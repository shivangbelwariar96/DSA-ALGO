| Problem | Approach | Visited? (Method) | Memo (DP)? | Time Complexity | Space Complexity | Key Considerations / Questions | Approach Detail |
|---------|----------|-------------------|------------|-----------------|------------------|--------------------------------|-----------------|
| Number of Islands | DFS or BFS | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Why DFS/BFS? Edge cases: empty grid. In-place modification ok? | Traverse from a '1', marking visited ('0' or separate bool array) to explore the connected component (island). Increment island count for each new '1' found. |
| Max Area of Island | DFS or BFS | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Reset max area for each new island. Handle grid of all zeros. | Similar to Number of Islands, but maintain a running count of cells within the current island during traversal and update the global max area. |
| Surrounded Regions ('O' to 'X') | DFS/BFS (from borders) | Yes (In-place mark '#') | No | O(m*n) | O(m*n) | Why start from borders? What if the border is 'X'? Flip remaining 'O's. | Start DFS/BFS from all 'O's on the grid borders. Mark these border-connected 'O's (e.g., with '#'). Then, iterate through the grid, changing remaining 'O's to 'X' and marked '#'s back to 'O'. |
| Number of Enclaves | DFS or BFS (from borders) | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Mark border-connected land. Count remaining unmarked land cells. | Start DFS/BFS from all '1's on the grid borders. Mark these border-connected '1's as visited. Finally, iterate through the grid and count any remaining '1's that were not visited (these are the enclaves). |
| Number of Closed Islands | DFS/BFS (borders first) | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Mark border land ('0'). Count remaining internal islands ('0' surrounded by '1'). Boundary conditions. | A closed island is an island not connected to the border. First, traverse from all '0's on the border and mark all reachable '0's (connected to the border). Then, iterate through the grid and count any remaining '0's that haven't been marked; each represents a closed island. |
| Shortest Bridge | DFS/BFS + Multi-source BFS | Yes (bool[][] x2) | No | O(m*n) | O(m*n) | Find island 1 (DFS/BFS), start BFS from it, find shortest path (flips) to island 2. | Use DFS/BFS to find the first island and mark all its cells as visited and add them to a queue. Then, perform a multi-source BFS starting from all cells of the first island, expanding layer by layer to find the shortest distance (number of flips) to reach any cell of the second island. |
| Flood Fill | DFS or BFS | Yes (Check color or bool[][]) | No | O(m*n) | O(m*n) | Base case: starting cell already has the new color. | Starting from the given cell, perform DFS/BFS to visit all connected cells with the original color. Change the color of each visited cell to the new color. Stop traversal when encountering cells of a different color or boundary. |
| Shortest Path in Binary Matrix | BFS | Yes (bool[][] or in-place) | No | O(m*n) | O(m*n) | Why BFS for shortest path? 8 directions? Handle blocked start/end. | Use BFS with a queue to explore the grid layer by layer. Start from (0,0). Store (row, col, distance) in the queue. Explore 8 directions. Mark visited cells. The first time the destination (n-1, m-1) is reached, the current distance is the shortest path. |
| 01 Matrix (Distance to nearest 0) | Multi-source BFS | Yes (bool[][]) | No | O(m*n) | O(m*n) | Why multi-source BFS? Initialize queue with all 0s. What if no 0s? | Initialize the distance matrix with infinity for 1s and 0 for 0s. Add all cells containing 0 to a queue. Perform a multi-source BFS, updating the distance of neighboring 1s with distance + 1 if the new distance is smaller. |
| Rotting Oranges | Multi-source BFS | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Multi-source BFS. Track time levels. How to check if impossible (fresh remain)? | Initialize a queue with all initially rotten oranges (2s). Keep track of the time elapsed (number of BFS levels). In each level, process all rotten oranges and turn adjacent fresh oranges (1s) into rotten oranges, adding them to the queue for the next level. After BFS, check if any fresh oranges remain; if so, it's impossible (-1), otherwise, the time is the last level reached. |
| Minimum Knight Moves | BFS | Yes (Set or bool[][]) | No | O(m*n) or O(|x|*|y|) | O(m*n) | Why BFS? Handle infinite board. Symmetry in moves. | Use BFS starting from (0,0) to reach (x,y). Store (row, col, steps) in the queue. Explore 8 knight moves. Use a visited set to avoid cycles. The first time (x,y) is reached, return the steps. Optimize using symmetry or bidirectional BFS. |
| Word Search | DFS (backtracking) | Yes (In-place mark '#') | No | O(mn*3^L) or O(mn*4^L) | O(L) (recursion) | L=word length. Why backtracking? Mark visited & backtrack. Pruning? | Start DFS from each cell in the grid. The DFS function explores 4 directions. At each step, check if the current cell matches the corresponding character in the word. Mark the current cell as visited (e.g., change temporarily) before recursive calls and backtrack by restoring its original value after the calls return. If the entire word is found, return true. |
| Unique Paths I | DP | No | Yes | O(m*n) | O(m*n) or O(n) | Base cases? Relation: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Space optimization? | Use a 2D DP table dp[m][n] where dp[i][j] is the number of unique paths to reach cell (i, j). Base cases: dp[0][j] = 1 and dp[i][0] = 1 (assuming the top-left is (0,0)). The recurrence is dp[i][j] = dp[i-1][j] + dp[i][j-1] for i > 0 and j > 0. Can be optimized to O(n) space using only the previous row/column. |
| Unique Paths II (Obstacles) | DP | No | Yes | O(m*n) | O(m*n) or O(n) | How do obstacles affect DP relation? Handle obstacle at start/end. | Similar to Unique Paths I, but if a cell (i, j) contains an obstacle, dp[i][j] = 0. The base cases and recurrence relation are adjusted to handle obstacles. If the start or end is an obstacle, the result is 0. |
| Minimum Path Sum | DP | No | Yes | O(m*n) | O(m*n) or O(n) | Relation: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]). Base cases? | Use a 2D DP table dp[m][n] where dp[i][j] is the minimum path sum to reach cell (i, j). Base case: dp[0][0] = grid[0][0]. For the first row and column, dp[i][0] = dp[i-1][0] + grid[i][0] and dp[0][j] = dp[0][j-1] + grid[0][j]. The recurrence is dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) for i > 0 and j > 0. Can be optimized to O(n) space. |
| Longest Increasing Path | DFS + Memo (DP) | No (Implicit via DP state) | Yes | O(m*n) | O(m*n) | Why DFS + Memo? Each cell is a potential start. Relation depends on neighbors. | For each cell (i, j), perform a DFS to find the length of the longest increasing path starting from that cell. Use memoization (a 2D DP table memo[m][n]) to store the computed length for each cell. The DFS explores neighbors with strictly greater values. If the result for a neighbor is already memoized, use it; otherwise, recursively compute it. The result for dp[i][j] is 1 + the maximum length from its valid neighbors. |
| Unique Paths III (Visit all squares) | DFS (backtracking) | Yes (bool[][] or in-place) | No | O(mn*3^(empty)) | O(m*n) | Need to count empty squares. Track visited count in DFS state. Start/End points fixed. | Use DFS with backtracking. The state of the DFS should include the current cell (r, c), the number of steps taken, and potentially a visited set/array. Count the total number of non-obstacle squares (empty_squares). Start DFS from the starting cell. Explore 4 directions. Mark visited cells. If the current cell is the end cell and the number of steps equals empty_squares, increment the valid path count. Backtrack by unmarking the cell. |
| Spiral Matrix | Simulation | Yes (Implicit boundary move) | No | O(m*n) | O(1) (excluding output) | Manage 4 boundaries (top, bottom, left, right). Shrink boundaries carefully. Edge cases? | Simulate the traversal layer by layer. Maintain four boundaries: top, bottom, left, and right. Traverse right (top row), then down (right column), then left (bottom row), then up (left column). After each traversal direction, shrink the corresponding boundary. Continue until top > bottom or left > right. |
| Rotate Image (90 degrees) | In-place (Transpose+Reverse) | No | No | O(n^2) | O(1) | How does transpose + reverse work? Handle non-square? (Usually square). | For a 90-degree clockwise rotation: First, transpose the matrix (swap elements matrix[i][j] and matrix[j][i]). Then, reverse each row of the transposed matrix. For a 90-degree counter-clockwise rotation, reverse each row first, then transpose. Works for square matrices. |
| Set Matrix Zeroes | In-place (Use 1st row/col) | No | No | O(m*n) | O(1) or O(m+n) | How to use first row/col without corrupting them? Handle zeroes in first row/col. | Use the first row and first column as markers. Iterate through the matrix; if matrix[i][j] == 0, set matrix[i][0] = 0 and matrix[0][j] = 0. Before using the first row/column as markers, use separate boolean variables to remember if the original first row or first column contained a zero. Finally, iterate again and set cells to zero based on the markers in the first row and column, and handle the first row/column based on the initial boolean flags. |
| Word Search II (Multiple words) | DFS + Trie | Yes (In-place mark '#') | No | O(mn*TrieNodes) | O(TrieSize + Lmax) | Build Trie first. Prune search path in DFS using Trie. Backtracking essential. | Build a Trie of all the words. Perform DFS from each cell in the grid. During DFS, traverse the Trie based on the characters encountered. If a path in the grid corresponds to a complete word in the Trie, add the word to the result and mark the word in the Trie as found (to avoid duplicates and re-finding). Backtrack after exploring a path. Prune the search if the current character does not lead to a valid path in the Trie. |
| Dungeon Game | DP (Bottom-up or Top-down) | No | Yes | O(m*n) | O(m*n) or O(n) | Why start from bottom-right? State: min health needed at (i,j). Ensure health > 0. | Use DP to calculate the minimum health required to reach the destination from each cell. Start DP from the bottom-right cell and work upwards and leftwards. The state dp[i][j] represents the minimum health needed when arriving at cell (i, j) to survive the path to the destination. The recurrence is dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]). The final answer is dp[0][0]. Need to handle boundary conditions and ensure health is always at least 1. |
| Maximal Square (All '1's) | DP | No | Yes | O(m*n) | O(m*n) or O(n) | State: dp[i][j] = side length ending at (i,j). Relation: 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]). | Use a 2D DP table dp[m][n] where dp[i][j] represents the side length of the largest square of 1s ending at cell (i, j). If matrix[i][j] == '0', dp[i][j] = 0. If matrix[i][j] == '1', dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]). The result is the square of the maximum value in the DP table. Can be optimized to O(n) space. |
| Valid Sudoku | HashSet validation | No | No | O(1) (9*9 = 81) | O(1) | Check rows, columns, and 3x3 subgrids independently. Use Sets to detect duplicates. | Iterate through the grid. For each cell (r, c), check if the number board[r][c] is already present in the set for row r, column c, and the 3x3 subgrid it belongs to. Use three sets (or equivalent structures) to track numbers seen in each row, column, and subgrid simultaneously. If a duplicate is found, the Sudoku is invalid. The grid size is fixed (9x9), making it O(1). |
| Minesweeper | DFS or BFS | Yes (bool[][] or in-place) | No | O(m*n) | O(m*n) | If click mine -> 'X'. If empty -> reveal neighbors (DFS/BFS). If number -> reveal number. | If the clicked cell is a mine ('M'), change it to 'X'. If it's an empty cell ('E'): count adjacent mines. If the count is 0, change 'E' to 'B' and recursively/iteratively (DFS/BFS) reveal all adjacent unrevealed empty cells. If the count is > 0, change 'E' to the count. If it's already a number, do nothing. |
| Count Square Submatrices with All Ones | DP | No | Yes | O(m*n) | O(m*n) or O(n) | Similar to Maximal Square DP. Sum up all dp[i][j] values. | Use a 2D DP table dp[m][n] where dp[i][j] represents the side length of the largest square of 1s ending at cell (i, j). If matrix[i][j] == 0, dp[i][j] = 0. If matrix[i][j] == 1, dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]). The total number of square submatrices is the sum of all values in the DP table. Can be optimized to O(n) space. |
| Pacific Atlantic Water Flow | DFS/BFS (from borders) | Yes (bool[][] per ocean) | No | O(m*n) | O(m*n) | Why start from borders? Find intersection of cells reachable by both oceans. | Perform two separate DFS/BFS traversals: one starting from all cells on the Pacific border, marking all reachable cells. Another starting from all cells on the Atlantic border, marking all reachable cells. A cell can flow to both oceans if it is reachable by both the Pacific-originated traversal and the Atlantic-originated traversal. Find the intersection of the cells marked in both traversals. |
| Max Sum of Rectangle No Larger Than K | Kadane's variation + Prefix Sum | No | No (uses BST/Set) | O(cols^2 * rows*log(rows)) | O(rows) | Fix left/right cols, calculate prefix sums for rows, use TreeSet/BST for <= K check. | Iterate through all possible pairs of left and right columns. For each pair, calculate a 1D array representing the sum of elements in each row between these two columns. Then, find the maximum sum subarray in this 1D array that is no larger than K. This subproblem can be solved efficiently using prefix sums and a balanced binary search tree (like TreeSet in Java or similar structures) to find the required prefix sum difference. |
| As Far from Land as Possible (1 vs 0) | Multi-source BFS | Yes (bool[][]) | No | O(n^2) | O(n^2) | BFS from all land (1s). Return max distance, or -1 if all land/water. | Initialize a queue with the coordinates of all land cells (1s). Use a visited array or modify the grid in-place to mark visited cells. Perform a multi-source BFS, expanding from all land cells simultaneously. The distance increases by 1 at each level of the BFS. The maximum distance reached for any water cell (0) is the answer. If there are no land cells or no water cells, return -1. |
| Shortest Distance from All Buildings | BFS (from each building) | Yes (bool[][] per BFS) | No | O(B*m*n) B=buildings | O(m*n) | Run BFS from each building. Sum distances. Handle unreachable cells. Optimization? | For each building, perform a BFS to calculate the shortest distance from that building to all reachable empty cells (0s). Maintain a total distance grid and a reachability count grid for empty cells. Sum the distances from each building in the total distance grid. An empty cell is reachable from all buildings if its reachability count equals the number of buildings. The minimum value in the total distance grid for cells reachable from all buildings is the answer. Handle unreachable cells (those not reached by all buildings). |
| Kth Smallest Number in Sorted Matrix | Binary Search or Min-Heap | No | No | O(n*log(max-min)) / O(k*log n) | O(1) / O(n) | BS on value range + count <= mid. MinHeap stores (val, row, col). | Binary Search: Binary search on the range of values in the matrix (from min to max element). For a given mid value, count how many elements in the matrix are less than or equal to mid. If this count is >= k, the k-th smallest is <= mid; otherwise, it's > mid. Min-Heap: Use a min-heap to store tuples of (value, row, col). Initialize the heap with the first element of each row. Repeatedly extract the minimum from the heap and, if the extracted element is not the last in its row, add the next element from that row to the heap. After k extractions, the last extracted value is the k-th smallest. |
| Robot Room Cleaner | DFS (backtracking) | Yes (Set<Pair>) | No | O(CellsVisited=m*n) | O(CellsVisited) | Use relative coordinates. Need move() and clean() API. Backtrack essential. Store visited absolute coords. | Use DFS to explore the grid. Since the grid is unknown, use relative directions and a visited set to keep track of absolute coordinates (calculated from the starting position and moves). At each step, clean() the current cell. Try moving in each of the four directions. If a move is successful and the cell hasn't been visited, recursively call DFS for the new position. After exploring a direction, backtrack: move back to the previous cell and rotate the robot's direction to its original orientation before the move. |
| Path With Minimum Effort | Dijkstra or Binary Search+BFS | Yes (bool[][] in BFS) | No | O(m*n*log(m*n)) / O(m*n*log H) | O(m*n) | Dijkstra on (effort, r, c). BS on max allowed effort + BFS check feasibility. | Dijkstra: Use Dijkstra's algorithm to find the path from (0,0) to (m-1, n-1) with the minimum maximum effort difference along the path. The states in the priority queue are (effort, row, col). The effort to reach a cell is the maximum effort difference encountered on the path from the start. Binary Search + BFS: Binary search on the possible range of minimum maximum effort values (from 0 to the maximum possible height difference). For a given effort_limit, use BFS or DFS to check if there's a path from (0,0) to (m-1, n-1) where the absolute height difference between adjacent cells is always less than or equal to effort_limit. |
| Walls and Gates | Multi-source BFS | Yes (Check INF or bool[][]) | No | O(m*n) | O(m*n) | Start BFS from all gates (0). Update INF distance. Skip non-INF cells. | Initialize the distance matrix. Set cells with gates (0) to 0 distance and all other accessible cells (INF) to infinity. Add all gate cell coordinates to a queue. Perform a multi-source BFS. When exploring neighbors of a cell with distance d, if the neighbor is an accessible cell with distance infinity, update its distance to d + 1 and add it to the queue. Stop when the queue is empty. Obstacles (-1) are not visited. |
| Trapping Rain Water II | Min-Heap (PriorityQueue) + BFS | Yes (bool[][]) | No | O(m*n*log(m*n)) | O(m*n) | PQ stores (height, r, c). Start from border cells. Process lowest height boundary cell. | Use a min-heap (priority queue) to store (height, row, col) of cells. Initially, add all border cells to the min-heap and mark them as visited. While the min-heap is not empty, extract the cell with the minimum height. This height represents the current "water level". Explore its unvisited neighbors. If a neighbor's height is less than the current water level, the water can be trapped above it; add the difference to the total trapped water. Add the neighbor to the min-heap with height equal to the maximum of its actual height and the current water level, and mark it visited. If the neighbor's height is greater than or equal to the current water level, it becomes a new boundary; add it to the min-heap with its actual height and mark it visited. |
| Island Perimeter | Loop or DFS | No (or Yes for DFS) | No | O(m*n) | O(1) or O(m*n) | Loop: Add 4 for land, subtract 2 for each shared edge. DFS: Sum perimeter during traversal. | Loop: Iterate through the grid. For each land cell (1), initialize its perimeter contribution to 4. Subtract 1 for each of its 4 neighbors that is also a land cell (check bounds). Sum the contributions of all land cells. DFS: Start DFS from a land cell. Mark visited cells. For each land cell, check its 4 neighbors. If a neighbor is water (0) or out of bounds, it contributes 1 to the perimeter. Sum these contributions during the DFS traversal. Ensure each land cell is visited only once. |
| Number of Distinct Islands | DFS + HashSet<String> | Yes (In-place or bool[][]) | No | O(m*n) | O(m*n) | Serialize island shape during DFS (e.g., "RDLU"). Store normalized paths in Set. | Iterate through the grid. When a new land cell ('1') is found, start a DFS to traverse the entire island. During the DFS, record the path taken to explore the island relative to the starting cell (e.g., using directional codes like 'U', 'D', 'L', 'R'). After visiting all cells in the island, normalize this path representation (e.g., always start from the top-leftmost cell of the island and represent the path from there). Store the normalized path string in a HashSet. The number of distinct islands is the size of the HashSet. Mark visited cells to avoid re-processing islands. |
| Knight Probability on Chessboard | DP | No | Yes | O(K*N^2) | O(N^2) | dp[k][r][c] = probability after k moves. Transition based on 8 knight moves. | Use a 3D DP table dp[k][r][c] where dp[k][r][c] is the probability that the knight is at cell (r, c) after making k moves. Base case: dp[0][start_r][start_c] = 1. For each move k from 1 to K, iterate through all cells (r, c). For each possible knight move from (r, c), if the destination (nr, nc) is within the board, add dp[k-1][r][c] / 8 to dp[k][nr][nc]. The final answer is the sum of dp[K][r][c] for all valid cells (r, c). Space can be optimized to O(N^2) by using only two layers of DP (current and previous move). |
| Shortest Path w/ Obstacles Elimination | BFS with State | Yes (visited[r][c][k]) | No | O(m*n*k) | O(m*n*k) | State: (r, c, obstacles_eliminated). Add k dimension to visited array/set. | Use BFS. The state in the queue is (row, col, obstacles_eliminated, steps). Use a 3D visited array or set visited[m][n][k+1] to keep track of visited states, where visited[r][c][obs] is true if cell (r, c) has been visited with obs obstacles eliminated. Start BFS from (0, 0, 0, 0). Explore 4 directions. If a cell is an obstacle (-1) and obstacles_eliminated < k, move to the cell incrementing obstacles_eliminated. If it's an empty cell (0), move to the cell keeping obstacles_eliminated the same. Stop when the destination (m-1, n-1) is reached. The number of steps is the shortest path length. |
| Cherry Pickup | DP | No | Yes | O(N^3) or O(N^4) | O(N^2) or O(N^3) | Tricky DP state: dp[r1][c1][r2] (c2 derived) or dp[step][c1][c2]. Handle double counting. | Use DP where the state represents two people moving from (0,0) to (N-1, N-1) simultaneously. A common DP state is dp[r1][c1][r2], representing the maximum cherries collected when the first person is at (r1, c1) and the second person is at (r2, r1 + c1 - r2). The second person's column c2 is constrained because they take the same number of steps. The transition involves considering the four possible previous positions for the two people (up/left for person 1, up/left for person 2). Need to handle the case where both people are on the same cell (only collect cherries once) and obstacle cells (-1). The DP is often done top-down with memoization or bottom-up. |
| Game of Life | Simulation | No | No | O(m*n) per step | O(m*n) or O(1) | Need simultaneous updates. Use copy of grid or encode states in-place. Handle neighbors. | Simulate the game according to the rules. Since all updates must happen simultaneously, either create a copy of the board for the next state or use an in-place encoding scheme within the existing grid. For in-place, use extra states to represent cells that are currently alive but will die (e.g., 2) and cells that are currently dead but will become alive (e.g., 3). After calculating the next state for all cells using the original values of their neighbors, update the grid based on the encoded states. Iterate through the grid, count live neighbors for each cell, and apply the rules to determine the next state. |