| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 1 | Two Sum | 1 | https://leetcode.com/problems/two-sum/ | Use a HashMap to store encountered numbers and their indices. For each element nums[i], check if target - nums[i] (the complement) exists in the map. If yes, return indices. If no, add nums[i] and its index to the map. | HashMap for O(1) complement lookup. | Hash Map | O(n) | O(n) | `if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i);` |
| 2 | Longest Substring Without Repeating Characters | 3 | https://leetcode.com/problems/longest-substring-without-repeating-characters/ | Use a sliding window approach with two pointers (start, end) and a Set/Map to track characters within the window [start, end). Expand end. If s.charAt(end) is in the set, shrink the window by incrementing start and removing s.charAt(start) from the set until the duplicate is removed. Update max length. | Sliding window with Set/Map for efficient duplicate checks. | Sliding Window | O(n) | O(min(n, m)) (where m is alphabet size) | `if (set.contains(s.charAt(end))) { set.remove(s.charAt(start++)); } else { set.add(s.charAt(end++)); maxLen = Math.max(maxLen, end - start); }` |
| 3 | Median of Two Sorted Arrays | 4 | https://leetcode.com/problems/median-of-two-sorted-arrays/ | Use binary search on the smaller array to find the correct partition point partitionX. Calculate the corresponding partition partitionY in the other array such that partitionX + partitionY = (n+m+1)/2. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. Adjust binary search range based on comparison. | Binary search on partitions to find median in logarithmic time. | Binary Search | O(log(min(n, m))) | O(1) | `if (maxLeftX <= minRightY && maxLeftY <= minRightX) { // Found partition } else if (maxLeftX > minRightY) { high = partitionX - 1; } else { low = partitionX + 1; }` |
| 4 | Maximum Subarray | 53 | https://leetcode.com/problems/maximum-subarray/ | Kadane's Algorithm: Iterate through the array, maintaining currentMax (max sum ending at current position) and globalMax (max sum found so far). currentMax = max(num, currentMax + num). Update globalMax = max(globalMax, currentMax). | Kadane's: Discard subarray prefix if its sum becomes negative. | Dynamic Programming / Greedy | O(n) | O(1) | `currentMax = Math.max(num, currentMax + num); globalMax = Math.max(globalMax, currentMax);` |
| 5 | Merge Intervals | 56 | https://leetcode.com/problems/merge-intervals/ | Sort intervals based on start times. Iterate through sorted intervals, merging overlapping ones. If the current interval overlaps with the last merged interval in the result list (current.start <= last.end), update the end of the last interval (last.end = max(last.end, current.end)). Otherwise, add the current interval as a new entry. | Sort by start then merge greedily. | Sorting / Greedy | O(n log n) | O(n) (for result list) or O(log n) (for sort) | `if (merged.isEmpty() || current.start > merged.get(merged.size() - 1).end) { merged.add(current); } else { merged.get(merged.size() - 1).end = Math.max(merged.get(merged.size() - 1).end, current.end); }` |
| 6 | Reverse Linked List | 206 | https://leetcode.com/problems/reverse-linked-list/ | Iterative approach: Use three pointers: prev (initially null), curr (initially head), and nextTemp. While curr is not null, store curr.next in nextTemp, set curr.next to prev, update prev to curr, and move curr to nextTemp. | Iterative reversal using three pointers (prev, curr, next). | Linked List | O(n) | O(1) | `ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp;` |
| 7 | LRU Cache | 146 | https://leetcode.com/problems/lru-cache/ | Use a HashMap for O(1) key lookup and a Doubly Linked List (DLL) to maintain the order of usage. Map keys to DLL nodes. On get or put (update), move the accessed node to the front of the DLL. On put when capacity is reached, remove the node from the tail of the DLL and the corresponding entry from the map. | HashMap + Doubly Linked List for O(1) get/put. | Hash Map / Doubly Linked List | O(1) for get and put | O(capacity) | `// On access (get/put): removeNode(node); addToFront(node); // On put full: Node tail = removeTail(); map.remove(tail.key);` |
| 8 | Generate Parentheses | 22 | https://leetcode.com/problems/generate-parentheses/ | Use backtracking (recursive approach). Maintain counts of open and close parentheses used. Add '(' if open < n. Add ')' if close < open. Base case: if length is 2*n, add the string to the result list. | Backtracking with constraints on open/close counts. | Backtracking / Recursion | O(4^n / (n^(3/2))) (Catalan Number) | O(n) (recursion stack) + O(n * 4^n / (n^(3/2))) (result storage) | `if (open < max) backtrack(list, str + '(', open + 1, close, max); if (close < open) backtrack(list, str + ')', open, close + 1, max);` |
| 9 | Lowest Common Ancestor of a Binary Tree | 236 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ | Recursive approach. Base cases: If root is null, p, or q, return root. Recursively find LCA in left and right subtrees (leftLCA, rightLCA). If both are non-null, current root is LCA. If only one is non-null, return that one. If both are null, return null. | Recursive search; LCA is the node where paths to p and q diverge. | Tree / Recursion / DFS | O(n) | O(n) (worst case, skewed tree) O(h) (average, height) | `ListNode leftLCA = lowestCommonAncestor(root.left, p, q); ListNode rightLCA = lowestCommonAncestor(root.right, p, q); if (leftLCA != null && rightLCA != null) return root; return (leftLCA != null) ? leftLCA : rightLCA;` |
| 10 | Longest Increasing Subsequence | 300 | https://leetcode.com/problems/longest-increasing-subsequence/ | DP with Memoization: Define dp[i] as the LIS ending at index i. To compute dp[i], iterate j from 0 to i-1. If nums[i] > nums[j], then dp[i] = max(dp[i], 1 + dp[j]). Alternatively, O(n log n) approach using patience sorting (maintain tails of potential LIS). | DP state dp[i] = LIS length ending at i. (Or O(n log n) patience sort). | Dynamic Programming | O(n^2) for basic DP, O(n log n) optimized | O(n) | `for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLength = Math.max(maxLength, dp[i]);` (for O(n^2) DP) |
| 11 | Search in Rotated Sorted Array | 33 | https://leetcode.com/problems/search-in-rotated-sorted-array/ | Modified Binary Search. Find the pivot point (minimum element) first OR directly adapt binary search. In each step, determine which half (left or right of mid) is sorted. Check if the target lies within the sorted half's range. Adjust low and high accordingly. | Modified binary search adapting to the rotation point. | Binary Search | O(log n) | O(1) | `if (nums[low] <= nums[mid]) { // Left half sorted if (target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; } else { // Right half sorted ... }` |
| 12 | Number of Islands | 200 | https://leetcode.com/problems/number-of-islands/ | Iterate through the grid. If a cell contains '1' and hasn't been visited, increment the island count and start a DFS or BFS from that cell to mark all connected '1's as visited (e.g., change '1' to '0' or use a separate visited array). | DFS/BFS traversal to explore and mark connected land cells. | Graph Traversal (DFS/BFS) | O(m*n) | O(m*n) (recursion stack for DFS or queue/visited array for BFS) | `if (grid[r][c] == '1') { count++; dfs(grid, r, c); // or bfs } // dfs(grid, r, c): mark grid[r][c] = '0'; explore neighbors` |
| 13 | Container With Most Water | 11 | https://leetcode.com/problems/container-with-most-water/ | Use two pointers, left at index 0 and right at index n-1. Calculate area min(height[left], height[right]) * (right - left). Update max area. Move the pointer pointing to the shorter line inward (left++ if height[left] < height[right], else right--). | Two pointers: move the shorter height pointer inward. | Two Pointers | O(n) | O(1) | `area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--;` |
| 14 | Trapping Rain Water | 42 | https://leetcode.com/problems/trapping-rain-water/ | Calculate maxLeft[i] (max height to the left of i) and maxRight[i] (max height to the right of i) for all i. The water trapped at index i is max(0, min(maxLeft[i], maxRight[i]) - height[i]). Sum these amounts. Can be optimized to O(1) space using two pointers. | Water at i depends on min(max_left, max_right) - height[i]. | Dynamic Programming / Two Pointers | O(n) | O(n) (for DP arrays) or O(1) (for Two Pointer) | `water += Math.max(0, Math.min(maxLeft[i], maxRight[i]) - height[i]); // DP <br> // Two Pointer: if (leftMax < rightMax) { water += leftMax - height[left]; left++; } else { water += rightMax - height[right]; right--; }` |
| 15 | Merge Two Sorted Lists | 21 | https://leetcode.com/problems/merge-two-sorted-lists/ | Iterative approach: Use a dummy head node. Maintain a current pointer for the merged list. Compare heads of list1 and list2. Append the smaller node to current.next and advance that list's pointer. Update current. After loop, append the remaining non-null list. | Dummy head node simplifies merging logic. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode dummy = new ListNode(0); ListNode current = dummy; ... if (list1.val <= list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; ... return dummy.next;` |
| 16 | Add Two Numbers | 2 | https://leetcode.com/problems/add-two-numbers/ | Iterate through both lists simultaneously using a dummy head for the result list. Keep track of carry. At each step, calculate sum = l1.val + l2.val + carry. The digit for the new node is sum % 10, and the new carry is sum / 10. Handle remaining nodes and final carry. | Simulate elementary addition with carry using linked lists. | Linked List / Simulation | O(max(n, m)) | O(max(n, m)) (for result list) | `int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); carry = sum / 10; curr.next = new ListNode(sum % 10); ...` |
| 17 | Binary Tree Inorder Traversal | 94 | https://leetcode.com/problems/binary-tree-inorder-traversal/ | Recursive approach: Helper function inorder(node, list). Base case: if node is null, return. Recursively call inorder(node.left, list), then add node.val to the list, then recursively call inorder(node.right, list). Iterative uses a Stack. | Standard recursive inorder traversal (Left-Root-Right). | Tree Traversal (DFS) | O(n) | O(n) (recursion stack / explicit stack) | `inorder(node.left, result); result.add(node.val); inorder(node.right, result);` |
| 18 | Validate Binary Search Tree | 98 | https://leetcode.com/problems/validate-binary-search-tree/ | Recursive approach: Pass down valid range (min, max) for each node. For a node, check if node.val > min and node.val < max. Recursively call for left child with range (min, node.val) and right child with range (node.val, max). | Recursive check passing valid range [min, max] down. | Tree Traversal (DFS) | O(n) | O(n) (recursion stack) | `return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);` |
| 19 | Binary Tree Level Order Traversal | 102 | https://leetcode.com/problems/binary-tree-level-order-traversal/ | Use Breadth-First Search (BFS) with a Queue. Initialize queue with root. While queue is not empty, get the size (levelSize). Process levelSize nodes: dequeue node, add its value to current level list, enqueue its non-null children. Add level list to result. | BFS using a queue to process nodes level by level. | Tree Traversal (BFS) | O(n) | O(w) (where w is max width of tree/queue size) | `int levelSize = queue.size(); List<Integer> currentLevel = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); ... queue.offer(child); }` |
| 20 | Serialize and Deserialize Binary Tree | 297 | https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ | Serialization (e.g., Preorder): Use DFS. Append node value to string/builder. If null, append a marker (e.g., 'null' or '#'). Recursively serialize left and right. Deserialization: Use a Queue/Iterator of the split serialized string. Build tree recursively. Read value, if marker, return null. Create node, recursively build left, then right. | Use Preorder/Level Order traversal with null markers for serialization. Rebuild recursively/iteratively during deserialization. | Tree Traversal (DFS/BFS) | O(n) | O(n) | `// Serialize (Preorder) sb.append(node.val).append(','); serializeHelper(node.left, sb); serializeHelper(node.right, sb); // Deserialize (Preorder) String val = nodes.poll(); if (val.equals("#")) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(nodes); node.right = deserializeHelper(nodes);` |
| 21 | Coin Change | 322 | https://leetcode.com/problems/coin-change/ | DP with Memoization. memo[amount] stores min coins for that amount. Base case: memo[0]=0. Recursive step: memo[amount] = 1 + min(solve(amount - coin)) for each coin c <= amount. Initialize memo with -1 (uncomputed) or Integer.MAX_VALUE. | DP state memo[i] = min coins for amount i. Check for Integer.MAX_VALUE to handle impossible cases. | Dynamic Programming | O(amount * coins) | O(amount) | `if (memo[rem] != -1) return memo[rem]; int minCoins = Integer.MAX_VALUE; for (int coin : coins) { if (rem >= coin) { int res = solve(rem - coin); if (res != Integer.MAX_VALUE) minCoins = Math.min(minCoins, 1 + res); } } memo[rem] = minCoins;` |
| 22 | Find Minimum in Rotated Sorted Array | 153 | https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ | Modified Binary Search. Compare nums[mid] with nums[high]. If nums[mid] < nums[high], the minimum is in the left half (including mid), so high = mid. Otherwise, the minimum is in the right half (mid + 1), so low = mid + 1. Loop ends when low == high. | Compare mid with high to decide which half contains the pivot/minimum. | Binary Search | O(log n) | O(1) | `if (nums[mid] < nums[high]) { high = mid; } else { low = mid + 1; }` |
| 23 | Course Schedule | 207 | https://leetcode.com/problems/course-schedule/ | Topological Sort using Kahn's Algorithm (BFS). Build adjacency list and calculate in-degrees. Initialize queue with nodes having in-degree 0. Process queue: dequeue node, decrement in-degree of neighbors. If neighbor's in-degree becomes 0, enqueue it. Count processed nodes; if count equals numCourses, return true. | Kahn's Algorithm (BFS + in-degree counting) for cycle detection. | Graph / Topological Sort | O(V+E) | O(V+E) (for adjacency list and in-degrees) | `Queue<Integer> queue = new LinkedList<>(); // Add nodes with inDegree 0 while (!queue.isEmpty()) { int course = queue.poll(); count++; for (int neighbor : adj.get(course)) { if (--inDegree[neighbor] == 0) queue.offer(neighbor); } } return count == numCourses;` |
| 24 | Word Ladder | 127 | https://leetcode.com/problems/word-ladder/ | BFS on implicit graph. Start BFS from beginWord. Each level represents one transformation. Use a Set for wordList for O(1) lookup and a Set for visited words. In each step, generate all possible 1-letter transformations of the current word. If a transformation is in wordList and not visited, add to queue and mark visited. | BFS for shortest path in unweighted graph. Generate neighbors by changing one char at a time. | Graph / BFS | O(N * M^2) (N=wordList size, M=word length) | O(N*M) (for word set and visited set/queue) | `for (int i = 0; i < word.length(); i++) { char[] chars = word.toCharArray(); for (char c = 'a'; c <= 'z'; c++) { chars[i] = c; String neighbor = new String(chars); if (wordSet.contains(neighbor) && !visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } }` |
| 25 | Group Anagrams | 49 | https://leetcode.com/problems/group-anagrams/ | Use a HashMap where the key represents the character count/sorted version of a string, and the value is a list of anagrams. Iterate through strs, generate the key for each string (e.g., sort the string or create a count array string like 'a1b1c0...'), and add the original string to the list associated with that key. | Canonical representation (sorted string or char count) as HashMap key. | Hash Map | O(N * K log K) or O(N*K) (N=num strings, K=max length) | O(N*K) (for storing anagram groups) | `char[] ca = str.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);` |
| 26 | Valid Parentheses | 20 | https://leetcode.com/problems/valid-parentheses/ | Use a Stack. Iterate through the string. If an opening bracket ('(', '{', '[') is encountered, push it onto the stack. If a closing bracket is found, check if the stack is empty or if the top element is the corresponding opening bracket. If not, return false. Pop if it matches. After iteration, the stack must be empty. | Stack to match opening/closing brackets LIFO order. | Stack | O(n) | O(n) | `if (c == '(' || c == '{' || c == '[') stack.push(c); else if (stack.isEmpty() || !isMatching(stack.pop(), c)) return false;` |
| 27 | Combination Sum | 39 | https://leetcode.com/problems/combination-sum/ | Backtracking/DFS. Define a recursive function findCombinations(index, currentSum, currentList). Base cases: if currentSum == target, add currentList to results. If currentSum > target or index >= candidates.length, return. Recursive step: Include candidates[index] (call findCombinations(index, ..., ...) again) and Exclude candidates[index] (call findCombinations(index + 1, ..., ...)). | Standard backtracking allowing element reuse. | Backtracking / Recursion | O(N^(T/M)) (approx, N=candidates, T=target, M=min candidate) | O(T/M) (recursion depth) + O(Result Size) | `// Include candidate[i] currentList.add(candidates[i]); backtrack(result, currentList, candidates, remaining - candidates[i], i); // crucial: pass i not i+1 currentList.remove(currentList.size() - 1); // Backtrack` |
| 28 | Permutations | 46 | https://leetcode.com/problems/permutations/ | Backtracking/DFS. Use a boolean used array or swap elements. Define backtrack(currentPermutation). Base case: if currentPermutation.size() == nums.length, add to results. Loop through nums: if nums[i] is not used, add it to currentPermutation, mark as used, recurse (backtrack(...)), unmark, remove from currentPermutation. | Backtracking with mechanism (visited array/swapping) to track used elements. | Backtracking / Recursion | O(N * N!) | O(N) (recursion depth) + O(N * N!) (result storage) | `if (tempList.size() == nums.length) { result.add(new ArrayList<>(tempList)); } else { for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; tempList.add(nums[i]); backtrack(result, tempList, nums, used); tempList.remove(tempList.size() - 1); used[i] = false; } }` |
| 29 | Word Search | 79 | https://leetcode.com/problems/word-search/ | Backtracking/DFS. Iterate through each cell as a potential starting point. Call DFS helper search(r, c, index). Base case: index == word.length(), return true. Check bounds, if board[r][c] != word.charAt(index), return false. Mark current cell (e.g., board[r][c] = '#'). Explore 4 neighbors recursively search(nr, nc, index + 1). If any returns true, return true. Unmark cell (backtrack) board[r][c] = originalChar. Return false if no path found. | DFS with backtracking (marking visited path). | Backtracking / DFS | O(N * M * 4^L) (N, M=dims, L=word length) | O(L) (recursion depth) | `char temp = board[r][c]; board[r][c] = '#'; // Mark visited boolean found = dfs(board, r+1, c, word, index+1) || dfs(board, r-1, c, word, index+1) || dfs(board, r, c+1, word, index+1) || dfs(board, r, c-1, word, index+1); board[r][c] = temp; // Backtrack` |
| 30 | Sudoku Solver | 37 | https://leetcode.com/problems/sudoku-solver/ | Backtracking. Find the next empty cell ('.'). Try filling it with digits '1' through '9'. For each digit, check if it's valid (using helper isValid(row, col, digit) checking row, col, and 3x3 subgrid). If valid, place digit and recursively call solve(). If recursive call returns true, return true. If not, backtrack (reset cell to '.'). If no digit works for the cell, return false. Base case: no empty cells found, return true. | Backtracking search trying digits 1-9 in empty cells, pruning invalid states. | Backtracking / Recursion | O(9^(N*N)) (with pruning, much faster in practice) | O(N*N) (recursion depth/board state) | `for (char c = '1'; c <= '9'; c++) { if (isValid(board, row, col, c)) { board[row][col] = c; if (solve(board)) return true; board[row][col] = '.'; // Backtrack } } return false;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 32 | Minimum Window Substring | 76 | https://leetcode.com/problems/minimum-window-substring/ | Sliding Window with Frequency Maps. Use two HashMaps (or arrays) `tFreq` for pattern `t` and `windowFreq` for current window in `s`. Use `required` count (distinct chars in `t`) and `formed` count (distinct chars in window matching `required` count). Expand `end` pointer, update `windowFreq` and `formed`. When `formed == required`, shrink `start` pointer, update window, check if still valid (`formed == required`), and update min window. | Sliding window with two pointers and frequency maps to track character counts. | Sliding Window / Hash Map | O(\|S\| + \|T\|) | O(\|T\|) or O(alphabet size) | `while (formed == required) { // Shrink window updateMinWindow(...); char leftChar = s.charAt(start); windowFreq[leftChar]--; if (tFreq.containsKey(leftChar) && windowFreq[leftChar] < tFreq.get(leftChar)) { formed--; } start++; }` |
| 33 | 3Sum | 15 | https://leetcode.com/problems/3sum/ | Sort the array. Iterate through the array with index `i` from 0 to n-3. For each `nums[i]`, use two pointers `left = i + 1` and `right = n - 1`. Calculate `sum = nums[i] + nums[left] + nums[right]`. If `sum == 0`, add `[nums[i], nums[left], nums[right]]` to result, increment `left`, decrement `right`, and skip duplicates. If `sum < 0`, `left++`. If `sum > 0`, `right--`. Skip duplicates for `i` as well. | Sort + Two Pointers approach after fixing one element. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) depending on sort | `while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { result.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left < right && nums[left] == nums[left+1]) left++; // Skip duplicates while (left < right && nums[right] == nums[right-1]) right--; left++; right--; } else if (sum < 0) left++; else right--; }` |
| 34 | Merge k Sorted Lists | 23 | https://leetcode.com/problems/merge-k-sorted-lists/ | Use a Min-Heap (PriorityQueue) to store the head nodes of the k lists, ordered by value. Repeatedly extract the minimum node from the heap, add it to the result list (using a dummy head), and if the extracted node has a `next`, add `next` to the heap. | Min-Heap to efficiently find the smallest current element across k lists. | Heap (Priority Queue) | O(N log k) N=total nodes, k=lists | O(k) for heap, O(N) for result list | `PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val)); for (ListNode node : lists) { if (node != null) pq.offer(node); } while (!pq.isEmpty()) { ListNode minNode = pq.poll(); current.next = minNode; current = current.next; if (minNode.next != null) pq.offer(minNode.next); }` |
| 35 | Construct Binary Tree from Preorder and Inorder Traversal | 105 | https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ | Recursive approach. Use preorder to identify the root (`preorder[preStart]`). Find the root's index (`inIndex`) in the inorder traversal (use a HashMap for O(1) lookup). Elements left of `inIndex` in inorder form the left subtree, elements right form the right subtree. Recursively build left subtree using `preorder[preStart+1 ...]` and `inorder[inStart ... inIndex-1]`. Recursively build right subtree using remaining preorder and `inorder[inIndex+1 ... inEnd]`. | Preorder gives root, Inorder splits left/right subtrees. HashMap for Inorder lookup. | Tree / Recursion / DFS / Hash Map | O(N) | O(N) for map and recursion stack | `int rootVal = preorder[preStart]; TreeNode root = new TreeNode(rootVal); int inIndex = map.get(rootVal); int leftSize = inIndex - inStart; root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, inorder, inStart, inIndex - 1, map); root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, inorder, inIndex + 1, inEnd, map);` |
| 36 | Longest Palindromic Substring | 5 | https://leetcode.com/problems/longest-palindromic-substring/ | Expand Around Center approach. Iterate through the string, considering each character `i` and each pair `(i, i+1)` as potential centers of a palindrome. For each center, expand outwards (`left--`, `right++`) while `s.charAt(left) == s.charAt(right)`. Keep track of the longest palindrome found. | Expand from center (odd and even length palindromes). | String / Dynamic Programming / Two Pointers | O(n^2) | O(1) | `for (int i = 0; i < s.length(); i++) { expandAroundCenter(s, i, i); // Odd length expandAroundCenter(s, i, i + 1); // Even length } // expandAroundCenter updates global start/maxLength` |
| 37 | Contains Duplicate | 217 | https://leetcode.com/problems/contains-duplicate/ | Use a HashSet. Iterate through the array `nums`. For each number, try to add it to the set. If `set.add(num)` returns `false`, it means the number is already in the set, so return `true`. If the loop finishes without finding duplicates, return `false`. | HashSet for O(1) average time duplicate checking. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) { if (!set.add(num)) return true; } return false;` |
| 38 | Longest Repeating Character Replacement | 424 | https://leetcode.com/problems/longest-repeating-character-replacement/ | Sliding Window. Maintain a window `[start, end]` and a frequency map (array `int[26]`) of characters in the window. Keep track of the frequency of the most frequent character (`maxFreq`). If `windowSize (end - start + 1) - maxFreq > k`, the window is invalid (too many replacements needed). Shrink the window by incrementing `start` and decrementing the count of `s.charAt(start)`. Update `maxLength` in each step. | Sliding window tracking max frequency and replacements needed. | Sliding Window / Hash Map | O(n) | O(1) (alphabet size 26) | `count[s.charAt(end) - 'A']++; maxFreq = Math.max(maxFreq, count[s.charAt(end) - 'A']); while (end - start + 1 - maxFreq > k) { count[s.charAt(start) - 'A']--; start++; // Note: maxFreq doesn't need explicit decrement here, it corrects itself } maxLength = Math.max(maxLength, end - start + 1);` |
| 39 | Sliding Window Maximum | 239 | https://leetcode.com/problems/sliding-window-maximum/ | Use a Deque (Double-Ended Queue) to store indices of elements in the current window. The deque maintains indices in decreasing order of their corresponding values in `nums`. Before adding a new index `i`, remove indices from the back whose values are less than or equal to `nums[i]`. Remove indices from the front that are out of the window `(deque.peekFirst() <= i - k)`. The maximum element for the window ending at `i` is always `nums[deque.peekFirst()]`. | Monotonic Decreasing Deque to efficiently query max in window. | Sliding Window / Deque | O(n) | O(k) | `while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) { deque.pollLast(); } deque.offerLast(i); if (deque.peekFirst() <= i - k) { deque.pollFirst(); } if (i >= k - 1) { result[i - k + 1] = nums[deque.peekFirst()]; }` |
| 40 | Linked List Cycle II | 142 | https://leetcode.com/problems/linked-list-cycle-ii/ | Floyd's Cycle-Finding Algorithm (Tortoise and Hare). Use two pointers, `slow` moving one step and `fast` moving two steps. If they meet, there's a cycle. To find the start of the cycle, reset `slow` to the head of the list. Then move both `slow` and `fast` (which is at the meeting point) one step at a time. They will meet again at the start of the cycle. | Floyd's algorithm: detect cycle, then find start node by moving one pointer from head and another from meeting point at same speed. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { // Cycle detected slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; // Cycle start } } return null;` |
| 42 | Reverse Nodes in k-Group | 25 | https://leetcode.com/problems/reverse-nodes-in-k-group/ | Recursive or Iterative. Iterative: Use a `dummy` head. Find the start (`groupPrev`) and end (`kth`) of a group of k nodes. If `kth` is null, break. Reverse the sublist from `groupPrev.next` to `kth` (using standard list reversal). Connect the previous part (`groupPrev`) to the new head of the reversed group, and connect the tail of the reversed group to the node after `kth`. Update `groupPrev` to the tail of the reversed group. | Reverse sublists of size k and reconnect them carefully. | Linked List | O(n) | O(1) iterative / O(n/k) recursive | `// Inside loop, after finding groupPrev and kth Node groupStart = groupPrev.next; Node groupEnd = kth; Node nextGroupStart = kth.next; // Reverse group from groupStart to groupEnd ... // Reconnect groupPrev.next = reversedHead; groupStart.next = nextGroupStart; // groupStart is now tail groupPrev = groupStart;` |
| 43 | Binary Tree Maximum Path Sum | 124 | https://leetcode.com/problems/binary-tree-maximum-path-sum/ | Recursive DFS approach. Define a helper function `maxGain(node)` that returns the maximum path sum starting at `node` and going downwards (either left or right). Inside `maxGain`, calculate `max(0, maxGain(node.left))` and `max(0, maxGain(node.right))`. Update a global `maxSum` variable with `node.val + leftGain + rightGain`. The function returns `node.val + max(leftGain, rightGain)`. | Recursive helper returns max gain downwards; global variable tracks max path sum possibly including split at node. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int leftGain = Math.max(0, maxGain(node.left)); int rightGain = Math.max(0, maxGain(node.right)); maxSum = Math.max(maxSum, node.val + leftGain + rightGain); // Update global return node.val + Math.max(leftGain, rightGain); // Return max path downwards` |
| 44 | Longest Common Subsequence | 1143 | https://leetcode.com/problems/longest-common-subsequence/ | DP with Memoization. `memo[i][j]` stores LCS length for `text1[i...]` and `text2[j...]`. Base case: if `i` or `j` reaches end, return 0. If `memo[i][j]` computed, return it. If `text1.charAt(i) == text2.charAt(j)`, result is `1 + solve(i+1, j+1)`. Otherwise, result is `max(solve(i+1, j), solve(i, j+1))`. Store and return result. | DP state `memo[i][j]` = LCS of suffixes starting at i,j. | Dynamic Programming | O(m*n) | O(m*n) | `if (memo[i][j] != null) return memo[i][j]; if (text1.charAt(i) == text2.charAt(j)) { memo[i][j] = 1 + solve(i + 1, j + 1, text1, text2, memo); } else { memo[i][j] = Math.max(solve(i + 1, j, text1, text2, memo), solve(i, j + 1, text1, text2, memo)); } return memo[i][j];` |
| 45 | Edit Distance | 72 | https://leetcode.com/problems/edit-distance/ | DP with Memoization. `memo[i][j]` stores min distance between `word1[i...]` and `word2[j...]`. Base cases: if `i` reaches end, return `len2 - j`; if `j` reaches end, return `len1 - i`. If `memo[i][j]` computed, return. If `word1[i] == word2[j]`, result is `solve(i+1, j+1)`. Otherwise, result is `1 + min(solve(i+1, j), solve(i, j+1), solve(i+1, j+1))` (delete, insert, replace). | DP state `memo[i][j]` = edit distance for suffixes. Consider match/replace, delete, insert options. | Dynamic Programming | O(m*n) | O(m*n) | `if (word1.charAt(i) == word2.charAt(j)) { memo[i][j] = solve(i + 1, j + 1, word1, word2, memo); } else { int delete = solve(i + 1, j, word1, word2, memo); int insert = solve(i, j + 1, word1, word2, memo); int replace = solve(i + 1, j + 1, word1, word2, memo); memo[i][j] = 1 + Math.min(delete, Math.min(insert, replace)); }` |
| 46 | Word Break | 139 | https://leetcode.com/problems/word-break/ | DP with Memoization. `memo[i]` stores whether `s[i...]` can be segmented. `memo` can be Boolean or Integer (0=uncomputed, 1=true, -1=false). Base case: if `i == s.length()`, return true. If `memo[i]` computed, return result. Iterate `j` from `i` to `s.length()-1`. If `s.substring(i, j+1)` is in `wordDict` and `solve(j+1)` returns true, set `memo[i] = true` and return true. If loop finishes, set `memo[i] = false`. | DP state `memo[i]` = can `s[i...]` be broken? Try all prefixes starting at `i`. | Dynamic Programming | O(n*m*k) n=s len, m=dict size, k=word len. Optimised O(n^2*k) or O(n^3) | O(n) | `if (memo[start] != null) return memo[start]; for (int end = start; end < s.length(); end++) { String word = s.substring(start, end + 1); if (wordDict.contains(word) && solve(end + 1, s, wordDict, memo)) { memo[start] = true; return true; } } memo[start] = false;` |
| 47 | Burst Balloons | 312 | https://leetcode.com/problems/burst-balloons/ | DP with Memoization. `memo[left][right]` stores max coins for bursting balloons *between* index `left` and `right` (exclusive). Add 1s at boundaries of `nums`. Iterate `k` from `left+1` to `right-1` representing the *last* balloon to burst in `(left, right)`. Cost is `nums[left]*nums[k]*nums[right] + solve(left, k) + solve(k, right)`. Maximize over `k`. | DP state `memo[l][r]` = max coins in `(l,r)`. Key is iterating the *last* balloon burst in the interval. | Dynamic Programming | O(n^3) | O(n^2) | `if (memo[left][right] > 0) return memo[left][right]; int maxCoins = 0; for (int k = left + 1; k < right; k++) { int coins = nums[left] * nums[k] * nums[right]; coins += solve(left, k, nums, memo) + solve(k, right, nums, memo); maxCoins = Math.max(maxCoins, coins); } memo[left][right] = maxCoins;` |
| 48 | Find First and Last Position of Element in Sorted Array | 34 | https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ | Binary Search twice. One search finds the leftmost index (`low`): if `nums[mid] == target`, potentially keep searching left (`high = mid - 1`), store `mid` as potential answer. Another search finds the rightmost index (`high`): if `nums[mid] == target`, potentially keep searching right (`low = mid + 1`), store `mid`. | Two modified binary searches: one biased left, one biased right. | Binary Search | O(log n) | O(1) | `// Find Leftmost int findBound(int[] nums, int target, boolean isFirst) { // ... inside BS loop if (nums[mid] == target) { index = mid; if (isFirst) high = mid - 1; else low = mid + 1; } //... } left = findBound(nums, target, true); right = findBound(nums, target, false);` |
| 49 | Course Schedule II | 210 | https://leetcode.com/problems/course-schedule-ii/ | Topological Sort (Kahn's or DFS). Kahn's: Same as Course Schedule I, but add dequeued nodes to a result list/array. If final count != numCourses, return empty array. DFS: Use 3 states (visiting, visited). Perform DFS. Add node to result list *after* visiting all neighbors (post-order). Reverse the result list. Detect cycles using 'visiting' state. | Topological sort storing the order. Return empty array if cycle detected. | Graph / Topological Sort | O(V+E) | O(V+E) | `// Kahn's: Add to result list after dequeuing // DFS: Add node to head of list/stack in post-order visit. Detect cycle with VISITING state. List<Integer> result = new ArrayList<>(); // Kahn's // ... add to queue, process ... result.add(course); // Add node after processing it // ... return result.stream().mapToInt(i->i).toArray(); // if count == numCourses` |
| 50 | Implement Trie (Prefix Tree) | 208 | https://leetcode.com/problems/implement-trie-prefix-tree/ | Create a `TrieNode` class containing `children` (e.g., `TrieNode[26]` or `Map<Character, TrieNode>`) and an `isEndOfWord` boolean flag. `insert`: Traverse from root, creating nodes if they don't exist. Mark `isEndOfWord` at the end. `search`: Traverse from root. If path exists and ends with `isEndOfWord`, return true. `startsWith`: Traverse from root. If path exists, return true. | Node-based structure where each node represents a character and path represents prefix/word. | Trie / Design | O(L) for ops, L=word length | O(N*L) total nodes/chars | `class TrieNode { TrieNode[] children = new TrieNode[26]; boolean isEndOfWord; } // Insert: TrieNode curr = root; for (char c : word.toCharArray()) { if (curr.children[c - 'a'] == null) curr.children[c - 'a'] = new TrieNode(); curr = curr.children[c - 'a']; } curr.isEndOfWord = true;` |
| 51 | Rotate Array | 189 | https://leetcode.com/problems/rotate-array/ | Reversal Algorithm: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining `n-k` elements. (Make sure `k = k % n`). This is O(n) time and O(1) space. | Three reversals achieve rotation in-place. | Array Manipulation | O(n) | O(1) | `k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);` |
| 52 | Sort Colors | 75 | https://leetcode.com/problems/sort-colors/ | Dutch National Flag algorithm (3-way partitioning). Use three pointers: `low=0`, `mid=0`, `high=n-1`. While `mid <= high`: If `nums[mid] == 0`, swap `nums[low]` and `nums[mid]`, increment both `low` and `mid`. If `nums[mid] == 1`, increment `mid`. If `nums[mid] == 2`, swap `nums[mid]` and `nums[high]`, decrement `high` (do not increment `mid` as swapped element needs checking). | Dutch National Flag (DNF) algorithm for 3-way partition. | Array / Two Pointers / Sorting | O(n) | O(1) | `while (mid <= high) { if (nums[mid] == 0) { swap(nums, low++, mid++); } else if (nums[mid] == 1) { mid++; } else { swap(nums, mid, high--); } }` |
| 53 | Find All Anagrams in a String | 438 | https://leetcode.com/problems/find-all-anagrams-in-a-string/ | Sliding Window with Character Counts. Maintain two frequency maps (arrays `int[26]`), one for pattern `p` (`pCount`) and one for the current window in `s` (`sCount`). Initialize window of size `p.length()`. Compare `sCount` and `pCount`. Slide the window one step at a time: decrement count for char leaving window, increment count for char entering window. Compare counts at each step. | Sliding window with frequency map comparison. | Sliding Window / Hash Map | O(\|S\|) | O(1) (alphabet size 26) | `int[] pCount = new int[26]; int[] sCount = new int[26]; // Fill pCount, initial sCount for (int i = pLen; i < sLen; i++) { if (Arrays.equals(sCount, pCount)) result.add(i - pLen); sCount[s.charAt(i - pLen) - 'a']--; sCount[s.charAt(i) - 'a']++; } // Final check for last window` |
| 54 | Two Sum II - Input Array Is Sorted | 167 | https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ | Use two pointers, `left` starting at index 0 and `right` starting at index `n-1`. Calculate `sum = numbers[left] + numbers[right]`. If `sum == target`, return `[left + 1, right + 1]`. If `sum < target`, increment `left` to increase the sum. If `sum > target`, decrement `right` to decrease the sum. | Two pointers moving inwards on a sorted array. | Two Pointers | O(n) | O(1) | `while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } else if (sum < target) { left++; } else { right--; } }` |
| 55 | Reorder List | 143 | https://leetcode.com/problems/reorder-list/ | 1. Find the middle node using slow/fast pointers. 2. Reverse the second half of the list starting from `middle.next`. Set `middle.next = null` to split lists. 3. Merge the first half and the reversed second half: Interleave nodes one by one from each half. | Find Mid -> Reverse 2nd Half -> Merge Alternately. | Linked List / Two Pointers | O(n) | O(1) | `// 1. Find Middle ListNode slow = head, fast = head; //... // 2. Reverse Second Half ListNode secondHead = reverse(slow.next); slow.next = null; // Split // 3. Merge ListNode first = head; while (secondHead != null) { ListNode temp1 = first.next; ListNode temp2 = secondHead.next; first.next = secondHead; secondHead.next = temp1; first = temp1; secondHead = temp2; }` |
| 56 | Sort List | 148 | https://leetcode.com/problems/sort-list/ | Use Merge Sort. Base case: if list is empty or has one node, return it. Find the middle of the list using slow/fast pointers. Split the list into two halves. Recursively sort the left half (`sortList(head)`) and the right half (`sortList(middle)`). Merge the two sorted halves using a standard merge function (like merge two sorted lists). | Merge Sort adapted for Linked Lists. | Linked List / Sorting / Recursion / Merge Sort | O(n log n) | O(log n) recursion stack | `// Find middle ListNode mid = getMid(head); // Split ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); // Merge return merge(left, right);` |
| 57 | Diameter of Binary Tree | 543 | https://leetcode.com/problems/diameter-of-binary-tree/ | Use DFS. Define a helper function `height(node)` that returns the height of the subtree rooted at `node`. Inside this function, recursively calculate `leftHeight = height(node.left)` and `rightHeight = height(node.right)`. The diameter *passing through* `node` is `leftHeight + rightHeight`. Update a global/instance variable `maxDiameter = max(maxDiameter, leftHeight + rightHeight)`. The function `height(node)` returns `1 + max(leftHeight, rightHeight)`. | DFS calculating height; diameter is max(leftHeight + rightHeight) across all nodes. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int maxDiameter = 0; int height(TreeNode node) { if (node == null) return 0; int leftH = height(node.left); int rightH = height(node.right); maxDiameter = Math.max(maxDiameter, leftH + rightH); return 1 + Math.max(leftH, rightH); }` |
| 58 | Kth Smallest Element in a BST | 230 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/ | Inorder Traversal (Recursive or Iterative). Perform an inorder traversal (Left, Root, Right) which visits nodes in ascending order for a BST. Maintain a counter. When the counter reaches `k`, the current node's value is the answer. Iterative using a stack is common. | Inorder traversal visits BST nodes in sorted order. | Tree / BST / Inorder Traversal | O(H + k) avg, O(N) worst | O(H) avg, O(N) worst (stack) | `Stack<TreeNode> stack = new Stack<>(); while (true) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (--k == 0) return root.val; root = root.right; }` |
| 59 | Partition Equal Subset Sum | 416 | https://leetcode.com/problems/partition-equal-subset-sum/ | DP (Memoization). Calculate total sum. If odd, return false. Target sum is `totalSum / 2`. Define `memo[i][s]` = can subset sum `s` be formed using elements up to index `i`. Base cases: `s=0` is true. `i<0` or `s<0` is false. Recurrence: `solve(i-1, s)` (exclude `nums[i]`) OR `solve(i-1, s - nums[i])` (include `nums[i]`). | Reduce to Subset Sum problem with target = totalSum / 2. | Dynamic Programming | O(n * sum) | O(n * sum) | `Boolean[][] memo; boolean solve(int[] nums, int i, int target) { if (target == 0) return true; if (i < 0 || target < 0) return false; if (memo[i][target] != null) return memo[i][target]; boolean include = solve(nums, i - 1, target - nums[i]); boolean exclude = solve(nums, i - 1, target); memo[i][target] = include || exclude; return memo[i][target]; }` |
| 60 | Longest Palindromic Subsequence | 516 | https://leetcode.com/problems/longest-palindromic-subsequence/ | DP with Memoization. `memo[i][j]` stores the length of the LPS for the substring `s[i..j]`. Base case: `memo[i][i] = 1`. If `s.charAt(i) == s.charAt(j)`, then `memo[i][j] = 2 + solve(i+1, j-1)`. If not equal, `memo[i][j] = max(solve(i+1, j), solve(i, j-1))`. | DP state `memo[i][j]` = LPS length in `s[i..j]`. Match ends or take max of subproblems. | Dynamic Programming | O(n^2) | O(n^2) | `Integer[][] memo; int solve(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != null) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) { memo[i][j] = 2 + solve(s, i + 1, j - 1); } else { memo[i][j] = Math.max(solve(s, i + 1, j), solve(s, i, j - 1)); } return memo[i][j]; }` |
| 61 | Palindrome Partitioning | 131 | https://leetcode.com/problems/palindrome-partitioning/ | Backtracking/DFS. Define `backtrack(start, currentList)`. Iterate `end` from `start` to `n-1`. Check if `s.substring(start, end + 1)` is a palindrome. If yes, add it to `currentList`, recurse `backtrack(end + 1, currentList)`, then remove the substring (backtrack). Base case: `start == n`, add `currentList` to results. | Backtracking exploring all partitions, checking palindrome property for each part. | Backtracking / Recursion | O(N * 2^N) | O(N) recursion depth | `for (int end = start; end < s.length(); end++) { if (isPalindrome(s, start, end)) { currentList.add(s.substring(start, end + 1)); backtrack(end + 1, currentList, s, result); currentList.remove(currentList.size() - 1); // Backtrack } }` |
| 62 | Decode Ways | 91 | https://leetcode.com/problems/decode-ways/ | DP with Memoization. `memo[i]` stores ways to decode `s[i...]`. Base case: `memo[n] = 1`. If `s[i] == '0'`, `memo[i] = 0`. One-digit decode: `ways = solve(i+1)`. Two-digit decode: If `i+1 < n` and `s[i..i+1]` is '10'-'26', `ways += solve(i+2)`. Store result in `memo[i]`. | DP state `memo[i]` = ways to decode suffix `s[i...]`. Handle '0' and 1/2 digit checks. | Dynamic Programming | O(n) | O(n) | `if (memo[i] != null) return memo[i]; if (s.charAt(i) == '0') return 0; int ways = solve(i + 1, s, memo); if (i + 1 < s.length()) { int twoDigit = Integer.parseInt(s.substring(i, i + 2)); if (twoDigit >= 10 && twoDigit <= 26) { ways += solve(i + 2, s, memo); } } memo[i] = ways;` |
| 63 | Longest Increasing Path in a Matrix | 329 | https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ | DP (Memoization) + DFS. `memo[r][c]` stores LIP length starting at `(r, c)`. Initialize memo with 0. Iterate through all cells, call DFS if `memo[r][c] == 0`. DFS(r, c): If `memo[r][c] > 0` return it. Calculate `maxPath = 1`. Explore 4 neighbors `(nr, nc)`. If valid and `matrix[nr][nc] > matrix[r][c]`, `maxPath = max(maxPath, 1 + dfs(nr, nc))`. Store `memo[r][c] = maxPath`. | DFS with memoization to avoid recomputing LIP from same cell. | DFS / Dynamic Programming | O(m*n) | O(m*n) | `if (memo[r][c] > 0) return memo[r][c]; int maxLen = 1; for (int[] dir : directions) { int nr = r + dir[0], nc = c + dir[1]; if (/* valid neighbor */ && matrix[nr][nc] > matrix[r][c]) { maxLen = Math.max(maxLen, 1 + dfs(matrix, nr, nc, memo)); } } memo[r][c] = maxLen;` |
| 64 | Pacific Atlantic Water Flow | 417 | https://leetcode.com/problems/pacific-atlantic-water-flow/ | DFS/BFS from both oceans. Create two boolean matrices `pacific` and `atlantic`. Start DFS/BFS from all border cells adjacent to Pacific, mark reachable cells in `pacific`. Do the same for Atlantic border cells and `atlantic` matrix. Iterate through the grid, if `pacific[r][c]` and `atlantic[r][c]` are both true, add `(r, c)` to result. | Start search from ocean boundaries inwards. | DFS / BFS | O(m*n) | O(m*n) | `// dfs(matrix, r, c, visited, prevHeight) for (int i = 0; i < rows; i++) { dfs(matrix, i, 0, pacific, Integer.MIN_VALUE); // Pacific border dfs(matrix, i, cols - 1, atlantic, Integer.MIN_VALUE); // Atlantic border } // ... same for top/bottom borders ... List<List<Integer>> result = new ArrayList<>(); for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) if (pacific[r][c] && atlantic[r][c]) result.add(Arrays.asList(r,c));` |
| 65 | Reconstruct Itinerary | 332 | https://leetcode.com/problems/reconstruct-itinerary/ | Hierholzer's algorithm variation using DFS. Build graph where `adj<String, PriorityQueue<String>>` stores destinations lexicographically. Start DFS from "JFK". In `dfs(airport)`: While neighbors exist, `dfs(neighbor)`. Add `airport` to the front of the result list *after* visiting all neighbors (post-order traversal). | Post-order DFS traversal on graph with sorted adjacency lists (MinHeap). | DFS / Graph / Eulerian Path | O(E log E) or O(E) if radix sort | O(V+E) | `Map<String, PriorityQueue<String>> adj; LinkedList<String> result; void dfs(String airport) { PriorityQueue<String> neighbors = adj.get(airport); while (neighbors != null && !neighbors.isEmpty()) { dfs(neighbors.poll()); } result.addFirst(airport); // Add post-visit }` |
| 66 | Design Twitter | 355 | https://leetcode.com/problems/design-twitter/ | Use HashMaps: `userMap<userId, UserObject>`. `UserObject` contains `Set<Integer> following` and `List<Tweet> tweets`. `Tweet` class has `id`, `timestamp`. `postTweet`: Add tweet to user's tweet list (keep it sorted/limited). `getNewsFeed`: Get user's tweets + tweets from all followees. Use a Max-Heap (PriorityQueue) ordered by timestamp to merge these tweet lists and get the top 10 recent. | HashMaps for users/following, Lists/Heaps for tweets. | Design / Hash Map / Heap | O(F*T*logK) feed, O(1) follow/post (F=following, T=tweets/user, K=10) | O(Users + Tweets + Follows) | `class User { Set<Integer> following = new HashSet<>(); LinkedList<Tweet> tweets = new LinkedList<>(); } Map<Integer, User> userMap; // getNewsFeed PriorityQueue<Tweet> maxHeap = new PriorityQueue<>((a,b)->b.timestamp-a.timestamp); // Add self tweets + followee tweets to heap... poll top 10` |
| 67 | Word Search II | 212 | https://leetcode.com/problems/word-search-ii/ | Build a Trie from the `words`. Perform DFS on the `board` starting from each cell. In the DFS function `dfs(r, c, currentNode)`, check bounds, visited status. Get char `board[r][c]`. If `currentNode` doesn't have child for char, return. Move to child node. If `childNode.word != null`, add it to result and set `childNode.word = null` (avoid duplicates). Mark cell visited, explore 4 neighbors, unmark cell. | Trie stores dictionary words for efficient prefix checking during board DFS. | Trie / DFS / Backtracking | O(M*N*4*3^(L-1)) M,N=dims, L=max word len. Dominated by Trie build + DFS. | O(Total Chars in words) for Trie | `void dfs(char[][] board, int r, int c, TrieNode node, List<String> result) { //... base cases ... char ch = board[r][c]; TrieNode child = node.children[ch - 'a']; if (child == null) return; if (child.word != null) { result.add(child.word); child.word = null; // Avoid duplicates } board[r][c] = '#'; // Mark visited // dfs neighbors... board[r][c] = ch; // Unmark }` |
| 68 | Design Add and Search Words Data Structure | 211 | https://leetcode.com/problems/design-add-and-search-words-data-structure/ | Use a Trie structure (`TrieNode` with children and `isEndOfWord`). `addWord` is standard Trie insertion. `search(word)` needs modification: If char is '.', recursively call `search` on all non-null children of the current node and return true if any succeed. If char is a letter, follow the specific child branch. If path doesn't exist, return false. | Trie with modified search to handle '.' wildcard by exploring all children. | Trie / Design / DFS | O(L) add, O(N*26^L) search worst-case (.), N=nodes, L=len | O(Total Chars) for Trie | `boolean searchHelper(String word, int k, TrieNode node) { if (k == word.length()) return node.isEndOfWord; char ch = word.charAt(k); if (ch == '.') { for (TrieNode child : node.children) { if (child != null && searchHelper(word, k + 1, child)) return true; } return false; } else { // Standard Trie traversal } }` |
| 69 | Longest Valid Parentheses | 32 | https://leetcode.com/problems/longest-valid-parentheses/ | Stack approach: Push indices of '(' onto stack. When ')' is encountered: if stack not empty, pop index `start`. Length is `current_index - start + 1`. Update `maxLength`. Alternative DP: `dp[i]` = length of LVP *ending* at `i`. If `s[i] == ')'`: if `s[i-1] == '('`, `dp[i] = dp[i-2] + 2`. If `s[i-1] == ')'` and matching '(' exists at `i - dp[i-1] - 1`, `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`. | Stack stores indices to calculate length upon finding matching ')', or DP relation. | Stack / Dynamic Programming | O(n) | O(n) stack/DP array | `// Stack approach Stack<Integer> stack = new Stack<>(); stack.push(-1); // Base for length calculation for (int i=0; i<s.length(); ++i) { if (s.charAt(i) == '(') stack.push(i); else { stack.pop(); if (stack.isEmpty()) stack.push(i); // New base else maxLen = Math.max(maxLen, i - stack.peek()); } }` |
| 70 | Remove Invalid Parentheses | 301 | https://leetcode.com/problems/remove-invalid-parentheses/ | BFS Approach: Start BFS with the initial string. Use a queue and a set `visited` to avoid cycles. At each level, process strings from the queue. If a string is valid, add it to the result list. If result is found, stop exploring deeper levels (since we want minimum removals). Generate next level strings by removing one '(' or ')' from each current string and adding to queue if not visited. | Level-order BFS guarantees finding shortest paths (minimum removals) first. | BFS / String Manipulation | O(N * 2^N) worst case | O(N * 2^N) visited set | `Queue<String> queue; Set<String> visited; List<String> result; boolean found = false; while (!queue.isEmpty()) { String curr = queue.poll(); if (isValid(curr)) { result.add(curr); found = true; } if (found) continue; // Found min removals level for (int i = 0; i < curr.length(); i++) { // Generate next strings by removing one char... if (!visited.contains(nextStr)) { queue.offer(nextStr); visited.add(nextStr); } } }` |
| 71 | Combination Sum II | 40 | https://leetcode.com/problems/combination-sum-ii/ | Backtracking with sorting to handle duplicates. Sort `candidates`. Define `backtrack(startIndex, currentSum, currentList)`. Base cases: `currentSum == target` (add copy of `currentList`), `currentSum > target` (return). Loop `i` from `startIndex` to `n-1`. **Crucial**: If `i > startIndex && candidates[i] == candidates[i-1]`, continue (skip duplicate combination). Add `candidates[i]` to list, recurse `backtrack(i + 1, ...)`, backtrack (remove). | Sort + skip duplicates in backtracking loop (`i > startIndex`). Use `i+1` in recursion. | Backtracking / Recursion | O(2^N) | O(N) recursion depth | `Arrays.sort(candidates); // ... backtrack function ... for (int i = start; i < candidates.length; i++) { if (i > start && candidates[i] == candidates[i - 1]) continue; // Skip duplicates if (candidates[i] > remaining) break; // Pruning tempList.add(candidates[i]); backtrack(result, tempList, candidates, remaining - candidates[i], i + 1); // Use i+1 tempList.remove(tempList.size() - 1); }` |
| 72 | Move Zeroes | 283 | https://leetcode.com/problems/move-zeroes/ | Two Pointers (Slow/Fast or Read/Write). Initialize `writePointer = 0`. Iterate through array with `readPointer` from 0 to `n-1`. If `nums[readPointer]` is not zero, set `nums[writePointer] = nums[readPointer]` and increment `writePointer`. After loop, fill remaining positions from `writePointer` to `n-1` with zeros. | In-place modification using a write pointer for non-zero elements. | Array / Two Pointers | O(n) | O(1) | `int insertPos = 0; for (int num : nums) { if (num != 0) { nums[insertPos++] = num; } } while (insertPos < nums.length) { nums[insertPos++] = 0; }` |
| 73 | Minimum Size Subarray Sum | 209 | https://leetcode.com/problems/minimum-size-subarray-sum/ | Sliding Window. Initialize `start = 0`, `currentSum = 0`, `minLength = Integer.MAX_VALUE`. Iterate `end` from 0 to `n-1`. Add `nums[end]` to `currentSum`. While `currentSum >= target`: update `minLength = Math.min(minLength, end - start + 1)`, subtract `nums[start]` from `currentSum`, and increment `start`. Return `minLength` or 0 if not found. | Sliding window expands right, shrinks left when sum condition met. | Sliding Window / Two Pointers | O(n) | O(1) | `while (end < nums.length) { currentSum += nums[end]; while (currentSum >= target) { minLength = Math.min(minLength, end - start + 1); currentSum -= nums[start]; start++; } end++; }` |
| 74 | 3Sum Closest | 16 | https://leetcode.com/problems/3sum-closest/ | Sort array. Initialize `closestSum`. Iterate `i` from 0 to `n-3`. Use two pointers `left = i + 1`, `right = n - 1`. Calculate `currentSum = nums[i] + nums[left] + nums[right]`. If `abs(currentSum - target) < abs(closestSum - target)`, update `closestSum = currentSum`. If `currentSum == target`, return target. If `currentSum < target`, `left++`. Else `right--`. Skip duplicates for `i` not strictly needed but good practice. | Sort + Two Pointers, track sum closest to target. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) sort | `Arrays.sort(nums); int closestSum = nums[0] + nums[1] + nums[2]; // Initial guess for (int i = 0; i < nums.length - 2; i++) { int left = i + 1, right = nums.length - 1; while (left < right) { int currentSum = nums[i] + nums[left] + nums[right]; if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) { closestSum = currentSum; } if (currentSum < target) left++; else if (currentSum > target) right--; else return target; // Exact match } }` |
| 75 | 4Sum | 18 | https://leetcode.com/problems/4sum/ | Sort array. Use nested loops: outer loop `i`, inner loop `j`. Skip duplicates for `i` and `j`. Inside `j` loop, use two pointers `left = j + 1`, `right = n - 1` to find pairs summing to `target - nums[i] - nums[j]`. Calculate `currentSum`. If equal to target, add quadruplet, increment `left`, decrement `right`, skip duplicates for `left` and `right`. If `sum < target`, `left++`. If `sum > target`, `right--`. | Sort + Nested Loops + Two Pointers. Handle duplicates at all levels. | Two Pointers / Sorting | O(n^3) | O(log n) or O(n) sort | `// Outer loops for i, j (with duplicate checks) // Inner two pointers int twoSumTarget = target - nums[i] - nums[j]; int left = j + 1, right = n - 1; while (left < right) { int sum = nums[left] + nums[right]; if (sum == twoSumTarget) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // Skip duplicates for left & right left++; right--; } else if (sum < twoSumTarget) left++; else right--; }` |
| 76 | Palindrome Linked List | 234 | https://leetcode.com/problems/palindrome-linked-list/ | Find middle node using slow/fast pointers. Reverse the second half of the list starting from `middle.next`. Compare the first half (from `head`) with the reversed second half node by node. Restore list afterwards if needed (reverse second half again). | Find Mid -> Reverse 2nd Half -> Compare 1st and Reversed 2nd. | Linked List / Two Pointers | O(n) | O(1) | `ListNode mid = findMiddle(head); ListNode secondHead = reverse(mid.next); // mid.next = null if needed boolean isPalindrome = true; while (secondHead != null) { if (head.val != secondHead.val) { isPalindrome = false; break; } head = head.next; secondHead = secondHead.next; }` |
| 77 | Intersection of Two Linked Lists | 160 | https://leetcode.com/problems/intersection-of-two-linked-lists/ | Two Pointers approach: Initialize `pA = headA`, `pB = headB`. Traverse both. If `pA` reaches end, redirect it to `headB`. If `pB` reaches end, redirect it to `headA`. They will meet at the intersection node (or null if no intersection) after at most two passes through combined lists. | Pointers traverse both lists; switching heads aligns them for meeting at intersection. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode pA = headA, pB = headB; while (pA != pB) { pA = (pA == null) ? headB : pA.next; pB = (pB == null) ? headA : pB.next; } return pA; // Returns intersection node or null` |
| 78 | Invert Binary Tree | 226 | https://leetcode.com/problems/invert-binary-tree/ | Recursive DFS: Base case: if `node == null`, return null. Swap `node.left` and `node.right`. Recursively call `invertTree(node.left)` and `invertTree(node.right)`. Return `node`. Iterative BFS also works. | Recursively swap left and right children. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `if (root == null) return null; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root;` |
| 79 | Binary Tree Right Side View | 199 | https://leetcode.com/problems/binary-tree-right-side-view/ | BFS (Level Order Traversal). Use a queue. In each level, iterate through all nodes currently in the queue (`levelSize`). Keep track of the value of the *last* node processed at each level. Add this last node's value to the result list. | Level order traversal, adding the last node encountered at each level. | Tree / BFS | O(n) | O(w) max width | `Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (i == levelSize - 1) { result.add(node.val); // Add last element } if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } }` |
| 80 | Subtree of Another Tree | 572 | https://leetcode.com/problems/subtree-of-another-tree/ | Recursive approach. Define `isSubtree(root, subRoot)`. Base case: `subRoot` is null -> true. `root` is null -> false. Check if `root` and `subRoot` form the same tree using `isSameTree(root, subRoot)`. If yes, return true. Otherwise, return `isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)`. `isSameTree` checks equality recursively. | Check if same tree at current node OR if subtree exists in left OR right child. | Tree / Recursion / DFS | O(m*n) worst case, O(m+n) avg | O(h) recursion depth | `boolean isSameTree(TreeNode p, TreeNode q) { // Standard same tree check } boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); }` |
| 81 | Balanced Binary Tree | 110 | https://leetcode.com/problems/balanced-binary-tree/ | Recursive DFS. Helper function `checkHeight(node)` returns height if balanced, -1 otherwise. Base case: null node returns 0. Get left/right heights recursively. If either is -1 or `abs(leftH - rightH) > 1`, return -1. Else, return `1 + max(leftH, rightH)`. Main function checks if `checkHeight(root) != -1`. | Combine height calculation and balance check in one recursive pass. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int checkHeight(TreeNode node) { if (node == null) return 0; int leftH = checkHeight(node.left); if (leftH == -1) return -1; int rightH = checkHeight(node.right); if (rightH == -1) return -1; if (Math.abs(leftH - rightH) > 1) return -1; return 1 + Math.max(leftH, rightH); }` |
| 82 | Symmetric Tree | 101 | https://leetcode.com/problems/symmetric-tree/ | Recursive helper `isMirror(node1, node2)`. Checks if two trees are mirror images. Base cases: Both null -> true; one null -> false. Return `(node1.val == node2.val) && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left)`. Initial call: `isMirror(root.left, root.right)`. | Recursive comparison of left subtree with mirror image of right subtree. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `boolean isMirror(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }` |
| 83 | Populating Next Right Pointers in Each Node | 116 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ | Level Order Traversal (BFS) or Optimized Iterative/Recursive using existing `next`. BFS: Standard level order, connect `prev.next = current` within each level. Optimized Iterative (O(1) space): Use two pointers `levelStart` and `curr`. Iterate `levelStart` down levels. Inner loop uses `curr` to traverse current level using `next` pointers, setting `curr.left.next = curr.right` and `curr.right.next = curr.next != null ? curr.next.left : null`. | Use BFS or leverage perfect tree structure for O(1) space iteration using `next` pointers. | Tree / BFS / DFS | O(n) | O(w) BFS / O(1) optimized | `// Optimized Iterative (O(1) space) Node levelStart = root; while (levelStart != null && levelStart.left != null) { Node curr = levelStart; while (curr != null) { curr.left.next = curr.right; if (curr.next != null) curr.right.next = curr.next.left; curr = curr.next; } levelStart = levelStart.left; }` |
| 84 | Minimum Path Sum | 64 | https://leetcode.com/problems/minimum-path-sum/ | DP (Tabulation in-place). `grid[r][c]` stores min path sum to reach `(r, c)`. Initialize first row and first column based on previous cell. For other cells `(r, c)`, `grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])`. Result is `grid[m-1][n-1]`. | DP state `dp[r][c]` = min sum to reach cell `(r,c)`. In-place update. | Dynamic Programming | O(m*n) | O(1) (in-place) / O(m*n) memo | `for (int r = 0; r < m; r++) { for (int c = 0; c < n; c++) { if (r == 0 && c == 0) continue; else if (r == 0) grid[r][c] += grid[r][c-1]; else if (c == 0) grid[r][c] += grid[r-1][c]; else grid[r][c] += Math.min(grid[r-1][c], grid[r][c-1]); } }` |
| 85 | Coin Change II | 518 | https://leetcode.com/problems/coin-change-ii/ | DP (Unbounded Knapsack). `dp[i]` = number of ways to make amount `i`. Initialize `dp[0] = 1`. Iterate through each `coin` in `coins`. For each `coin`, iterate through amounts `j` from `coin` up to `amount`. Update `dp[j] = dp[j] + dp[j - coin]`. Result is `dp[amount]`. | DP state `dp[i]` = number of combinations for amount `i`. Outer loop coins, inner loop amounts. | Dynamic Programming | O(amount * coins) | O(amount) | `int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } }` |
| 86 | House Robber II | 213 | https://leetcode.com/problems/house-robber-ii/ | Reduce to two House Robber I problems. Because first and last houses cannot be robbed together, calculate max profit for `nums[0...n-2]` (excluding last) and max profit for `nums[1...n-1]` (excluding first). Return the maximum of these two results. Use standard House Robber I DP logic for subproblems. | Solve two subproblems excluding first/last house respectively. | Dynamic Programming | O(n) | O(1) (using optimized HR I) | `if (nums.length == 1) return nums[0]; int max1 = robHelper(nums, 0, nums.length - 2); int max2 = robHelper(nums, 1, nums.length - 1); return Math.max(max1, max2); // robHelper implements House Robber I DP` |
| 87 | Unique Paths II | 63 | https://leetcode.com/problems/unique-paths-ii/ | DP (Tabulation in-place or separate DP array). `dp[r][c]` = number of paths to `(r, c)`. If `obstacleGrid[r][c] == 1`, `dp[r][c] = 0`. Else, `dp[r][c] = dp[r-1][c] + dp[r][c-1]`. Handle first row/col initialization carefully considering obstacles. Start `dp[0][0] = 1` if no obstacle. | DP state `dp[r][c]` = unique paths to `(r,c)`. Set paths to 0 if obstacle. | Dynamic Programming | O(m*n) | O(m*n) or O(n) space | `dp[r][c] = 0; // If obstacleGrid[r][c] == 1 else if (r==0 && c==0) dp[r][c] = 1; else if (r==0) dp[r][c] = dp[r][c-1]; else if (c==0) dp[r][c] = dp[r-1][c]; else dp[r][c] = dp[r-1][c] + dp[r][c-1];` |
| 88 | Search a 2D Matrix | 74 | https://leetcode.com/problems/search-a-2d-matrix/ | Treat matrix as a sorted 1D array of size `m*n`. Perform standard binary search. Map 1D index `mid` back to 2D coordinates: `row = mid / cols`, `col = mid % cols`. Compare `matrix[row][col]` with target. | Binary search on flattened matrix indices. | Binary Search | O(log(m*n)) | O(1) | `int low = 0, high = rows * cols - 1; while (low <= high) { int mid = low + (high - low) / 2; int row = mid / cols; int col = mid % cols; if (matrix[row][col] == target) return true; else if (matrix[row][col] < target) low = mid + 1; else high = mid - 1; }` |
| 89 | Kth Smallest Element in a Sorted Matrix | 378 | https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ | Binary Search on value range `[matrix[0][0], matrix[m-1][n-1]]`. For a `mid` value, count elements `<= mid` using a staircase search (start top-right or bottom-left, O(m+n)). If `count < k`, search upper half (`low = mid + 1`). If `count >= k`, search lower half (`high = mid`), storing potential answer. | Binary search on answer range, count elements efficiently. | Binary Search / Matrix | O((m+n) * log(max-min)) | O(1) | `int countLE(int[][] matrix, int x) { // Staircase search O(m+n) } int low = matrix[0][0], high = matrix[rows-1][cols-1]; int ans = low; while (low <= high) { int mid = low + (high - low) / 2; if (countLE(matrix, mid) >= k) { ans = mid; high = mid - 1; } else { low = mid + 1; } }` |
| 90 | Rotting Oranges | 994 | https://leetcode.com/problems/rotting-oranges/ | Multi-source BFS. Initialize queue with all initial rotten oranges (2s). Keep track of `freshOranges` count. Perform BFS level by level. Each level signifies one minute. Dequeue rotten orange, explore 4 neighbors. If fresh neighbor (1) found, make it rotten (2), decrement `freshOranges`, enqueue neighbor. After BFS, return minutes elapsed if `freshOranges == 0`, else -1. | Multi-source BFS tracking levels (minutes) and remaining fresh count. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `// Initial pass: count fresh, add rotten to queue Queue<int[]> queue; int minutes = 0; while (!queue.isEmpty() && freshCount > 0) { int size = queue.size(); minutes++; for (int i=0; i<size; ++i) { // Dequeue, explore neighbors, rot fresh ones, decrement freshCount, enqueue new rotten } } return freshCount == 0 ? minutes : -1;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 91 | Surrounded Regions | 130 | https://leetcode.com/problems/surrounded-regions/ | DFS/BFS from borders. Iterate through border cells `(r, c)`. If `board[r][c] == 'O'`, start DFS/BFS and mark connected 'O's as 'E' (escaped). Then, iterate board again: 'O'  'X' (surrounded), 'E'  'O' (not surrounded). | Start from borders to find non-surrounded 'O's first, then flip remaining 'O's. | DFS / BFS / Graph | O(m*n) | O(m*n) recursion/queue | `void capture(char[][] board, int r, int c) { // DFS/BFS marking 'O' to 'E' } for (int r=0; r<rows; ++r) { if (board[r][0]=='O') capture(board,r,0); if (board[r][cols-1]=='O') capture(board,r,cols-1); } // ... top/bottom ... for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) { if (board[r][c]=='O') board[r][c]='X'; else if (board[r][c]=='E') board[r][c]='O'; }` |
| 92 | Shortest Path in Binary Matrix | 1091 | https://leetcode.com/problems/shortest-path-in-binary-matrix/ | BFS on grid. Queue stores `int[]{row, col}`. Use grid for visited/distance (set `grid[r][c] = distance`). Start from `(0,0)` with distance 1. Explore 8 neighbors. Return distance when `(n-1,n-1)` reached, or -1 if queue empty. Check `grid[0][0]` and `grid[n-1][n-1]` are 0. | BFS for shortest path in unweighted grid with 8-directional moves. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `Queue<int[]> queue = new LinkedList<>(); if (grid[0][0] == 1) return -1; queue.offer(new int[]{0, 0}); grid[0][0] = 1; int distance = 1; while (!queue.isEmpty()) { // Process level if (r == rows - 1 && c == cols - 1) return distance; // Explore 8 neighbors, set grid[nr][nc]=distance+1 }` |
| 93 | Cheapest Flights Within K Stops | 787 | https://leetcode.com/problems/cheapest-flights-within-k-stops/ | Modified Dijkstra. PriorityQueue stores `(cost, city, stops)`. Use `minCost[city][stops]` for pruning. Relax neighbors if `stops < k`. Alternatively, Bellman-Ford: relax edges `k+1` times with `newCosts` array. | Track stops in state to limit path length. | Graph / Dijkstra / Bellman-Ford | O(E + V log V) Dijkstra / O(k*E) Bellman-Ford | O(V*k) Dijkstra / O(V) Bellman-Ford | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); pq.offer(new int[]{0, src, 0}); int[][] minCost = new int[n][k + 2]; // Fill INF while (!pq.isEmpty()) { // Poll, relax neighbors if stops < k+1 }` |
| 94 | Network Delay Time | 743 | https://leetcode.com/problems/network-delay-time/ | Dijkstra's. Build adjacency list `Map<Integer, List<int[]>>`. Initialize `minTime[node]` with infinity, `minTime[k] = 0`. PriorityQueue stores `(time, node)`. Relax neighbors if shorter path found. Return max `minTime` or -1 if unreachable nodes exist. | Standard Dijkstra for shortest paths from source. | Graph / Dijkstra | O(E log V) | O(V+E) | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); int[] minTime = new int[n + 1]; Arrays.fill(minTime, Integer.MAX_VALUE); minTime[k] = 0; pq.offer(new int[]{0, k}); while (!pq.isEmpty()) { // Poll, relax neighbors }` |
| 95 | Design Tic-Tac-Toe | 348 | https://leetcode.com/problems/design-tic-tac-toe/ | O(1) move check. Use `rows[n]`, `cols[n]`, `diagonal1`, `diagonal2`. Player 1: +1, Player 2: -1. After move, check if `abs(rows[r]) == n`, `abs(cols[c]) == n`, or diagonals equal `n`. Return winner. | Sum row/col/diagonal to detect win in O(1). | Design / Array | O(1) per move | O(n) | `int[] rows; int[] cols; int diag1, diag2; int size; int move(int row, int col, int player) { int val = (player == 1) ? 1 : -1; rows[row] += val; cols[col] += val; if (row == col) diag1 += val; if (row + col == size - 1) diag2 += val; if (Math.abs(rows[row])==size || ...) return player; return 0; }` |
| 96 | Evaluate Reverse Polish Notation | 150 | https://leetcode.com/problems/evaluate-reverse-polish-notation/ | Stack-based. For each token: if number, push to stack; if operator, pop two numbers (op2, op1), compute `op1 op op2`, push result. Return final stack value. | Stack evaluates RPN by processing operators immediately. | Stack | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); for (String token : tokens) { if (isOperator(token)) { int op2 = stack.pop(); int op1 = stack.pop(); stack.push(evaluate(op1, op2, token)); } else { stack.push(Integer.parseInt(token)); } } return stack.pop();` |
| 97 | Basic Calculator | 224 | https://leetcode.com/problems/basic-calculator/ | Stack for parentheses. Track `result`, `number`, `sign`. For '(', push `result` and `sign`, reset `result`. For ')', compute expression, multiply by popped sign, add popped result. Add `number * sign` to result for digits. | Stack manages nested expressions and signs. | Stack / String | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int result = 0; int number = 0; int sign = 1; for (char c : s.toCharArray()) { if (c == '(') { stack.push(result); stack.push(sign); result = 0; sign = 1; } else if (c == ')') { result += sign * number; number = 0; result *= stack.pop(); result += stack.pop(); } }` |
| 98 | Basic Calculator II | 227 | https://leetcode.com/problems/basic-calculator-ii/ | No-Stack approach. Track `result`, `lastNum`, `currentNum`, `operation`. For '+' or '-': `result += lastNum`, update `lastNum`. For '*' or '/': update `lastNum = lastNum op currentNum`. Handle final number. | Process */ immediately, delay +/- by tracking last number. | Stack / String | O(n) | O(1) | `int result = 0, lastNum = 0, currentNum = 0; char operation = '+'; for (int i=0; i<s.length(); ++i) { if (!Character.isDigit(c) && c != ' ' || i == s.length() - 1) { if (operation == '+') { result += lastNum; lastNum = currentNum; } else if (operation == '-') { result += lastNum; lastNum = -currentNum; } else if (operation == '*') lastNum *= currentNum; else lastNum /= currentNum; operation = c; currentNum = 0; } } result += lastNum;` |
| 99 | Letter Combinations of a Phone Number | 17 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/ | Backtracking. Map digits to letters. Recurse with `backtrack(index, current)`. Base case: `index == digits.length()`, add `current`. For each letter of current digit, append and recurse. | Explore all letter combinations recursively. | Backtracking / Recursion / String | O(4^N * N) | O(N) recursion depth | `Map<Character, String> map; List<String> result; void backtrack(int index, StringBuilder current, String digits) { if (index == digits.length()) { result.add(current.toString()); return; } String letters = map.get(digits.charAt(index)); for (char c : letters.toCharArray()) { current.append(c); backtrack(index + 1, current, digits); current.deleteCharAt(current.length() - 1); } }` |
| 100 | K Closest Points to Origin | 973 | https://leetcode.com/problems/k-closest-points-to-origin/ | Max-Heap of size `k`. Store points in heap ordered by descending distance squared. For each point: add to heap; if size > k, poll max. Return heap contents. | Max-Heap maintains k smallest distances. | Heap (Priority Queue) / Sorting | O(N log k) | O(k) | `PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])); for (int[] point : points) { maxHeap.offer(point); if (maxHeap.size() > k) maxHeap.poll(); } int[][] result = new int[k][2]; while (k-- > 0) result[k] = maxHeap.poll();` |
| 101 | Squares of a Sorted Array | 977 | https://leetcode.com/problems/squares-of-a-sorted-array/ | Two pointers (`left=0`, `right=n-1`). Compare squares of `nums[left]` and `nums[right]`. Place larger square at end of result array (`k=n-1`). Move pointer with larger square inward. | Largest squares come from ends of sorted array. | Two Pointers | O(n) | O(n) | `int[] result = new int[n]; int left = 0, right = n - 1; for (int k = n - 1; k >= 0; k--) { if (Math.abs(nums[left]) > Math.abs(nums[right])) { result[k] = nums[left] * nums[left++]; } else { result[k] = nums[right] * nums[right--]; } }` |
| 102 | Max Consecutive Ones III | 1004 | https://leetcode.com/problems/max-consecutive-ones-iii/ | Sliding window. Track `zeroCount` in window. Expand `right` pointer, increment `zeroCount` for zeros. If `zeroCount > k`, shrink window (`left++`), decrement `zeroCount`. Update `maxLen`. | Track zeros in window to ensure at most k flips. | Sliding Window | O(n) | O(1) | `int left = 0, zeroCount = 0, maxLen = 0; for (int right = 0; right < nums.length; right++) { if (nums[right] == 0) zeroCount++; while (zeroCount > k) { if (nums[left] == 0) zeroCount--; left++; } maxLen = Math.max(maxLen, right - left + 1); }` |
| 103 | Contains Duplicate II | 219 | https://leetcode.com/problems/contains-duplicate-ii/ | HashMap stores last index of each number. For each `nums[i]`, check if in map and `i - map.get(nums[i]) <= k`. Update map with current index. | Map tracks indices to check distance constraint. | Hash Map / Sliding Window (implicit) | O(n) | O(min(n, k)) | `Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; i++) { if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k) return true; map.put(nums[i], i); } return false;` |
| 104 | Permutation in String | 567 | https://leetcode.com/problems/permutation-in-string/ | Sliding window with frequency arrays. Use `s1Count[26]` for `s1` and `s2Count[26]` for window in `s2`. Initialize window of `s1.length()`. Slide window, updating counts. Check if arrays equal. | Compare frequency arrays to detect permutation. | Sliding Window / Frequency Map | O(L1 + L2) | O(1) (alphabet size) | `int[] s1Count = new int[26]; int[] s2Count = new int[26]; for (char c : s1.toCharArray()) s1Count[c - 'a']++; for (int i = 0; i < s2.length(); i++) { s2Count[s2.charAt(i) - 'a']++; if (i >= s1.length()) s2Count[s2.charAt(i - s1.length()) - 'a']--; if (Arrays.equals(s1Count, s2Count)) return true; }` |
| 105 | Trapping Rain Water II | 407 | https://leetcode.com/problems/trapping-rain-water-ii/ | Min-Heap PriorityQueue with cells `(r, c, height)`. Add boundary cells to heap, mark visited. Poll min height cell, process neighbors. For each neighbor, water trapped = `max(0, currentHeight - neighborHeight)`. Update neighbor height and add to heap. | Min-Heap ensures processing cells by increasing height, simulating water flow. | Priority Queue / BFS variant | O(m*n log(m*n)) | O(m*n) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); boolean[][] visited = new boolean[m][n]; // Add boundary cells to pq while (!pq.isEmpty()) { int[] cell = pq.poll(); // Process neighbors, calculate water, update height }` |
| 106 | Swap Nodes in Pairs | 24 | https://leetcode.com/problems/swap-nodes-in-pairs/ | Iterative with dummy node. For each pair, swap `prev.next` and `prev.next.next`. Update pointers: `prev`, `first`, `second`. Connect to next pair. | Dummy node simplifies head case; swap pairs in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0, head); ListNode prev = dummy; while (prev.next != null && prev.next.next != null) { ListNode first = prev.next; ListNode second = first.next; prev.next = second; first.next = second.next; second.next = first; prev = first; }` |
| 107 | Reverse Linked List II | 92 | https://leetcode.com/problems/reverse-linked-list-ii/ | Locate `prev` (before segment), `start` (segment start), `end` (segment end), `next_group` (after segment). Reverse segment, connect `prev` to new head, old `start` to `next_group`. | Identify four key nodes and reverse segment in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for (int i = 1; i < left; i++) prev = prev.next; ListNode start = prev.next; ListNode end = start; for (int i = left; i < right; i++) end = end.next; ListNode next_group = end.next; // Reverse segment and connect` |
| 108 | Populating Next Right Pointers in Each Node II | 117 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ | Iterative O(1) space. Use `next` pointers of previous level to traverse current level. Maintain `levelHead` (dummy for next level) and `prev` to link nodes within level. | Use existing `next` pointers to avoid extra space. | Tree Traversal / Linked List | O(n) | O(1) | `Node dummy = new Node(0); Node levelHead = dummy; Node curr = root; while (curr != null) { while (curr != null) { if (curr.left != null) { levelHead.next = curr.left; levelHead = levelHead.next; } if (curr.right != null) { levelHead.next = curr.right; levelHead = levelHead.next; } curr = curr.next; } curr = dummy.next; dummy.next = null; levelHead = dummy; }` |
| 109 | Construct Tree from Given Inorder and Preorder Traversal | N/A | https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ | Recursive. Preorders first element is root. Find root in inorder to split left/right subtrees. Use HashMap for O(1) inorder lookup. Recurse on subtrees. | Preorder gives root; inorder splits subtrees. | Recursion / Tree Construction | O(n) | O(n) (map + recursion) | `Map<Integer, Integer> inorderMap = new HashMap<>(); for (int i = 0; i < inorder.length; i++) inorderMap.put(inorder[i], i); return buildTreeHelper(preorder, 0, preorder.length - 1, 0, inorder.length - 1, inorderMap);` |
| 110 | Reverse a Linked List in Groups of Given Size | N/A | https://www.geeksforgeeks.org/reverse-a-linked-list-in-groups-of-given-size/ | Iterative. Use dummy node. For each group of k nodes, check if exists, reverse, and connect `prevGroupEnd` to new head, old head to next group. | Reverse k nodes and reconnect segments. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prevGroupEnd = dummy; while (head != null) { ListNode groupStart = head; int count = 0; while (head != null && count < k) { head = head.next; count++; } if (count == k) { ListNode reversedHead = reverse(groupStart, k); prevGroupEnd.next = reversedHead; prevGroupEnd = groupStart; } }` |
| 111 | Knapsack Problem 0/1 | N/A | https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/ | DP Memoization. `dp(index, capacity)` = max value from `index` onwards with given capacity. Recurrence: max(include `values[index]` if possible, exclude). | State: (index, remaining capacity). | Dynamic Programming | O(n * capacity) | O(n * capacity) | `Map<String, Integer> memo = new HashMap<>(); int solve(int i, int capacity, int[] weights, int[] values) { if (i == weights.length || capacity == 0) return 0; String key = i + "-" + capacity; if (memo.containsKey(key)) return memo.get(key); int include = (weights[i] <= capacity) ? values[i] + solve(i + 1, capacity - weights[i], weights, values) : -1; int exclude = solve(i + 1, capacity, weights, values); memo.put(key, Math.max(include, exclude)); return memo.get(key); }` |
| 112 | Egg Dropping Puzzle | N/A | https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/ | DP Memoization. `dp(eggs, floors)` = min trials needed. For each floor k, max of `dp(eggs-1, k-1)` (breaks) and `dp(eggs, floors-k)` (survives). Minimize over k. | State: (eggs, floors); minimize max outcomes. | Dynamic Programming | O(eggs * floors^2) | O(eggs * floors) | `Map<String, Integer> memo = new HashMap<>(); int solve(int eggs, int floors) { if (floors <= 1) return floors; if (eggs == 1) return floors; String key = eggs + "-" + floors; if (memo.containsKey(key)) return memo.get(key); int minTrials = Integer.MAX_VALUE; for (int k = 1; k <= floors; k++) { int res = Math.max(solve(eggs - 1, k - 1), solve(eggs, floors - k)); minTrials = Math.min(minTrials, res); } memo.put(key, minTrials + 1); return minTrials + 1; }` |
| 113 | Search Insert Position | 35 | https://leetcode.com/problems/search-insert-position/ | Binary search. If target found, return index. Else, return `low` where search converges (insertion point). | Binary search finds exact or insertion position. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return low;` |
| 114 | Binary Search | 704 | https://leetcode.com/problems/binary-search/ | Standard binary search. Compare target with mid element, adjust `low` or `high`. Return index if found, -1 otherwise. | Classic divide-and-conquer on sorted array. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return -1;` |
| 115 | Search in Rotated Sorted Array II | 81 | https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ | Binary search handling duplicates. If `nums[mid] == nums[low] == nums[high]`, skip duplicates (`low++`, `high--`). Else, check which half is sorted and if target lies in it. | Handle duplicates by shrinking ambiguous cases. | Binary Search | O(log n) avg, O(n) worst | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return true; if (nums[mid] == nums[low] && nums[mid] == nums[high]) { low++; high--; continue; } // Check sorted half and target range }` |
| 116 | Middle of the Linked List | 876 | https://leetcode.com/problems/middle-of-the-linked-list/ | Slow and fast pointers. Slow moves one step, fast moves two. When fast reaches end, slow is at middle. | Fast pointer doubles speed to find middle. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;` |
| 117 | A Product Array Puzzle | N/A | https://www.geeksforgeeks.org/a-product-array-puzzle/ | Compute `left[i]` (product of `arr[0...i-1]`) and `right[i]` (product of `arr[i+1...n-1]`). Result `prod[i] = left[i] * right[i]`. Avoid division. | Precompute left and right products for each index. | Array Manipulation | O(n) | O(n) | `int[] left = new int[n]; int[] right = new int[n]; left[0] = 1; for (int i = 1; i < n; i++) left[i] = left[i-1] * arr[i-1]; right[n-1] = 1; for (int i = n-2; i >= 0; i--) right[i] = right[i+1] * arr[i+1]; int[] prod = new int[n]; for (int i = 0; i < n; i++) prod[i] = left[i] * right[i];` |
| 118 | Find the Smallest Window in a String Containing All Characters of Another String | N/A | https://www.geeksforgeeks.org/find-the-smallest-window-in-a-string-containing-all-characters-of-another-string/ | Sliding window. Use `patternMap` and `windowMap`. Expand window until valid (`formed == required`). Shrink from left, update min window if smaller. | Track matching characters with frequency maps. | Sliding Window / Frequency Map | O(S + T) | O(1) (alphabet size) | `Map<Character, Integer> patternMap = new HashMap<>(); Map<Character, Integer> windowMap = new HashMap<>(); int required = patternMap.size(); int formed = 0; int left = 0, minLen = Integer.MAX_VALUE, minStart = 0; for (int right = 0; right < s.length(); right++) { // Expand and shrink logic }` |
| 119 | Swapping Nodes in a Linked List | 1721 | https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ | Find k-th node from start (`kFromStart`) and k-th from end (`kFromEnd`) using two pointers. Swap their values. | Use two pointers to locate k-th from end efficiently. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; for (int i = 0; i < k-1; i++) fast = fast.next; ListNode kFromStart = fast; while (fast.next != null) { fast = fast.next; slow = slow.next; } ListNode kFromEnd = slow; int temp = kFromStart.val; kFromStart.val = kFromEnd.val; kFromEnd.val = temp;` |
| 120 | Odd Even Linked List | 328 | https://leetcode.com/problems/odd-even-linked-list/ | Maintain `oddPtr` and `evenPtr` to build odd and even lists. Connect odd nodes to odd, even to even. Link odd tail to even head. | Separate odd and even nodes, then reconnect. | Linked List Manipulation | O(n) | O(1) | `ListNode oddHead = head; ListNode evenHead = head.next; ListNode oddPtr = oddHead; ListNode evenPtr = evenHead; while (evenPtr != null && evenPtr.next != null) { oddPtr.next = evenPtr.next; oddPtr = oddPtr.next; evenPtr.next = oddPtr.next; evenPtr = evenPtr.next; } oddPtr.next = evenHead;` |
| 121 | Construct Binary Tree from String | 536 | https://leetcode.com/problems/construct-binary-tree-from-string/ | Recursive. Parse number as root. Find matching parentheses for left/right subtrees. Recurse on substrings. | Parse string, handle nested parentheses for subtrees. | Recursion / Tree Construction | O(n) | O(n) (recursion stack) | `int[] build(String s, int start) { // Returns [node, endIndex] // Parse number, find '(' and matching ')', recurse for left/right } TreeNode construct(String s) { return build(s, 0)[0]; }` |
| 122 | Lowest Common Ancestor of a Binary Tree II | 1644 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ | Recursive LCA. Track if `p` and `q` found. Return LCA only if both found. If node is `p` or `q`, check other in subtrees. | Verify `p` and `q` exist before returning LCA. | Tree Traversal / Recursion | O(n) | O(h) | `boolean[] found = new boolean[2]; TreeNode lca(TreeNode root, TreeNode p, TreeNode q) { TreeNode result = lcaHelper(root, p, q); return found[0] && found[1] ? result : null; } TreeNode lcaHelper(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; if (root == p) { found[0] = true; return root; } if (root == q) { found[1] = true; return root; } TreeNode left = lcaHelper(root.left, p, q); TreeNode right = lcaHelper(root.right, p, q); if (left != null && right != null) return root; return left != null ? left : right; }` |
| 123 | Lowest Common Ancestor of a Binary Tree III | 1650 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ | Use parent pointers. Traverse from `p` to root, store in `Set`. Traverse from `q`, return first node in `Set`. | Parent pointers allow path tracing to find intersection. | Tree Traversal / Hash Set | O(h) | O(h) | `Set<Node> visited = new HashSet<>(); while (p != null) { visited.add(p); p = p.parent; } while (q != null) { if (visited.contains(q)) return q; q = q.parent; } return null;` |
| 124 | Check if a Binary Tree is Subtree of Another Binary Tree | N/A | https://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/ | Recursive. Check if tree rooted at each node of `T` is identical to `S`. Use `isIdentical` helper to compare trees. | Traverse `T`, check identity with `S` at each node. | Tree Traversal / Recursion | O(m*n) worst, O(n) avg | O(max(h_T, h_S)) | `boolean isIdentical(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return t1.val == t2.val && isIdentical(t1.left, t2.left) && isIdentical(t1.right, t2.right); } boolean isSubtree(TreeNode T, TreeNode S) { if (T == null) return false; if (isIdentical(T, S)) return true; return isSubtree(T.left, S) || isSubtree(T.right, S); }` |
| 125 | Flattening a Linked List | N/A | https://www.geeksforgeeks.org/flattening-a-linked-list/ | Recursive. Flatten `next` list, merge current `down` list with flattened result using sorted merge. | Merge sorted `down` lists recursively. | Linked List / Recursion | O(N * M) | O(N) (recursion) | `Node merge(Node list1, Node list2) { // Standard merge sorted lists } Node flatten(Node root) { if (root == null || root.next == null) return root; root.next = flatten(root.next); return merge(root, root.next); }` |
| 126 | Subset Sum Problem | N/A | https://www.geeksforgeeks.org/subset-sum-problem-dp-25/ | DP Memoization. `dp(index, target)` = can `target` be formed from `index` onwards. Recurrence: include or exclude `arr[index]`. | State: (index, target sum); try include/exclude. | Dynamic Programming | O(n * target_sum) | O(n * target_sum) | `Map<String, Boolean> memo = new HashMap<>(); boolean solve(int i, int target, int[] arr) { if (target == 0) return true; if (i == arr.length) return false; String key = i + "-" + target; if (memo.containsKey(key)) return memo.get(key); boolean include = arr[i] <= target ? solve(i + 1, target - arr[i], arr) : false; boolean exclude = solve(i + 1, target, arr); memo.put(key, include || exclude); return memo.get(key); }` |
| 127 | Partition Problem | N/A | https://www.geeksforgeeks.org/partition-problem-dp-18/ | Subset Sum variant. If total sum is even, check if subset with `totalSum / 2` exists using Subset Sum DP. | Reduce to Subset Sum with target = totalSum / 2. | Dynamic Programming | O(n * total_sum) | O(n * total_sum) | `int totalSum = 0; for (int num : arr) totalSum += num; if (totalSum % 2 != 0) return false; return solve(0, totalSum / 2, arr, new HashMap<>()); // Subset Sum logic` |
| 128 | Minimum Coins Make Given Value | N/A | https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-given-value/ | DP Memoization. `dp(value)` = min coins for `value`. Recurrence: min(1 + `dp(value - coin)`) for valid coins. | State: remaining value; try each coin. | Dynamic Programming | O(target_value * num_coins) | O(target_value) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int value, int[] coins) { if (value == 0) return 0; if (value < 0) return -1; if (memo.containsKey(value)) return memo.get(value); int minCoins = Integer.MAX_VALUE; for (int coin : coins) { int res = solve(value - coin, coins); if (res != -1) minCoins = Math.min(minCoins, res + 1); } memo.put(value, minCoins == Integer.MAX_VALUE ? -1 : minCoins); return memo.get(value); }` |
| 129 | Matrix Chain Multiplication | N/A | https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/ | DP Memoization. `dp(i, j)` = min multiplications for matrices `i` to `j`. Recurrence: min(`dp(i, k) + dp(k+1, j) + p[i-1]*p[k]*p[j]`) for k. | State: (start, end indices); try all splits. | Dynamic Programming | O(n^3) | O(n^2) | `int[][] memo; int solve(int i, int j, int[] p) { if (i == j) return 0; if (memo[i][j] != -1) return memo[i][j]; int minCost = Integer.MAX_VALUE; for (int k = i; k < j; k++) { int cost = solve(i, k, p) + solve(k + 1, j, p) + p[i - 1] * p[k] * p[j]; minCost = Math.min(minCost, cost); } return memo[i][j] = minCost; }` |
| 130 | Maximum Sum Increasing Subsequence | N/A | https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/ | DP. `dp[i]` = max sum of increasing subsequence ending at `i`. For each `i`, check `j < i` where `arr[i] > arr[j]`, update `dp[i]`. | Iterate previous indices for increasing property. | Dynamic Programming | O(n^2) | O(n) | `int[] dp = new int[n]; for (int i = 0; i < n; i++) dp[i] = arr[i]; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (arr[i] > arr[j]) dp[i] = Math.max(dp[i], dp[j] + arr[i]); } } int maxSum = 0; for (int sum : dp) maxSum = Math.max(maxSum, sum);` |
| 131 | Minimum Insertion Steps to Make a String Palindrome | N/A | https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindromic-string-dp-28/ | DP. Find Longest Palindromic Subsequence (LPS). Result = `s.length() - LPS`. `dp(i, j)` = LPS length for `s[i..j]`. Recurrence: if `s[i] == s[j]`, `2 + dp(i+1, j-1)`; else, max of subproblems. | Use LPS to compute min insertions. | Dynamic Programming | O(n^2) | O(n^2) | `int[][] memo; int lps(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != 0) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) return memo[i][j] = 2 + lps(s, i + 1, j - 1); return memo[i][j] = Math.max(lps(s, i + 1, j), lps(s, i, j - 1)); } // Result: s.length() - lps(s, 0, s.length() - 1)` |
| 132 | Search an Element in a Sorted and Pivoted Array | N/A | https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/ | Binary search. Check if left or right half is sorted. If target lies in sorted half, search there; else, search other half. | Identify sorted portion and narrow search. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[low] <= nums[mid] && target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; }` |
| 133 | Find the Maximum j  i Such that arr[j] > arr[i] | N/A | https://www.geeksforgeeks.org/find-the-maximum-j-i-such-that-arrj-arri/ | Create `LMin[i]` (min from 0 to i) and `RMax[j]` (max from j to n-1). Use two pointers `i`, `j`. If `RMax[j] > LMin[i]`, try next `j`; else, next `i`. Track max `j-i`. | Precompute min/max arrays, use two pointers. | Array / Two Pointers | O(n) | O(n) | `int[] LMin = new int[n]; int[] RMax = new int[n]; LMin[0] = arr[0]; for (int i = 1; i < n; i++) LMin[i] = Math.min(arr[i], LMin[i-1]); RMax[n-1] = arr[n-1]; for (int j = n-2; j >= 0; j--) RMax[j] = Math.max(arr[j], RMax[j+1]); int i = 0, j = 0, maxDiff = -1; while (i < n && j < n) { if (RMax[j] > LMin[i]) { maxDiff = Math.max(maxDiff, j - i); j++; } else i++; }` |
| 134 | Insert into a Sorted Circular Linked List | 708 | https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/ | Find insertion point: where `node.val <= insertVal <= node.next.val`, or at lists break (max to min), or if all equal. Insert new node. Handle empty/single node cases. | Handle sorted segment, break point, and equal values. | Linked List / Circular | O(n) | O(1) | `if (head == null) { Node newNode = new Node(insertVal); newNode.next = newNode; return newNode; } Node curr = head; while (true) { if (curr.val <= insertVal && insertVal <= curr.next.val || curr.val > curr.next.val && (insertVal >= curr.val || insertVal <= curr.next.val)) { Node newNode = new Node(insertVal); newNode.next = curr.next; curr.next = newNode; break; } curr = curr.next; if (curr == head) break; }` |
| 135 | Binary Tree Upside Down | 156 | https://leetcode.com/problems/binary-tree-upside-down/ | Iterative. Left child becomes root, root becomes right child, right child becomes left child. Use pointers `curr`, `prev`, `next` to transform bottom-up. | Transform tree level by level using pointer updates. | Tree Transformation | O(n) | O(1) | `Node curr = root; Node prev = null; Node next = null; while (curr != null) { next = curr.left; curr.left = prev; prev = curr.right; curr.right = curr; curr = next; } return prev;` |
| 136 | Boundary Traversal of Binary Tree | N/A | https://www.geeksforgeeks.org/boundary-traversal-of-binary-tree/ | Traverse left boundary (top-down, exclude leaf), leaves (inorder), right boundary (bottom-up, exclude leaf). Handle duplicates and single-node cases. | Split into three traversals, avoid duplicate leaves. | Tree Traversal | O(n) | O(h) | `void leftBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; result.add(node.val); leftBoundary(node.left != null ? node.left : node.right, result); } void leaves(TreeNode node, List<Integer> result) { if (node == null) return; if (node.left == null && node.right == null) result.add(node.val); leaves(node.left, result); leaves(node.right, result); } void rightBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; rightBoundary(node.right != null ? node.right : node.left, result); result.add(node.val); }` |
| 137 | Clone a Binary Tree with Random Pointers | N/A | https://www.geeksforgeeks.org/clone-binary-tree-with-random-pointers/ | Two-pass. First: create nodes and map original to clones. Second: set `left`, `right`, `random` pointers using map. | Map ensures correct pointer assignments. | Tree Traversal / Hash Map | O(n) | O(n) | `Map<Node, Node> map = new HashMap<>(); Node clone(Node root) { if (root == null) return null; if (map.containsKey(root)) return map.get(root); Node newNode = new Node(root.val); map.put(root, newNode); newNode.left = clone(root.left); newNode.right = clone(root.right); newNode.random = clone(root.random); return newNode; }` |
| 138 | Convert an Arbitrary Binary Tree to a Tree that Holds Children Sum Property | N/A | https://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/ | Post-order. Recurse on children. If node value < children sum, set node value to sum. If node value > sum, increase children to match (propagate down). | Adjust node or children values post-order. | Tree Traversal / Recursion | O(n^2) worst case | O(h) | `void convert(Node node) { if (node == null || (node.left == null && node.right == null)) return; convert(node.left); convert(node.right); int childSum = (node.left != null ? node.left.val : 0) + (node.right != null ? node.right.val : 0); if (node.val <= childSum) node.val = childSum; else incrementChildren(node, node.val - childSum); } void incrementChildren(Node node, int diff) { if (node.left != null) node.left.val += diff; else if (node.right != null) node.right.val += diff; }` |
| 139 | Print Nodes at Distance k from Given Node in Binary Tree | N/A | https://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root/ | Two parts: nodes k distance below target (DFS), and nodes k distance via ancestors (track distance to target, print in other subtree). | Handle downward and ancestor paths separately. | Tree Traversal / Recursion | O(n) | O(h) | `int printKDistance(Node root, Node target, int k) { if (root == null) return -1; if (root == target) { printBelow(root, k); return 0; } int leftDist = printKDistance(root.left, target, k); if (leftDist != -1) { if (leftDist + 1 == k) System.out.println(root.val); else printBelow(root.right, k - leftDist - 2); return leftDist + 1; } // Similar for right subtree } void printBelow(Node node, int k) { if (node == null || k < 0) return; if (k == 0) System.out.println(node.val); printBelow(node.left, k-1); printBelow(node.right, k-1); }` |
| 140 | Longest Bitonic Subsequence | N/A | https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/ | DP. Compute `lis[i]` (LIS ending at i) and `lds[i]` (LDS starting at i). Max bitonic length = `lis[i] + lds[i] - 1` for any i. | Combine LIS and LDS through each index. | Dynamic Programming | O(n^2) | O(n) | `int[] lis = new int[n]; int[] lds = new int[n]; for (int i = 0; i < n; i++) lis[i] = 1; for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j]) lis[i] = Math.max(lis[i], lis[j] + 1); for (int i = 0; i < n; i++) lds[i] = 1; for (int i = n-2; i >= 0; i--) for (int j = n-1; j > i; j--) if (arr[i] > arr[j]) lds[i] = Math.max(lds[i], lds[j] + 1); int maxLen = 0; for (int i = 0; i < n; i++) maxLen = Math.max(maxLen, lis[i] + lds[i] - 1);` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 141 | Rod Cutting | N/A | https://www.geeksforgeeks.org/cutting-a-rod-dp-13/ | Dynamic Programming (Memoization). Define `dp(length)` as max value for rod of length `length`. Recurrence: `dp(l) = max(price[i] + dp(l - i - 1))` for `i` from 0 to `l-1` (cuts of length `i+1`). Base case: `dp(0) = 0`. | State is remaining rod length. Maximize value by trying all possible first cuts. | Dynamic Programming (Memoization) | O(n^2) | O(n) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int length, int[] price) { if (length == 0) return 0; if (memo.containsKey(length)) return memo.get(length); int maxVal = Integer.MIN_VALUE; for (int i = 0; i < length; i++) maxVal = Math.max(maxVal, price[i] + solve(length - (i + 1), price)); memo.put(length, maxVal); return maxVal; }` |
| 142 | Min Cost Path | N/A | https://www.geeksforgeeks.org/min-cost-path-dp-6/ | Dynamic Programming (Memoization). Define `dp(r, c)` as min cost to reach `(r, c)` from `(0, 0)`. Recurrence: `dp(r, c) = grid[r][c] + min(dp(r-1, c), dp(r, c-1), dp(r-1, c-1))`. Base case: `dp(0, 0) = grid[0][0]`. Handle boundaries. | State is current cell. Minimize cost from valid neighbors (up, left, diagonal). | Dynamic Programming, Grid Traversal | O(rows * cols) | O(rows * cols) | `int[][] memo; int solve(int r, int c, int[][] grid) { if (r < 0 || c < 0) return Integer.MAX_VALUE; if (r == 0 && c == 0) return grid[0][0]; if (memo[r][c] != -1) return memo[r][c]; int minPrevCost = Math.min(Math.min(solve(r - 1, c, grid), solve(r, c - 1, grid)), solve(r - 1, c - 1, grid)); return memo[r][c] = grid[r][c] + minPrevCost; }` |
| 143 | Maximize Greatness of an Array | 2592 | https://leetcode.com/problems/maximize-greatness-of-an-array/ | Sort array. Use two pointers: `p1` for permuted array, `p2` for original sorted array. For each `nums[p1]`, find smallest `nums[p2]` where `nums[p2] > nums[p1]`. Increment greatness and both pointers if found, else advance `p2`. | Greedy: pair each element with smallest greater element. | Sorting, Two Pointers, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); int p1 = 0, p2 = 0, greatness = 0; while (p1 < nums.length && p2 < nums.length) { if (p2 < nums.length && nums[p2] > nums[p1]) { greatness++; p1++; p2++; } else p2++; } return greatness;` |
| 144 | Count Complete Subarrays in an Array | 2799 | https://leetcode.com/problems/count-complete-subarrays-in-an-array/ | Find `k` (distinct elements in array). Use sliding window with frequency map. Expand until window has `k` distinct elements. Count subarrays ending at `right` starting from `left` or later. Shrink `left` and repeat. | Count valid subarrays by tracking distinct elements in window. | Sliding Window, Frequency Map | O(n) | O(D) | `int distinctCount = new HashSet<>(Arrays.asList(Arrays.stream(nums).boxed().toArray())).size(); Map<Integer, Integer> windowFreq = new HashMap<>(); int left = 0, count = 0; for (int right = 0; right < nums.length; right++) { windowFreq.put(nums[right], windowFreq.getOrDefault(nums[right], 0) + 1); while (windowFreq.size() == distinctCount) { count += nums.length - right; windowFreq.put(nums[left], windowFreq.get(nums[left]) - 1); if (windowFreq.get(nums[left]) == 0) windowFreq.remove(nums[left]); left++; } } return count;` |
| 145 | Maximum Number of Upgradable Servers | 1947 | https://leetcode.com/problems/maximum-number-of-upgradable-servers/ | Recursive DP on tree/graph. For each server, compute max upgradable servers in subtree for two states: upgraded or not. Use memoization to store results. Consider dependencies (parent must be upgraded). | State: (server, isUpgraded). Recurse on children, aggregate results. | Dynamic Programming, Tree/Graph Traversal | O(n) | O(n) | `Map<Integer, int[]> memo; int[] solve(int serverId, int parentId, List<List<Integer>> adj, int[] cost, int[] value) { if (memo.containsKey(serverId)) return memo.get(serverId); int[] result = new int[2]; // [upgraded, notUpgraded] // Recurse on children, compute max for both states return result; }` |
| 146 | Double a Number Represented as a Linked List | 2816 | https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/ | Recursive approach. Process list from right to left via recursion. Double each digit, handle carry. Return carry for previous digit. Use dummy node for potential leading digit. | Recurse to process least significant digits first, propagate carry. | Linked List, Recursion | O(n) | O(n) | `int doubleHelper(ListNode node) { if (node == null) return 0; int carry = doubleHelper(node.next); int newVal = node.val * 2 + carry; node.val = newVal % 10; return newVal / 10; } ListNode doubleIt(ListNode head) { int carry = doubleHelper(head); if (carry > 0) { ListNode newHead = new ListNode(carry); newHead.next = head; return newHead; } return head; }` |
| 147 | Merge In Between Linked Lists | 1669 | https://leetcode.com/problems/merge-in-between-linked-lists/ | Locate node at `a-1` and `b` in `list1`. Find `list2` head and tail. Connect `a-1` to `list2` head, `list2` tail to `b.next`. | Identify and relink four key pointers. | Linked List Manipulation | O(a + b) | O(1) | `ListNode nodeBeforeA = head; for (int i = 0; i < a - 1; i++) nodeBeforeA = nodeBeforeA.next; ListNode nodeB = head; for (int i = 0; i < b; i++) nodeB = nodeB.next; ListNode list2Tail = list2; while (list2Tail.next != null) list2Tail = list2Tail.next; nodeBeforeA.next = list2; list2Tail.next = nodeB.next;` |
| 148 | Valid Anagram | 242 | https://leetcode.com/problems/valid-anagram/ | Use frequency array for lowercase letters. Increment counts for `s`, decrement for `t`. Check if all counts are zero. | Identical character frequencies indicate anagrams. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (char c : t.toCharArray()) count[c - 'a']--; for (int i : count) if (i != 0) return false; return true;` |
| 149 | Longest Consecutive Sequence | 128 | https://leetcode.com/problems/longest-consecutive-sequence/ | Use HashSet for O(1) lookups. For each number, if its a sequence start (`num-1` not in set), count consecutive numbers (`num+1`, `num+2`, ...). Track max length. | Only count from sequence starts to avoid redundant work. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) set.add(num); int maxLen = 0; for (int num : nums) { if (!set.contains(num - 1)) { int currentNum = num; int currentLen = 0; while (set.contains(currentNum)) { currentLen++; currentNum++; } maxLen = Math.max(maxLen, currentLen); } } return maxLen;` |
| 150 | Find the Duplicate Number | 287 | https://leetcode.com/problems/find-the-duplicate-number/ | Floyds Tortoise and Hare. Treat array as linked list (`index i` points to `nums[i]`). Find cycle meeting point, then cycle start (duplicate). | Array forms a cycle due to duplicate. Cycle start is the duplicate. | Cycle Detection | O(n) | O(1) | `int tortoise = nums[0]; int hare = nums[0]; do { tortoise = nums[tortoise]; hare = nums[nums[hare]]; } while (tortoise != hare); tortoise = nums[0]; while (tortoise != hare) { tortoise = nums[tortoise]; hare = nums[hare]; } return hare;` |
| 151 | Kth Largest Element in an Array | 215 | https://leetcode.com/problems/kth-largest-element-in-an-array/ | QuickSelect. Partition around pivot. If pivot position is `n-k`, return pivot. If less, recurse right; if greater, recurse left. | Partition to narrow search for kth largest. | QuickSelect | O(n) avg | O(log n) | `int quickSelect(int[] nums, int low, int high, int k) { int pivot = partition(nums, low, high); if (pivot == nums.length - k) return nums[pivot]; if (pivot < nums.length - k) return quickSelect(nums, pivot + 1, high, k); return quickSelect(nums, low, pivot - 1, k); }` |
| 152 | Find Median from Data Stream | 295 | https://leetcode.com/problems/find-median-from-data-stream/ | Use max-heap for lower half, min-heap for upper half. Keep max-heap size equal or one more than min-heap. Median is max-heap top or average of both tops. | Two heaps split data for O(log n) insertion, O(1) median. | Two Heaps | O(log n) add, O(1) median | O(n) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); void addNum(int num) { maxHeap.offer(num); minHeap.offer(maxHeap.poll()); if (maxHeap.size() < minHeap.size()) maxHeap.offer(minHeap.poll()); } double findMedian() { return maxHeap.size() > minHeap.size() ? maxHeap.peek() : (maxHeap.peek() + minHeap.peek()) / 2.0; }` |
| 153 | Valid Palindrome | 125 | https://leetcode.com/problems/valid-palindrome/ | Two pointers from start and end. Skip non-alphanumeric, compare lowercase alphanumeric chars. | Ignore non-alphanumeric, case-insensitive comparison. | Two Pointers, String | O(n) | O(1) | `int left = 0, right = s.length() - 1; while (left < right) { char l = s.charAt(left), r = s.charAt(right); if (!Character.isLetterOrDigit(l)) left++; else if (!Character.isLetterOrDigit(r)) right--; else if (Character.toLowerCase(l) != Character.toLowerCase(r)) return false; else { left++; right--; } } return true;` |
| 154 | Longest Common Prefix | 14 | https://leetcode.com/problems/longest-common-prefix/ | Compare chars at same index across all strings. Stop at mismatch or end of any string. | First mismatch determines prefix length. | String | O(S) | O(1) | `if (strs.length == 0) return ""; for (int i = 0; i < strs[0].length(); i++) { char c = strs[0].charAt(i); for (int j = 1; j < strs.length; j++) { if (i >= strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); } } return strs[0];` |
| 155 | Regular Expression Matching | 10 | https://leetcode.com/problems/regular-expression-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `.` and `*`. If `*`, try zero or more matches. Else, check direct match. | Recurrence based on pattern chars and `*`. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '.' || pattern.charAt(j) == text.charAt(i))); if (j + 1 < pattern.length() && pattern.charAt(j + 1) == '*') return memo[i][j] = (solve(text, pattern, i, j + 2) || (firstMatch && solve(text, pattern, i + 1, j))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 156 | Wildcard Matching | 44 | https://leetcode.com/problems/wildcard-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `?` and `*`. If `*`, try zero or more chars. If `?` or char match, advance both. | Recurrence based on `?` and `*` handling. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; if (pattern.charAt(j) == '*') return memo[i][j] = (solve(text, pattern, i, j + 1) || (i < text.length() && solve(text, pattern, i + 1, j))); boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '?' || pattern.charAt(j) == text.charAt(i))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 157 | First Unique Character in a String | 387 | https://leetcode.com/problems/first-unique-character-in-a-string/ | Use frequency array. Count char occurrences in first pass. In second pass, return index of first char with count 1. | Two passes: count frequencies, find first unique. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (int i = 0; i < s.length(); i++) if (count[s.charAt(i) - 'a'] == 1) return i; return -1;` |
| 158 | Intersection of Two Arrays | 349 | https://leetcode.com/problems/intersection-of-two-arrays/ | HashSet for `nums1`. Check `nums2` elements in set, add to result set, remove from set to avoid duplicates. | Set for O(1) lookups, ensure unique results. | Hash Set | O(m + n) | O(min(m, n)) | `Set<Integer> set1 = new HashSet<>(); for (int num : nums1) set1.add(num); Set<Integer> resultSet = new HashSet<>(); for (int num : nums2) if (set1.contains(num)) resultSet.add(num); return resultSet.toArray(new Integer[0]);` |
| 159 | Intersection of Two Arrays II | 350 | https://leetcode.com/problems/intersection-of-two-arrays-ii/ | HashMap for `nums1` frequencies. For `nums2`, add to result if count > 0, decrement count. | Frequency map handles duplicates correctly. | Hash Map | O(m + n) | O(min(m, n)) | `Map<Integer, Integer> freq = new HashMap<>(); for (int num : nums1) freq.put(num, freq.getOrDefault(num, 0) + 1); List<Integer> resultList = new ArrayList<>(); for (int num : nums2) if (freq.containsKey(num) && freq.get(num) > 0) { resultList.add(num); freq.put(num, freq.get(num) - 1); } return resultList.stream().mapToInt(i -> i).toArray();` |
| 160 | Sliding Window Median | 480 | https://leetcode.com/problems/sliding-window-median/ | Two heaps: max-heap for lower half, min-heap for upper half. Add/remove elements as window slides, balance heaps. Median from heap tops. | Heaps maintain sorted window for O(log k) updates. | Sliding Window, Two Heaps | O(n log k) | O(k) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); for (int i = 0; i < nums.length; i++) { // Add nums[i], remove nums[i-k], balance, compute median }` |
| 161 | Find K Pairs with Smallest Sums | 373 | https://leetcode.com/problems/find-k-pairs-with-smallest-sums/ | Min-PQ with `(sum, i, j)`. Start with `(nums1[i] + nums2[0], i, 0)`. Extract min, add to result, push next pair `(nums1[i] + nums2[j+1], i, j+1)` if valid. Repeat k times. | PQ explores sums in order, next pair from same `i`. | Priority Queue | O(k log k) | O(k) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); for (int i = 0; i < Math.min(k, nums1.length); i++) pq.offer(new int[]{nums1[i] + nums2[0], i, 0}); List<List<Integer>> result = new ArrayList<>(); while (k-- > 0 && !pq.isEmpty()) { int[] curr = pq.poll(); result.add(Arrays.asList(nums1[curr[1]], nums2[curr[2]])); if (curr[2] + 1 < nums2.length) pq.offer(new int[]{nums1[curr[1]] + nums2[curr[2] + 1], curr[1], curr[2] + 1}); }` |
| 162 | Kth Largest Element in a Stream | 703 | https://leetcode.com/problems/kth-largest-element-in-a-stream/ | Min-PQ of size `k`. Add new number, if size > `k`, remove smallest. Top is kth largest. | Min-heap maintains k largest elements. | Priority Queue | O(log k) per add | O(k) | `PriorityQueue<Integer> pq; int k; KthLargest(int k, int[] nums) { this.k = k; pq = new PriorityQueue<>(); for (int num : nums) { pq.offer(num); if (pq.size() > k) pq.poll(); } } int add(int val) { pq.offer(val); if (pq.size() > k) pq.poll(); return pq.peek(); }` |




