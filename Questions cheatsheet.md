| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 1 | Two Sum | 1 | https://leetcode.com/problems/two-sum/ | Use a HashMap to store encountered numbers and their indices. For each element nums[i], check if target - nums[i] (the complement) exists in the map. If yes, return indices. If no, add nums[i] and its index to the map. | HashMap for O(1) complement lookup. | Hash Map | O(n) | O(n) | `if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i);` |
| 2 | Longest Substring Without Repeating Characters | 3 | https://leetcode.com/problems/longest-substring-without-repeating-characters/ | Use a sliding window approach with two pointers (start, end) and a Set/Map to track characters within the window [start, end). Expand end. If s.charAt(end) is in the set, shrink the window by incrementing start and removing s.charAt(start) from the set until the duplicate is removed. Update max length. | Sliding window with Set/Map for efficient duplicate checks. | Sliding Window | O(n) | O(min(n, m)) (where m is alphabet size) | `if (set.contains(s.charAt(end))) { set.remove(s.charAt(start++)); } else { set.add(s.charAt(end++)); maxLen = Math.max(maxLen, end - start); }` |
| 3 | Median of Two Sorted Arrays | 4 | https://leetcode.com/problems/median-of-two-sorted-arrays/ | Use binary search on the smaller array to find the correct partition point partitionX. Calculate the corresponding partition partitionY in the other array such that partitionX + partitionY = (n+m+1)/2. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. Adjust binary search range based on comparison. | Binary search on partitions to find median in logarithmic time. | Binary Search | O(log(min(n, m))) | O(1) | `if (maxLeftX <= minRightY && maxLeftY <= minRightX) { // Found partition } else if (maxLeftX > minRightY) { high = partitionX - 1; } else { low = partitionX + 1; }` |
| 4 | Maximum Subarray | 53 | https://leetcode.com/problems/maximum-subarray/ | Kadane's Algorithm: Iterate through the array, maintaining currentMax (max sum ending at current position) and globalMax (max sum found so far). currentMax = max(num, currentMax + num). Update globalMax = max(globalMax, currentMax). | Kadane's: Discard subarray prefix if its sum becomes negative. | Dynamic Programming / Greedy | O(n) | O(1) | `currentMax = Math.max(num, currentMax + num); globalMax = Math.max(globalMax, currentMax);` |
| 5 | Merge Intervals | 56 | https://leetcode.com/problems/merge-intervals/ | Sort intervals based on start times. Iterate through sorted intervals, merging overlapping ones. If the current interval overlaps with the last merged interval in the result list (current.start <= last.end), update the end of the last interval (last.end = max(last.end, current.end)). Otherwise, add the current interval as a new entry. | Sort by start then merge greedily. | Sorting / Greedy | O(n log n) | O(n) (for result list) or O(log n) (for sort) | `if (merged.isEmpty() || current.start > merged.get(merged.size() - 1).end) { merged.add(current); } else { merged.get(merged.size() - 1).end = Math.max(merged.get(merged.size() - 1).end, current.end); }` |
| 6 | Reverse Linked List | 206 | https://leetcode.com/problems/reverse-linked-list/ | Iterative approach: Use three pointers: prev (initially null), curr (initially head), and nextTemp. While curr is not null, store curr.next in nextTemp, set curr.next to prev, update prev to curr, and move curr to nextTemp. | Iterative reversal using three pointers (prev, curr, next). | Linked List | O(n) | O(1) | `ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp;` |
| 7 | LRU Cache | 146 | https://leetcode.com/problems/lru-cache/ | Use a HashMap for O(1) key lookup and a Doubly Linked List (DLL) to maintain the order of usage. Map keys to DLL nodes. On get or put (update), move the accessed node to the front of the DLL. On put when capacity is reached, remove the node from the tail of the DLL and the corresponding entry from the map. | HashMap + Doubly Linked List for O(1) get/put. | Hash Map / Doubly Linked List | O(1) for get and put | O(capacity) | `// On access (get/put): removeNode(node); addToFront(node); // On put full: Node tail = removeTail(); map.remove(tail.key);` |
| 8 | Generate Parentheses | 22 | https://leetcode.com/problems/generate-parentheses/ | Use backtracking (recursive approach). Maintain counts of open and close parentheses used. Add '(' if open < n. Add ')' if close < open. Base case: if length is 2*n, add the string to the result list. | Backtracking with constraints on open/close counts. | Backtracking / Recursion | O(4^n / (n^(3/2))) (Catalan Number) | O(n) (recursion stack) + O(n * 4^n / (n^(3/2))) (result storage) | `if (open < max) backtrack(list, str + '(', open + 1, close, max); if (close < open) backtrack(list, str + ')', open, close + 1, max);` |
| 9 | Lowest Common Ancestor of a Binary Tree | 236 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ | Recursive approach. Base cases: If root is null, p, or q, return root. Recursively find LCA in left and right subtrees (leftLCA, rightLCA). If both are non-null, current root is LCA. If only one is non-null, return that one. If both are null, return null. | Recursive search; LCA is the node where paths to p and q diverge. | Tree / Recursion / DFS | O(n) | O(n) (worst case, skewed tree) O(h) (average, height) | `ListNode leftLCA = lowestCommonAncestor(root.left, p, q); ListNode rightLCA = lowestCommonAncestor(root.right, p, q); if (leftLCA != null && rightLCA != null) return root; return (leftLCA != null) ? leftLCA : rightLCA;` |
| 10 | Longest Increasing Subsequence | 300 | https://leetcode.com/problems/longest-increasing-subsequence/ | DP with Memoization: Define dp[i] as the LIS ending at index i. To compute dp[i], iterate j from 0 to i-1. If nums[i] > nums[j], then dp[i] = max(dp[i], 1 + dp[j]). Alternatively, O(n log n) approach using patience sorting (maintain tails of potential LIS). | DP state dp[i] = LIS length ending at i. (Or O(n log n) patience sort). | Dynamic Programming | O(n^2) for basic DP, O(n log n) optimized | O(n) | `for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLength = Math.max(maxLength, dp[i]);` (for O(n^2) DP) |
| 11 | Search in Rotated Sorted Array | 33 | https://leetcode.com/problems/search-in-rotated-sorted-array/ | Modified Binary Search. Find the pivot point (minimum element) first OR directly adapt binary search. In each step, determine which half (left or right of mid) is sorted. Check if the target lies within the sorted half's range. Adjust low and high accordingly. | Modified binary search adapting to the rotation point. | Binary Search | O(log n) | O(1) | `if (nums[low] <= nums[mid]) { // Left half sorted if (target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; } else { // Right half sorted ... }` |
| 12 | Number of Islands | 200 | https://leetcode.com/problems/number-of-islands/ | Iterate through the grid. If a cell contains '1' and hasn't been visited, increment the island count and start a DFS or BFS from that cell to mark all connected '1's as visited (e.g., change '1' to '0' or use a separate visited array). | DFS/BFS traversal to explore and mark connected land cells. | Graph Traversal (DFS/BFS) | O(m*n) | O(m*n) (recursion stack for DFS or queue/visited array for BFS) | `if (grid[r][c] == '1') { count++; dfs(grid, r, c); // or bfs } // dfs(grid, r, c): mark grid[r][c] = '0'; explore neighbors` |
| 13 | Container With Most Water | 11 | https://leetcode.com/problems/container-with-most-water/ | Use two pointers, left at index 0 and right at index n-1. Calculate area min(height[left], height[right]) * (right - left). Update max area. Move the pointer pointing to the shorter line inward (left++ if height[left] < height[right], else right--). | Two pointers: move the shorter height pointer inward. | Two Pointers | O(n) | O(1) | `area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--;` |
| 14 | Trapping Rain Water | 42 | https://leetcode.com/problems/trapping-rain-water/ | Calculate maxLeft[i] (max height to the left of i) and maxRight[i] (max height to the right of i) for all i. The water trapped at index i is max(0, min(maxLeft[i], maxRight[i]) - height[i]). Sum these amounts. Can be optimized to O(1) space using two pointers. | Water at i depends on min(max_left, max_right) - height[i]. | Dynamic Programming / Two Pointers | O(n) | O(n) (for DP arrays) or O(1) (for Two Pointer) | `water += Math.max(0, Math.min(maxLeft[i], maxRight[i]) - height[i]); // DP <br> // Two Pointer: if (leftMax < rightMax) { water += leftMax - height[left]; left++; } else { water += rightMax - height[right]; right--; }` |
| 15 | Merge Two Sorted Lists | 21 | https://leetcode.com/problems/merge-two-sorted-lists/ | Iterative approach: Use a dummy head node. Maintain a current pointer for the merged list. Compare heads of list1 and list2. Append the smaller node to current.next and advance that list's pointer. Update current. After loop, append the remaining non-null list. | Dummy head node simplifies merging logic. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode dummy = new ListNode(0); ListNode current = dummy; ... if (list1.val <= list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; ... return dummy.next;` |
| 16 | Add Two Numbers | 2 | https://leetcode.com/problems/add-two-numbers/ | Iterate through both lists simultaneously using a dummy head for the result list. Keep track of carry. At each step, calculate sum = l1.val + l2.val + carry. The digit for the new node is sum % 10, and the new carry is sum / 10. Handle remaining nodes and final carry. | Simulate elementary addition with carry using linked lists. | Linked List / Simulation | O(max(n, m)) | O(max(n, m)) (for result list) | `int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); carry = sum / 10; curr.next = new ListNode(sum % 10); ...` |
| 17 | Binary Tree Inorder Traversal | 94 | https://leetcode.com/problems/binary-tree-inorder-traversal/ | Recursive approach: Helper function inorder(node, list). Base case: if node is null, return. Recursively call inorder(node.left, list), then add node.val to the list, then recursively call inorder(node.right, list). Iterative uses a Stack. | Standard recursive inorder traversal (Left-Root-Right). | Tree Traversal (DFS) | O(n) | O(n) (recursion stack / explicit stack) | `inorder(node.left, result); result.add(node.val); inorder(node.right, result);` |
| 18 | Validate Binary Search Tree | 98 | https://leetcode.com/problems/validate-binary-search-tree/ | Recursive approach: Pass down valid range (min, max) for each node. For a node, check if node.val > min and node.val < max. Recursively call for left child with range (min, node.val) and right child with range (node.val, max). | Recursive check passing valid range [min, max] down. | Tree Traversal (DFS) | O(n) | O(n) (recursion stack) | `return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);` |
| 19 | Binary Tree Level Order Traversal | 102 | https://leetcode.com/problems/binary-tree-level-order-traversal/ | Use Breadth-First Search (BFS) with a Queue. Initialize queue with root. While queue is not empty, get the size (levelSize). Process levelSize nodes: dequeue node, add its value to current level list, enqueue its non-null children. Add level list to result. | BFS using a queue to process nodes level by level. | Tree Traversal (BFS) | O(n) | O(w) (where w is max width of tree/queue size) | `int levelSize = queue.size(); List<Integer> currentLevel = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); ... queue.offer(child); }` |
| 20 | Serialize and Deserialize Binary Tree | 297 | https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ | Serialization (e.g., Preorder): Use DFS. Append node value to string/builder. If null, append a marker (e.g., 'null' or '#'). Recursively serialize left and right. Deserialization: Use a Queue/Iterator of the split serialized string. Build tree recursively. Read value, if marker, return null. Create node, recursively build left, then right. | Use Preorder/Level Order traversal with null markers for serialization. Rebuild recursively/iteratively during deserialization. | Tree Traversal (DFS/BFS) | O(n) | O(n) | `// Serialize (Preorder) sb.append(node.val).append(','); serializeHelper(node.left, sb); serializeHelper(node.right, sb); // Deserialize (Preorder) String val = nodes.poll(); if (val.equals("#")) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(nodes); node.right = deserializeHelper(nodes);` |
| 21 | Coin Change | 322 | https://leetcode.com/problems/coin-change/ | DP with Memoization. memo[amount] stores min coins for that amount. Base case: memo[0]=0. Recursive step: memo[amount] = 1 + min(solve(amount - coin)) for each coin c <= amount. Initialize memo with -1 (uncomputed) or Integer.MAX_VALUE. | DP state memo[i] = min coins for amount i. Check for Integer.MAX_VALUE to handle impossible cases. | Dynamic Programming | O(amount * coins) | O(amount) | `if (memo[rem] != -1) return memo[rem]; int minCoins = Integer.MAX_VALUE; for (int coin : coins) { if (rem >= coin) { int res = solve(rem - coin); if (res != Integer.MAX_VALUE) minCoins = Math.min(minCoins, 1 + res); } } memo[rem] = minCoins;` |
| 22 | Find Minimum in Rotated Sorted Array | 153 | https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ | Modified Binary Search. Compare nums[mid] with nums[high]. If nums[mid] < nums[high], the minimum is in the left half (including mid), so high = mid. Otherwise, the minimum is in the right half (mid + 1), so low = mid + 1. Loop ends when low == high. | Compare mid with high to decide which half contains the pivot/minimum. | Binary Search | O(log n) | O(1) | `if (nums[mid] < nums[high]) { high = mid; } else { low = mid + 1; }` |
| 23 | Course Schedule | 207 | https://leetcode.com/problems/course-schedule/ | Topological Sort using Kahn's Algorithm (BFS). Build adjacency list and calculate in-degrees. Initialize queue with nodes having in-degree 0. Process queue: dequeue node, decrement in-degree of neighbors. If neighbor's in-degree becomes 0, enqueue it. Count processed nodes; if count equals numCourses, return true. | Kahn's Algorithm (BFS + in-degree counting) for cycle detection. | Graph / Topological Sort | O(V+E) | O(V+E) (for adjacency list and in-degrees) | `Queue<Integer> queue = new LinkedList<>(); // Add nodes with inDegree 0 while (!queue.isEmpty()) { int course = queue.poll(); count++; for (int neighbor : adj.get(course)) { if (--inDegree[neighbor] == 0) queue.offer(neighbor); } } return count == numCourses;` |
| 24 | Word Ladder | 127 | https://leetcode.com/problems/word-ladder/ | BFS on implicit graph. Start BFS from beginWord. Each level represents one transformation. Use a Set for wordList for O(1) lookup and a Set for visited words. In each step, generate all possible 1-letter transformations of the current word. If a transformation is in wordList and not visited, add to queue and mark visited. | BFS for shortest path in unweighted graph. Generate neighbors by changing one char at a time. | Graph / BFS | O(N * M^2) (N=wordList size, M=word length) | O(N*M) (for word set and visited set/queue) | `for (int i = 0; i < word.length(); i++) { char[] chars = word.toCharArray(); for (char c = 'a'; c <= 'z'; c++) { chars[i] = c; String neighbor = new String(chars); if (wordSet.contains(neighbor) && !visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } }` |
| 25 | Group Anagrams | 49 | https://leetcode.com/problems/group-anagrams/ | Use a HashMap where the key represents the character count/sorted version of a string, and the value is a list of anagrams. Iterate through strs, generate the key for each string (e.g., sort the string or create a count array string like 'a1b1c0...'), and add the original string to the list associated with that key. | Canonical representation (sorted string or char count) as HashMap key. | Hash Map | O(N * K log K) or O(N*K) (N=num strings, K=max length) | O(N*K) (for storing anagram groups) | `char[] ca = str.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);` |
| 26 | Valid Parentheses | 20 | https://leetcode.com/problems/valid-parentheses/ | Use a Stack. Iterate through the string. If an opening bracket ('(', '{', '[') is encountered, push it onto the stack. If a closing bracket is found, check if the stack is empty or if the top element is the corresponding opening bracket. If not, return false. Pop if it matches. After iteration, the stack must be empty. | Stack to match opening/closing brackets LIFO order. | Stack | O(n) | O(n) | `if (c == '(' || c == '{' || c == '[') stack.push(c); else if (stack.isEmpty() || !isMatching(stack.pop(), c)) return false;` |
| 27 | Combination Sum | 39 | https://leetcode.com/problems/combination-sum/ | Backtracking/DFS. Define a recursive function findCombinations(index, currentSum, currentList). Base cases: if currentSum == target, add currentList to results. If currentSum > target or index >= candidates.length, return. Recursive step: Include candidates[index] (call findCombinations(index, ..., ...) again) and Exclude candidates[index] (call findCombinations(index + 1, ..., ...)). | Standard backtracking allowing element reuse. | Backtracking / Recursion | O(N^(T/M)) (approx, N=candidates, T=target, M=min candidate) | O(T/M) (recursion depth) + O(Result Size) | `// Include candidate[i] currentList.add(candidates[i]); backtrack(result, currentList, candidates, remaining - candidates[i], i); // crucial: pass i not i+1 currentList.remove(currentList.size() - 1); // Backtrack` |
| 28 | Permutations | 46 | https://leetcode.com/problems/permutations/ | Backtracking/DFS. Use a boolean used array or swap elements. Define backtrack(currentPermutation). Base case: if currentPermutation.size() == nums.length, add to results. Loop through nums: if nums[i] is not used, add it to currentPermutation, mark as used, recurse (backtrack(...)), unmark, remove from currentPermutation. | Backtracking with mechanism (visited array/swapping) to track used elements. | Backtracking / Recursion | O(N * N!) | O(N) (recursion depth) + O(N * N!) (result storage) | `if (tempList.size() == nums.length) { result.add(new ArrayList<>(tempList)); } else { for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; tempList.add(nums[i]); backtrack(result, tempList, nums, used); tempList.remove(tempList.size() - 1); used[i] = false; } }` |
| 29 | Word Search | 79 | https://leetcode.com/problems/word-search/ | Backtracking/DFS. Iterate through each cell as a potential starting point. Call DFS helper search(r, c, index). Base case: index == word.length(), return true. Check bounds, if board[r][c] != word.charAt(index), return false. Mark current cell (e.g., board[r][c] = '#'). Explore 4 neighbors recursively search(nr, nc, index + 1). If any returns true, return true. Unmark cell (backtrack) board[r][c] = originalChar. Return false if no path found. | DFS with backtracking (marking visited path). | Backtracking / DFS | O(N * M * 4^L) (N, M=dims, L=word length) | O(L) (recursion depth) | `char temp = board[r][c]; board[r][c] = '#'; // Mark visited boolean found = dfs(board, r+1, c, word, index+1) || dfs(board, r-1, c, word, index+1) || dfs(board, r, c+1, word, index+1) || dfs(board, r, c-1, word, index+1); board[r][c] = temp; // Backtrack` |
| 30 | Sudoku Solver | 37 | https://leetcode.com/problems/sudoku-solver/ | Backtracking. Find the next empty cell ('.'). Try filling it with digits '1' through '9'. For each digit, check if it's valid (using helper isValid(row, col, digit) checking row, col, and 3x3 subgrid). If valid, place digit and recursively call solve(). If recursive call returns true, return true. If not, backtrack (reset cell to '.'). If no digit works for the cell, return false. Base case: no empty cells found, return true. | Backtracking search trying digits 1-9 in empty cells, pruning invalid states. | Backtracking / Recursion | O(9^(N*N)) (with pruning, much faster in practice) | O(N*N) (recursion depth/board state) | `for (char c = '1'; c <= '9'; c++) { if (isValid(board, row, col, c)) { board[row][col] = c; if (solve(board)) return true; board[row][col] = '.'; // Backtrack } } return false;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 32 | Minimum Window Substring | 76 | https://leetcode.com/problems/minimum-window-substring/ | Sliding Window with Frequency Maps. Use two HashMaps (or arrays) `tFreq` for pattern `t` and `windowFreq` for current window in `s`. Use `required` count (distinct chars in `t`) and `formed` count (distinct chars in window matching `required` count). Expand `end` pointer, update `windowFreq` and `formed`. When `formed == required`, shrink `start` pointer, update window, check if still valid (`formed == required`), and update min window. | Sliding window with two pointers and frequency maps to track character counts. | Sliding Window / Hash Map | O(\|S\| + \|T\|) | O(\|T\|) or O(alphabet size) | `while (formed == required) { // Shrink window updateMinWindow(...); char leftChar = s.charAt(start); windowFreq[leftChar]--; if (tFreq.containsKey(leftChar) && windowFreq[leftChar] < tFreq.get(leftChar)) { formed--; } start++; }` |
| 33 | 3Sum | 15 | https://leetcode.com/problems/3sum/ | Sort the array. Iterate through the array with index `i` from 0 to n-3. For each `nums[i]`, use two pointers `left = i + 1` and `right = n - 1`. Calculate `sum = nums[i] + nums[left] + nums[right]`. If `sum == 0`, add `[nums[i], nums[left], nums[right]]` to result, increment `left`, decrement `right`, and skip duplicates. If `sum < 0`, `left++`. If `sum > 0`, `right--`. Skip duplicates for `i` as well. | Sort + Two Pointers approach after fixing one element. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) depending on sort | `while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { result.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left < right && nums[left] == nums[left+1]) left++; // Skip duplicates while (left < right && nums[right] == nums[right-1]) right--; left++; right--; } else if (sum < 0) left++; else right--; }` |
| 34 | Merge k Sorted Lists | 23 | https://leetcode.com/problems/merge-k-sorted-lists/ | Use a Min-Heap (PriorityQueue) to store the head nodes of the k lists, ordered by value. Repeatedly extract the minimum node from the heap, add it to the result list (using a dummy head), and if the extracted node has a `next`, add `next` to the heap. | Min-Heap to efficiently find the smallest current element across k lists. | Heap (Priority Queue) | O(N log k) N=total nodes, k=lists | O(k) for heap, O(N) for result list | `PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val)); for (ListNode node : lists) { if (node != null) pq.offer(node); } while (!pq.isEmpty()) { ListNode minNode = pq.poll(); current.next = minNode; current = current.next; if (minNode.next != null) pq.offer(minNode.next); }` |
| 35 | Construct Binary Tree from Preorder and Inorder Traversal | 105 | https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ | Recursive approach. Use preorder to identify the root (`preorder[preStart]`). Find the root's index (`inIndex`) in the inorder traversal (use a HashMap for O(1) lookup). Elements left of `inIndex` in inorder form the left subtree, elements right form the right subtree. Recursively build left subtree using `preorder[preStart+1 ...]` and `inorder[inStart ... inIndex-1]`. Recursively build right subtree using remaining preorder and `inorder[inIndex+1 ... inEnd]`. | Preorder gives root, Inorder splits left/right subtrees. HashMap for Inorder lookup. | Tree / Recursion / DFS / Hash Map | O(N) | O(N) for map and recursion stack | `int rootVal = preorder[preStart]; TreeNode root = new TreeNode(rootVal); int inIndex = map.get(rootVal); int leftSize = inIndex - inStart; root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, inorder, inStart, inIndex - 1, map); root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, inorder, inIndex + 1, inEnd, map);` |
| 36 | Longest Palindromic Substring | 5 | https://leetcode.com/problems/longest-palindromic-substring/ | Expand Around Center approach. Iterate through the string, considering each character `i` and each pair `(i, i+1)` as potential centers of a palindrome. For each center, expand outwards (`left--`, `right++`) while `s.charAt(left) == s.charAt(right)`. Keep track of the longest palindrome found. | Expand from center (odd and even length palindromes). | String / Dynamic Programming / Two Pointers | O(n^2) | O(1) | `for (int i = 0; i < s.length(); i++) { expandAroundCenter(s, i, i); // Odd length expandAroundCenter(s, i, i + 1); // Even length } // expandAroundCenter updates global start/maxLength` |
| 37 | Contains Duplicate | 217 | https://leetcode.com/problems/contains-duplicate/ | Use a HashSet. Iterate through the array `nums`. For each number, try to add it to the set. If `set.add(num)` returns `false`, it means the number is already in the set, so return `true`. If the loop finishes without finding duplicates, return `false`. | HashSet for O(1) average time duplicate checking. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) { if (!set.add(num)) return true; } return false;` |
| 38 | Longest Repeating Character Replacement | 424 | https://leetcode.com/problems/longest-repeating-character-replacement/ | Sliding Window. Maintain a window `[start, end]` and a frequency map (array `int[26]`) of characters in the window. Keep track of the frequency of the most frequent character (`maxFreq`). If `windowSize (end - start + 1) - maxFreq > k`, the window is invalid (too many replacements needed). Shrink the window by incrementing `start` and decrementing the count of `s.charAt(start)`. Update `maxLength` in each step. | Sliding window tracking max frequency and replacements needed. | Sliding Window / Hash Map | O(n) | O(1) (alphabet size 26) | `count[s.charAt(end) - 'A']++; maxFreq = Math.max(maxFreq, count[s.charAt(end) - 'A']); while (end - start + 1 - maxFreq > k) { count[s.charAt(start) - 'A']--; start++; // Note: maxFreq doesn't need explicit decrement here, it corrects itself } maxLength = Math.max(maxLength, end - start + 1);` |
| 39 | Sliding Window Maximum | 239 | https://leetcode.com/problems/sliding-window-maximum/ | Use a Deque (Double-Ended Queue) to store indices of elements in the current window. The deque maintains indices in decreasing order of their corresponding values in `nums`. Before adding a new index `i`, remove indices from the back whose values are less than or equal to `nums[i]`. Remove indices from the front that are out of the window `(deque.peekFirst() <= i - k)`. The maximum element for the window ending at `i` is always `nums[deque.peekFirst()]`. | Monotonic Decreasing Deque to efficiently query max in window. | Sliding Window / Deque | O(n) | O(k) | `while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) { deque.pollLast(); } deque.offerLast(i); if (deque.peekFirst() <= i - k) { deque.pollFirst(); } if (i >= k - 1) { result[i - k + 1] = nums[deque.peekFirst()]; }` |
| 40 | Linked List Cycle II | 142 | https://leetcode.com/problems/linked-list-cycle-ii/ | Floyd's Cycle-Finding Algorithm (Tortoise and Hare). Use two pointers, `slow` moving one step and `fast` moving two steps. If they meet, there's a cycle. To find the start of the cycle, reset `slow` to the head of the list. Then move both `slow` and `fast` (which is at the meeting point) one step at a time. They will meet again at the start of the cycle. | Floyd's algorithm: detect cycle, then find start node by moving one pointer from head and another from meeting point at same speed. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { // Cycle detected slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; // Cycle start } } return null;` |
| 42 | Reverse Nodes in k-Group | 25 | https://leetcode.com/problems/reverse-nodes-in-k-group/ | Recursive or Iterative. Iterative: Use a `dummy` head. Find the start (`groupPrev`) and end (`kth`) of a group of k nodes. If `kth` is null, break. Reverse the sublist from `groupPrev.next` to `kth` (using standard list reversal). Connect the previous part (`groupPrev`) to the new head of the reversed group, and connect the tail of the reversed group to the node after `kth`. Update `groupPrev` to the tail of the reversed group. | Reverse sublists of size k and reconnect them carefully. | Linked List | O(n) | O(1) iterative / O(n/k) recursive | `// Inside loop, after finding groupPrev and kth Node groupStart = groupPrev.next; Node groupEnd = kth; Node nextGroupStart = kth.next; // Reverse group from groupStart to groupEnd ... // Reconnect groupPrev.next = reversedHead; groupStart.next = nextGroupStart; // groupStart is now tail groupPrev = groupStart;` |
| 43 | Binary Tree Maximum Path Sum | 124 | https://leetcode.com/problems/binary-tree-maximum-path-sum/ | Recursive DFS approach. Define a helper function `maxGain(node)` that returns the maximum path sum starting at `node` and going downwards (either left or right). Inside `maxGain`, calculate `max(0, maxGain(node.left))` and `max(0, maxGain(node.right))`. Update a global `maxSum` variable with `node.val + leftGain + rightGain`. The function returns `node.val + max(leftGain, rightGain)`. | Recursive helper returns max gain downwards; global variable tracks max path sum possibly including split at node. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int leftGain = Math.max(0, maxGain(node.left)); int rightGain = Math.max(0, maxGain(node.right)); maxSum = Math.max(maxSum, node.val + leftGain + rightGain); // Update global return node.val + Math.max(leftGain, rightGain); // Return max path downwards` |
| 44 | Longest Common Subsequence | 1143 | https://leetcode.com/problems/longest-common-subsequence/ | DP with Memoization. `memo[i][j]` stores LCS length for `text1[i...]` and `text2[j...]`. Base case: if `i` or `j` reaches end, return 0. If `memo[i][j]` computed, return it. If `text1.charAt(i) == text2.charAt(j)`, result is `1 + solve(i+1, j+1)`. Otherwise, result is `max(solve(i+1, j), solve(i, j+1))`. Store and return result. | DP state `memo[i][j]` = LCS of suffixes starting at i,j. | Dynamic Programming | O(m*n) | O(m*n) | `if (memo[i][j] != null) return memo[i][j]; if (text1.charAt(i) == text2.charAt(j)) { memo[i][j] = 1 + solve(i + 1, j + 1, text1, text2, memo); } else { memo[i][j] = Math.max(solve(i + 1, j, text1, text2, memo), solve(i, j + 1, text1, text2, memo)); } return memo[i][j];` |
| 45 | Edit Distance | 72 | https://leetcode.com/problems/edit-distance/ | DP with Memoization. `memo[i][j]` stores min distance between `word1[i...]` and `word2[j...]`. Base cases: if `i` reaches end, return `len2 - j`; if `j` reaches end, return `len1 - i`. If `memo[i][j]` computed, return. If `word1[i] == word2[j]`, result is `solve(i+1, j+1)`. Otherwise, result is `1 + min(solve(i+1, j), solve(i, j+1), solve(i+1, j+1))` (delete, insert, replace). | DP state `memo[i][j]` = edit distance for suffixes. Consider match/replace, delete, insert options. | Dynamic Programming | O(m*n) | O(m*n) | `if (word1.charAt(i) == word2.charAt(j)) { memo[i][j] = solve(i + 1, j + 1, word1, word2, memo); } else { int delete = solve(i + 1, j, word1, word2, memo); int insert = solve(i, j + 1, word1, word2, memo); int replace = solve(i + 1, j + 1, word1, word2, memo); memo[i][j] = 1 + Math.min(delete, Math.min(insert, replace)); }` |
| 46 | Word Break | 139 | https://leetcode.com/problems/word-break/ | DP with Memoization. `memo[i]` stores whether `s[i...]` can be segmented. `memo` can be Boolean or Integer (0=uncomputed, 1=true, -1=false). Base case: if `i == s.length()`, return true. If `memo[i]` computed, return result. Iterate `j` from `i` to `s.length()-1`. If `s.substring(i, j+1)` is in `wordDict` and `solve(j+1)` returns true, set `memo[i] = true` and return true. If loop finishes, set `memo[i] = false`. | DP state `memo[i]` = can `s[i...]` be broken? Try all prefixes starting at `i`. | Dynamic Programming | O(n*m*k) n=s len, m=dict size, k=word len. Optimised O(n^2*k) or O(n^3) | O(n) | `if (memo[start] != null) return memo[start]; for (int end = start; end < s.length(); end++) { String word = s.substring(start, end + 1); if (wordDict.contains(word) && solve(end + 1, s, wordDict, memo)) { memo[start] = true; return true; } } memo[start] = false;` |
| 47 | Burst Balloons | 312 | https://leetcode.com/problems/burst-balloons/ | DP with Memoization. `memo[left][right]` stores max coins for bursting balloons *between* index `left` and `right` (exclusive). Add 1s at boundaries of `nums`. Iterate `k` from `left+1` to `right-1` representing the *last* balloon to burst in `(left, right)`. Cost is `nums[left]*nums[k]*nums[right] + solve(left, k) + solve(k, right)`. Maximize over `k`. | DP state `memo[l][r]` = max coins in `(l,r)`. Key is iterating the *last* balloon burst in the interval. | Dynamic Programming | O(n^3) | O(n^2) | `if (memo[left][right] > 0) return memo[left][right]; int maxCoins = 0; for (int k = left + 1; k < right; k++) { int coins = nums[left] * nums[k] * nums[right]; coins += solve(left, k, nums, memo) + solve(k, right, nums, memo); maxCoins = Math.max(maxCoins, coins); } memo[left][right] = maxCoins;` |
| 48 | Find First and Last Position of Element in Sorted Array | 34 | https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ | Binary Search twice. One search finds the leftmost index (`low`): if `nums[mid] == target`, potentially keep searching left (`high = mid - 1`), store `mid` as potential answer. Another search finds the rightmost index (`high`): if `nums[mid] == target`, potentially keep searching right (`low = mid + 1`), store `mid`. | Two modified binary searches: one biased left, one biased right. | Binary Search | O(log n) | O(1) | `// Find Leftmost int findBound(int[] nums, int target, boolean isFirst) { // ... inside BS loop if (nums[mid] == target) { index = mid; if (isFirst) high = mid - 1; else low = mid + 1; } //... } left = findBound(nums, target, true); right = findBound(nums, target, false);` |
| 49 | Course Schedule II | 210 | https://leetcode.com/problems/course-schedule-ii/ | Topological Sort (Kahn's or DFS). Kahn's: Same as Course Schedule I, but add dequeued nodes to a result list/array. If final count != numCourses, return empty array. DFS: Use 3 states (visiting, visited). Perform DFS. Add node to result list *after* visiting all neighbors (post-order). Reverse the result list. Detect cycles using 'visiting' state. | Topological sort storing the order. Return empty array if cycle detected. | Graph / Topological Sort | O(V+E) | O(V+E) | `// Kahn's: Add to result list after dequeuing // DFS: Add node to head of list/stack in post-order visit. Detect cycle with VISITING state. List<Integer> result = new ArrayList<>(); // Kahn's // ... add to queue, process ... result.add(course); // Add node after processing it // ... return result.stream().mapToInt(i->i).toArray(); // if count == numCourses` |
| 50 | Implement Trie (Prefix Tree) | 208 | https://leetcode.com/problems/implement-trie-prefix-tree/ | Create a `TrieNode` class containing `children` (e.g., `TrieNode[26]` or `Map<Character, TrieNode>`) and an `isEndOfWord` boolean flag. `insert`: Traverse from root, creating nodes if they don't exist. Mark `isEndOfWord` at the end. `search`: Traverse from root. If path exists and ends with `isEndOfWord`, return true. `startsWith`: Traverse from root. If path exists, return true. | Node-based structure where each node represents a character and path represents prefix/word. | Trie / Design | O(L) for ops, L=word length | O(N*L) total nodes/chars | `class TrieNode { TrieNode[] children = new TrieNode[26]; boolean isEndOfWord; } // Insert: TrieNode curr = root; for (char c : word.toCharArray()) { if (curr.children[c - 'a'] == null) curr.children[c - 'a'] = new TrieNode(); curr = curr.children[c - 'a']; } curr.isEndOfWord = true;` |
| 51 | Rotate Array | 189 | https://leetcode.com/problems/rotate-array/ | Reversal Algorithm: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining `n-k` elements. (Make sure `k = k % n`). This is O(n) time and O(1) space. | Three reversals achieve rotation in-place. | Array Manipulation | O(n) | O(1) | `k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);` |
| 52 | Sort Colors | 75 | https://leetcode.com/problems/sort-colors/ | Dutch National Flag algorithm (3-way partitioning). Use three pointers: `low=0`, `mid=0`, `high=n-1`. While `mid <= high`: If `nums[mid] == 0`, swap `nums[low]` and `nums[mid]`, increment both `low` and `mid`. If `nums[mid] == 1`, increment `mid`. If `nums[mid] == 2`, swap `nums[mid]` and `nums[high]`, decrement `high` (do not increment `mid` as swapped element needs checking). | Dutch National Flag (DNF) algorithm for 3-way partition. | Array / Two Pointers / Sorting | O(n) | O(1) | `while (mid <= high) { if (nums[mid] == 0) { swap(nums, low++, mid++); } else if (nums[mid] == 1) { mid++; } else { swap(nums, mid, high--); } }` |
| 53 | Find All Anagrams in a String | 438 | https://leetcode.com/problems/find-all-anagrams-in-a-string/ | Sliding Window with Character Counts. Maintain two frequency maps (arrays `int[26]`), one for pattern `p` (`pCount`) and one for the current window in `s` (`sCount`). Initialize window of size `p.length()`. Compare `sCount` and `pCount`. Slide the window one step at a time: decrement count for char leaving window, increment count for char entering window. Compare counts at each step. | Sliding window with frequency map comparison. | Sliding Window / Hash Map | O(\|S\|) | O(1) (alphabet size 26) | `int[] pCount = new int[26]; int[] sCount = new int[26]; // Fill pCount, initial sCount for (int i = pLen; i < sLen; i++) { if (Arrays.equals(sCount, pCount)) result.add(i - pLen); sCount[s.charAt(i - pLen) - 'a']--; sCount[s.charAt(i) - 'a']++; } // Final check for last window` |
| 54 | Two Sum II - Input Array Is Sorted | 167 | https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ | Use two pointers, `left` starting at index 0 and `right` starting at index `n-1`. Calculate `sum = numbers[left] + numbers[right]`. If `sum == target`, return `[left + 1, right + 1]`. If `sum < target`, increment `left` to increase the sum. If `sum > target`, decrement `right` to decrease the sum. | Two pointers moving inwards on a sorted array. | Two Pointers | O(n) | O(1) | `while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } else if (sum < target) { left++; } else { right--; } }` |
| 55 | Reorder List | 143 | https://leetcode.com/problems/reorder-list/ | 1. Find the middle node using slow/fast pointers. 2. Reverse the second half of the list starting from `middle.next`. Set `middle.next = null` to split lists. 3. Merge the first half and the reversed second half: Interleave nodes one by one from each half. | Find Mid -> Reverse 2nd Half -> Merge Alternately. | Linked List / Two Pointers | O(n) | O(1) | `// 1. Find Middle ListNode slow = head, fast = head; //... // 2. Reverse Second Half ListNode secondHead = reverse(slow.next); slow.next = null; // Split // 3. Merge ListNode first = head; while (secondHead != null) { ListNode temp1 = first.next; ListNode temp2 = secondHead.next; first.next = secondHead; secondHead.next = temp1; first = temp1; secondHead = temp2; }` |
| 56 | Sort List | 148 | https://leetcode.com/problems/sort-list/ | Use Merge Sort. Base case: if list is empty or has one node, return it. Find the middle of the list using slow/fast pointers. Split the list into two halves. Recursively sort the left half (`sortList(head)`) and the right half (`sortList(middle)`). Merge the two sorted halves using a standard merge function (like merge two sorted lists). | Merge Sort adapted for Linked Lists. | Linked List / Sorting / Recursion / Merge Sort | O(n log n) | O(log n) recursion stack | `// Find middle ListNode mid = getMid(head); // Split ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); // Merge return merge(left, right);` |
| 57 | Diameter of Binary Tree | 543 | https://leetcode.com/problems/diameter-of-binary-tree/ | Use DFS. Define a helper function `height(node)` that returns the height of the subtree rooted at `node`. Inside this function, recursively calculate `leftHeight = height(node.left)` and `rightHeight = height(node.right)`. The diameter *passing through* `node` is `leftHeight + rightHeight`. Update a global/instance variable `maxDiameter = max(maxDiameter, leftHeight + rightHeight)`. The function `height(node)` returns `1 + max(leftHeight, rightHeight)`. | DFS calculating height; diameter is max(leftHeight + rightHeight) across all nodes. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int maxDiameter = 0; int height(TreeNode node) { if (node == null) return 0; int leftH = height(node.left); int rightH = height(node.right); maxDiameter = Math.max(maxDiameter, leftH + rightH); return 1 + Math.max(leftH, rightH); }` |
| 58 | Kth Smallest Element in a BST | 230 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/ | Inorder Traversal (Recursive or Iterative). Perform an inorder traversal (Left, Root, Right) which visits nodes in ascending order for a BST. Maintain a counter. When the counter reaches `k`, the current node's value is the answer. Iterative using a stack is common. | Inorder traversal visits BST nodes in sorted order. | Tree / BST / Inorder Traversal | O(H + k) avg, O(N) worst | O(H) avg, O(N) worst (stack) | `Stack<TreeNode> stack = new Stack<>(); while (true) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (--k == 0) return root.val; root = root.right; }` |
| 59 | Partition Equal Subset Sum | 416 | https://leetcode.com/problems/partition-equal-subset-sum/ | DP (Memoization). Calculate total sum. If odd, return false. Target sum is `totalSum / 2`. Define `memo[i][s]` = can subset sum `s` be formed using elements up to index `i`. Base cases: `s=0` is true. `i<0` or `s<0` is false. Recurrence: `solve(i-1, s)` (exclude `nums[i]`) OR `solve(i-1, s - nums[i])` (include `nums[i]`). | Reduce to Subset Sum problem with target = totalSum / 2. | Dynamic Programming | O(n * sum) | O(n * sum) | `Boolean[][] memo; boolean solve(int[] nums, int i, int target) { if (target == 0) return true; if (i < 0 || target < 0) return false; if (memo[i][target] != null) return memo[i][target]; boolean include = solve(nums, i - 1, target - nums[i]); boolean exclude = solve(nums, i - 1, target); memo[i][target] = include || exclude; return memo[i][target]; }` |
| 60 | Longest Palindromic Subsequence | 516 | https://leetcode.com/problems/longest-palindromic-subsequence/ | DP with Memoization. `memo[i][j]` stores the length of the LPS for the substring `s[i..j]`. Base case: `memo[i][i] = 1`. If `s.charAt(i) == s.charAt(j)`, then `memo[i][j] = 2 + solve(i+1, j-1)`. If not equal, `memo[i][j] = max(solve(i+1, j), solve(i, j-1))`. | DP state `memo[i][j]` = LPS length in `s[i..j]`. Match ends or take max of subproblems. | Dynamic Programming | O(n^2) | O(n^2) | `Integer[][] memo; int solve(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != null) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) { memo[i][j] = 2 + solve(s, i + 1, j - 1); } else { memo[i][j] = Math.max(solve(s, i + 1, j), solve(s, i, j - 1)); } return memo[i][j]; }` |
| 61 | Palindrome Partitioning | 131 | https://leetcode.com/problems/palindrome-partitioning/ | Backtracking/DFS. Define `backtrack(start, currentList)`. Iterate `end` from `start` to `n-1`. Check if `s.substring(start, end + 1)` is a palindrome. If yes, add it to `currentList`, recurse `backtrack(end + 1, currentList)`, then remove the substring (backtrack). Base case: `start == n`, add `currentList` to results. | Backtracking exploring all partitions, checking palindrome property for each part. | Backtracking / Recursion | O(N * 2^N) | O(N) recursion depth | `for (int end = start; end < s.length(); end++) { if (isPalindrome(s, start, end)) { currentList.add(s.substring(start, end + 1)); backtrack(end + 1, currentList, s, result); currentList.remove(currentList.size() - 1); // Backtrack } }` |
| 62 | Decode Ways | 91 | https://leetcode.com/problems/decode-ways/ | DP with Memoization. `memo[i]` stores ways to decode `s[i...]`. Base case: `memo[n] = 1`. If `s[i] == '0'`, `memo[i] = 0`. One-digit decode: `ways = solve(i+1)`. Two-digit decode: If `i+1 < n` and `s[i..i+1]` is '10'-'26', `ways += solve(i+2)`. Store result in `memo[i]`. | DP state `memo[i]` = ways to decode suffix `s[i...]`. Handle '0' and 1/2 digit checks. | Dynamic Programming | O(n) | O(n) | `if (memo[i] != null) return memo[i]; if (s.charAt(i) == '0') return 0; int ways = solve(i + 1, s, memo); if (i + 1 < s.length()) { int twoDigit = Integer.parseInt(s.substring(i, i + 2)); if (twoDigit >= 10 && twoDigit <= 26) { ways += solve(i + 2, s, memo); } } memo[i] = ways;` |
| 63 | Longest Increasing Path in a Matrix | 329 | https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ | DP (Memoization) + DFS. `memo[r][c]` stores LIP length starting at `(r, c)`. Initialize memo with 0. Iterate through all cells, call DFS if `memo[r][c] == 0`. DFS(r, c): If `memo[r][c] > 0` return it. Calculate `maxPath = 1`. Explore 4 neighbors `(nr, nc)`. If valid and `matrix[nr][nc] > matrix[r][c]`, `maxPath = max(maxPath, 1 + dfs(nr, nc))`. Store `memo[r][c] = maxPath`. | DFS with memoization to avoid recomputing LIP from same cell. | DFS / Dynamic Programming | O(m*n) | O(m*n) | `if (memo[r][c] > 0) return memo[r][c]; int maxLen = 1; for (int[] dir : directions) { int nr = r + dir[0], nc = c + dir[1]; if (/* valid neighbor */ && matrix[nr][nc] > matrix[r][c]) { maxLen = Math.max(maxLen, 1 + dfs(matrix, nr, nc, memo)); } } memo[r][c] = maxLen;` |
| 64 | Pacific Atlantic Water Flow | 417 | https://leetcode.com/problems/pacific-atlantic-water-flow/ | DFS/BFS from both oceans. Create two boolean matrices `pacific` and `atlantic`. Start DFS/BFS from all border cells adjacent to Pacific, mark reachable cells in `pacific`. Do the same for Atlantic border cells and `atlantic` matrix. Iterate through the grid, if `pacific[r][c]` and `atlantic[r][c]` are both true, add `(r, c)` to result. | Start search from ocean boundaries inwards. | DFS / BFS | O(m*n) | O(m*n) | `// dfs(matrix, r, c, visited, prevHeight) for (int i = 0; i < rows; i++) { dfs(matrix, i, 0, pacific, Integer.MIN_VALUE); // Pacific border dfs(matrix, i, cols - 1, atlantic, Integer.MIN_VALUE); // Atlantic border } // ... same for top/bottom borders ... List<List<Integer>> result = new ArrayList<>(); for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) if (pacific[r][c] && atlantic[r][c]) result.add(Arrays.asList(r,c));` |
| 65 | Reconstruct Itinerary | 332 | https://leetcode.com/problems/reconstruct-itinerary/ | Hierholzer's algorithm variation using DFS. Build graph where `adj<String, PriorityQueue<String>>` stores destinations lexicographically. Start DFS from "JFK". In `dfs(airport)`: While neighbors exist, `dfs(neighbor)`. Add `airport` to the front of the result list *after* visiting all neighbors (post-order traversal). | Post-order DFS traversal on graph with sorted adjacency lists (MinHeap). | DFS / Graph / Eulerian Path | O(E log E) or O(E) if radix sort | O(V+E) | `Map<String, PriorityQueue<String>> adj; LinkedList<String> result; void dfs(String airport) { PriorityQueue<String> neighbors = adj.get(airport); while (neighbors != null && !neighbors.isEmpty()) { dfs(neighbors.poll()); } result.addFirst(airport); // Add post-visit }` |
| 66 | Design Twitter | 355 | https://leetcode.com/problems/design-twitter/ | Use HashMaps: `userMap<userId, UserObject>`. `UserObject` contains `Set<Integer> following` and `List<Tweet> tweets`. `Tweet` class has `id`, `timestamp`. `postTweet`: Add tweet to user's tweet list (keep it sorted/limited). `getNewsFeed`: Get user's tweets + tweets from all followees. Use a Max-Heap (PriorityQueue) ordered by timestamp to merge these tweet lists and get the top 10 recent. | HashMaps for users/following, Lists/Heaps for tweets. | Design / Hash Map / Heap | O(F*T*logK) feed, O(1) follow/post (F=following, T=tweets/user, K=10) | O(Users + Tweets + Follows) | `class User { Set<Integer> following = new HashSet<>(); LinkedList<Tweet> tweets = new LinkedList<>(); } Map<Integer, User> userMap; // getNewsFeed PriorityQueue<Tweet> maxHeap = new PriorityQueue<>((a,b)->b.timestamp-a.timestamp); // Add self tweets + followee tweets to heap... poll top 10` |
| 67 | Word Search II | 212 | https://leetcode.com/problems/word-search-ii/ | Build a Trie from the `words`. Perform DFS on the `board` starting from each cell. In the DFS function `dfs(r, c, currentNode)`, check bounds, visited status. Get char `board[r][c]`. If `currentNode` doesn't have child for char, return. Move to child node. If `childNode.word != null`, add it to result and set `childNode.word = null` (avoid duplicates). Mark cell visited, explore 4 neighbors, unmark cell. | Trie stores dictionary words for efficient prefix checking during board DFS. | Trie / DFS / Backtracking | O(M*N*4*3^(L-1)) M,N=dims, L=max word len. Dominated by Trie build + DFS. | O(Total Chars in words) for Trie | `void dfs(char[][] board, int r, int c, TrieNode node, List<String> result) { //... base cases ... char ch = board[r][c]; TrieNode child = node.children[ch - 'a']; if (child == null) return; if (child.word != null) { result.add(child.word); child.word = null; // Avoid duplicates } board[r][c] = '#'; // Mark visited // dfs neighbors... board[r][c] = ch; // Unmark }` |
| 68 | Design Add and Search Words Data Structure | 211 | https://leetcode.com/problems/design-add-and-search-words-data-structure/ | Use a Trie structure (`TrieNode` with children and `isEndOfWord`). `addWord` is standard Trie insertion. `search(word)` needs modification: If char is '.', recursively call `search` on all non-null children of the current node and return true if any succeed. If char is a letter, follow the specific child branch. If path doesn't exist, return false. | Trie with modified search to handle '.' wildcard by exploring all children. | Trie / Design / DFS | O(L) add, O(N*26^L) search worst-case (.), N=nodes, L=len | O(Total Chars) for Trie | `boolean searchHelper(String word, int k, TrieNode node) { if (k == word.length()) return node.isEndOfWord; char ch = word.charAt(k); if (ch == '.') { for (TrieNode child : node.children) { if (child != null && searchHelper(word, k + 1, child)) return true; } return false; } else { // Standard Trie traversal } }` |
| 69 | Longest Valid Parentheses | 32 | https://leetcode.com/problems/longest-valid-parentheses/ | Stack approach: Push indices of '(' onto stack. When ')' is encountered: if stack not empty, pop index `start`. Length is `current_index - start + 1`. Update `maxLength`. Alternative DP: `dp[i]` = length of LVP *ending* at `i`. If `s[i] == ')'`: if `s[i-1] == '('`, `dp[i] = dp[i-2] + 2`. If `s[i-1] == ')'` and matching '(' exists at `i - dp[i-1] - 1`, `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`. | Stack stores indices to calculate length upon finding matching ')', or DP relation. | Stack / Dynamic Programming | O(n) | O(n) stack/DP array | `// Stack approach Stack<Integer> stack = new Stack<>(); stack.push(-1); // Base for length calculation for (int i=0; i<s.length(); ++i) { if (s.charAt(i) == '(') stack.push(i); else { stack.pop(); if (stack.isEmpty()) stack.push(i); // New base else maxLen = Math.max(maxLen, i - stack.peek()); } }` |
| 70 | Remove Invalid Parentheses | 301 | https://leetcode.com/problems/remove-invalid-parentheses/ | BFS Approach: Start BFS with the initial string. Use a queue and a set `visited` to avoid cycles. At each level, process strings from the queue. If a string is valid, add it to the result list. If result is found, stop exploring deeper levels (since we want minimum removals). Generate next level strings by removing one '(' or ')' from each current string and adding to queue if not visited. | Level-order BFS guarantees finding shortest paths (minimum removals) first. | BFS / String Manipulation | O(N * 2^N) worst case | O(N * 2^N) visited set | `Queue<String> queue; Set<String> visited; List<String> result; boolean found = false; while (!queue.isEmpty()) { String curr = queue.poll(); if (isValid(curr)) { result.add(curr); found = true; } if (found) continue; // Found min removals level for (int i = 0; i < curr.length(); i++) { // Generate next strings by removing one char... if (!visited.contains(nextStr)) { queue.offer(nextStr); visited.add(nextStr); } } }` |
| 71 | Combination Sum II | 40 | https://leetcode.com/problems/combination-sum-ii/ | Backtracking with sorting to handle duplicates. Sort `candidates`. Define `backtrack(startIndex, currentSum, currentList)`. Base cases: `currentSum == target` (add copy of `currentList`), `currentSum > target` (return). Loop `i` from `startIndex` to `n-1`. **Crucial**: If `i > startIndex && candidates[i] == candidates[i-1]`, continue (skip duplicate combination). Add `candidates[i]` to list, recurse `backtrack(i + 1, ...)`, backtrack (remove). | Sort + skip duplicates in backtracking loop (`i > startIndex`). Use `i+1` in recursion. | Backtracking / Recursion | O(2^N) | O(N) recursion depth | `Arrays.sort(candidates); // ... backtrack function ... for (int i = start; i < candidates.length; i++) { if (i > start && candidates[i] == candidates[i - 1]) continue; // Skip duplicates if (candidates[i] > remaining) break; // Pruning tempList.add(candidates[i]); backtrack(result, tempList, candidates, remaining - candidates[i], i + 1); // Use i+1 tempList.remove(tempList.size() - 1); }` |
| 72 | Move Zeroes | 283 | https://leetcode.com/problems/move-zeroes/ | Two Pointers (Slow/Fast or Read/Write). Initialize `writePointer = 0`. Iterate through array with `readPointer` from 0 to `n-1`. If `nums[readPointer]` is not zero, set `nums[writePointer] = nums[readPointer]` and increment `writePointer`. After loop, fill remaining positions from `writePointer` to `n-1` with zeros. | In-place modification using a write pointer for non-zero elements. | Array / Two Pointers | O(n) | O(1) | `int insertPos = 0; for (int num : nums) { if (num != 0) { nums[insertPos++] = num; } } while (insertPos < nums.length) { nums[insertPos++] = 0; }` |
| 73 | Minimum Size Subarray Sum | 209 | https://leetcode.com/problems/minimum-size-subarray-sum/ | Sliding Window. Initialize `start = 0`, `currentSum = 0`, `minLength = Integer.MAX_VALUE`. Iterate `end` from 0 to `n-1`. Add `nums[end]` to `currentSum`. While `currentSum >= target`: update `minLength = Math.min(minLength, end - start + 1)`, subtract `nums[start]` from `currentSum`, and increment `start`. Return `minLength` or 0 if not found. | Sliding window expands right, shrinks left when sum condition met. | Sliding Window / Two Pointers | O(n) | O(1) | `while (end < nums.length) { currentSum += nums[end]; while (currentSum >= target) { minLength = Math.min(minLength, end - start + 1); currentSum -= nums[start]; start++; } end++; }` |
| 74 | 3Sum Closest | 16 | https://leetcode.com/problems/3sum-closest/ | Sort array. Initialize `closestSum`. Iterate `i` from 0 to `n-3`. Use two pointers `left = i + 1`, `right = n - 1`. Calculate `currentSum = nums[i] + nums[left] + nums[right]`. If `abs(currentSum - target) < abs(closestSum - target)`, update `closestSum = currentSum`. If `currentSum == target`, return target. If `currentSum < target`, `left++`. Else `right--`. Skip duplicates for `i` not strictly needed but good practice. | Sort + Two Pointers, track sum closest to target. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) sort | `Arrays.sort(nums); int closestSum = nums[0] + nums[1] + nums[2]; // Initial guess for (int i = 0; i < nums.length - 2; i++) { int left = i + 1, right = nums.length - 1; while (left < right) { int currentSum = nums[i] + nums[left] + nums[right]; if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) { closestSum = currentSum; } if (currentSum < target) left++; else if (currentSum > target) right--; else return target; // Exact match } }` |
| 75 | 4Sum | 18 | https://leetcode.com/problems/4sum/ | Sort array. Use nested loops: outer loop `i`, inner loop `j`. Skip duplicates for `i` and `j`. Inside `j` loop, use two pointers `left = j + 1`, `right = n - 1` to find pairs summing to `target - nums[i] - nums[j]`. Calculate `currentSum`. If equal to target, add quadruplet, increment `left`, decrement `right`, skip duplicates for `left` and `right`. If `sum < target`, `left++`. If `sum > target`, `right--`. | Sort + Nested Loops + Two Pointers. Handle duplicates at all levels. | Two Pointers / Sorting | O(n^3) | O(log n) or O(n) sort | `// Outer loops for i, j (with duplicate checks) // Inner two pointers int twoSumTarget = target - nums[i] - nums[j]; int left = j + 1, right = n - 1; while (left < right) { int sum = nums[left] + nums[right]; if (sum == twoSumTarget) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // Skip duplicates for left & right left++; right--; } else if (sum < twoSumTarget) left++; else right--; }` |
| 76 | Palindrome Linked List | 234 | https://leetcode.com/problems/palindrome-linked-list/ | Find middle node using slow/fast pointers. Reverse the second half of the list starting from `middle.next`. Compare the first half (from `head`) with the reversed second half node by node. Restore list afterwards if needed (reverse second half again). | Find Mid -> Reverse 2nd Half -> Compare 1st and Reversed 2nd. | Linked List / Two Pointers | O(n) | O(1) | `ListNode mid = findMiddle(head); ListNode secondHead = reverse(mid.next); // mid.next = null if needed boolean isPalindrome = true; while (secondHead != null) { if (head.val != secondHead.val) { isPalindrome = false; break; } head = head.next; secondHead = secondHead.next; }` |
| 77 | Intersection of Two Linked Lists | 160 | https://leetcode.com/problems/intersection-of-two-linked-lists/ | Two Pointers approach: Initialize `pA = headA`, `pB = headB`. Traverse both. If `pA` reaches end, redirect it to `headB`. If `pB` reaches end, redirect it to `headA`. They will meet at the intersection node (or null if no intersection) after at most two passes through combined lists. | Pointers traverse both lists; switching heads aligns them for meeting at intersection. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode pA = headA, pB = headB; while (pA != pB) { pA = (pA == null) ? headB : pA.next; pB = (pB == null) ? headA : pB.next; } return pA; // Returns intersection node or null` |
| 78 | Invert Binary Tree | 226 | https://leetcode.com/problems/invert-binary-tree/ | Recursive DFS: Base case: if `node == null`, return null. Swap `node.left` and `node.right`. Recursively call `invertTree(node.left)` and `invertTree(node.right)`. Return `node`. Iterative BFS also works. | Recursively swap left and right children. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `if (root == null) return null; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root;` |
| 79 | Binary Tree Right Side View | 199 | https://leetcode.com/problems/binary-tree-right-side-view/ | BFS (Level Order Traversal). Use a queue. In each level, iterate through all nodes currently in the queue (`levelSize`). Keep track of the value of the *last* node processed at each level. Add this last node's value to the result list. | Level order traversal, adding the last node encountered at each level. | Tree / BFS | O(n) | O(w) max width | `Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (i == levelSize - 1) { result.add(node.val); // Add last element } if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } }` |
| 80 | Subtree of Another Tree | 572 | https://leetcode.com/problems/subtree-of-another-tree/ | Recursive approach. Define `isSubtree(root, subRoot)`. Base case: `subRoot` is null -> true. `root` is null -> false. Check if `root` and `subRoot` form the same tree using `isSameTree(root, subRoot)`. If yes, return true. Otherwise, return `isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)`. `isSameTree` checks equality recursively. | Check if same tree at current node OR if subtree exists in left OR right child. | Tree / Recursion / DFS | O(m*n) worst case, O(m+n) avg | O(h) recursion depth | `boolean isSameTree(TreeNode p, TreeNode q) { // Standard same tree check } boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); }` |
| 81 | Balanced Binary Tree | 110 | https://leetcode.com/problems/balanced-binary-tree/ | Recursive DFS. Helper function `checkHeight(node)` returns height if balanced, -1 otherwise. Base case: null node returns 0. Get left/right heights recursively. If either is -1 or `abs(leftH - rightH) > 1`, return -1. Else, return `1 + max(leftH, rightH)`. Main function checks if `checkHeight(root) != -1`. | Combine height calculation and balance check in one recursive pass. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int checkHeight(TreeNode node) { if (node == null) return 0; int leftH = checkHeight(node.left); if (leftH == -1) return -1; int rightH = checkHeight(node.right); if (rightH == -1) return -1; if (Math.abs(leftH - rightH) > 1) return -1; return 1 + Math.max(leftH, rightH); }` |
| 82 | Symmetric Tree | 101 | https://leetcode.com/problems/symmetric-tree/ | Recursive helper `isMirror(node1, node2)`. Checks if two trees are mirror images. Base cases: Both null -> true; one null -> false. Return `(node1.val == node2.val) && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left)`. Initial call: `isMirror(root.left, root.right)`. | Recursive comparison of left subtree with mirror image of right subtree. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `boolean isMirror(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }` |
| 83 | Populating Next Right Pointers in Each Node | 116 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ | Level Order Traversal (BFS) or Optimized Iterative/Recursive using existing `next`. BFS: Standard level order, connect `prev.next = current` within each level. Optimized Iterative (O(1) space): Use two pointers `levelStart` and `curr`. Iterate `levelStart` down levels. Inner loop uses `curr` to traverse current level using `next` pointers, setting `curr.left.next = curr.right` and `curr.right.next = curr.next != null ? curr.next.left : null`. | Use BFS or leverage perfect tree structure for O(1) space iteration using `next` pointers. | Tree / BFS / DFS | O(n) | O(w) BFS / O(1) optimized | `// Optimized Iterative (O(1) space) Node levelStart = root; while (levelStart != null && levelStart.left != null) { Node curr = levelStart; while (curr != null) { curr.left.next = curr.right; if (curr.next != null) curr.right.next = curr.next.left; curr = curr.next; } levelStart = levelStart.left; }` |
| 84 | Minimum Path Sum | 64 | https://leetcode.com/problems/minimum-path-sum/ | DP (Tabulation in-place). `grid[r][c]` stores min path sum to reach `(r, c)`. Initialize first row and first column based on previous cell. For other cells `(r, c)`, `grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])`. Result is `grid[m-1][n-1]`. | DP state `dp[r][c]` = min sum to reach cell `(r,c)`. In-place update. | Dynamic Programming | O(m*n) | O(1) (in-place) / O(m*n) memo | `for (int r = 0; r < m; r++) { for (int c = 0; c < n; c++) { if (r == 0 && c == 0) continue; else if (r == 0) grid[r][c] += grid[r][c-1]; else if (c == 0) grid[r][c] += grid[r-1][c]; else grid[r][c] += Math.min(grid[r-1][c], grid[r][c-1]); } }` |
| 85 | Coin Change II | 518 | https://leetcode.com/problems/coin-change-ii/ | DP (Unbounded Knapsack). `dp[i]` = number of ways to make amount `i`. Initialize `dp[0] = 1`. Iterate through each `coin` in `coins`. For each `coin`, iterate through amounts `j` from `coin` up to `amount`. Update `dp[j] = dp[j] + dp[j - coin]`. Result is `dp[amount]`. | DP state `dp[i]` = number of combinations for amount `i`. Outer loop coins, inner loop amounts. | Dynamic Programming | O(amount * coins) | O(amount) | `int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } }` |
| 86 | House Robber II | 213 | https://leetcode.com/problems/house-robber-ii/ | Reduce to two House Robber I problems. Because first and last houses cannot be robbed together, calculate max profit for `nums[0...n-2]` (excluding last) and max profit for `nums[1...n-1]` (excluding first). Return the maximum of these two results. Use standard House Robber I DP logic for subproblems. | Solve two subproblems excluding first/last house respectively. | Dynamic Programming | O(n) | O(1) (using optimized HR I) | `if (nums.length == 1) return nums[0]; int max1 = robHelper(nums, 0, nums.length - 2); int max2 = robHelper(nums, 1, nums.length - 1); return Math.max(max1, max2); // robHelper implements House Robber I DP` |
| 87 | Unique Paths II | 63 | https://leetcode.com/problems/unique-paths-ii/ | DP (Tabulation in-place or separate DP array). `dp[r][c]` = number of paths to `(r, c)`. If `obstacleGrid[r][c] == 1`, `dp[r][c] = 0`. Else, `dp[r][c] = dp[r-1][c] + dp[r][c-1]`. Handle first row/col initialization carefully considering obstacles. Start `dp[0][0] = 1` if no obstacle. | DP state `dp[r][c]` = unique paths to `(r,c)`. Set paths to 0 if obstacle. | Dynamic Programming | O(m*n) | O(m*n) or O(n) space | `dp[r][c] = 0; // If obstacleGrid[r][c] == 1 else if (r==0 && c==0) dp[r][c] = 1; else if (r==0) dp[r][c] = dp[r][c-1]; else if (c==0) dp[r][c] = dp[r-1][c]; else dp[r][c] = dp[r-1][c] + dp[r][c-1];` |
| 88 | Search a 2D Matrix | 74 | https://leetcode.com/problems/search-a-2d-matrix/ | Treat matrix as a sorted 1D array of size `m*n`. Perform standard binary search. Map 1D index `mid` back to 2D coordinates: `row = mid / cols`, `col = mid % cols`. Compare `matrix[row][col]` with target. | Binary search on flattened matrix indices. | Binary Search | O(log(m*n)) | O(1) | `int low = 0, high = rows * cols - 1; while (low <= high) { int mid = low + (high - low) / 2; int row = mid / cols; int col = mid % cols; if (matrix[row][col] == target) return true; else if (matrix[row][col] < target) low = mid + 1; else high = mid - 1; }` |
| 89 | Kth Smallest Element in a Sorted Matrix | 378 | https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ | Binary Search on value range `[matrix[0][0], matrix[m-1][n-1]]`. For a `mid` value, count elements `<= mid` using a staircase search (start top-right or bottom-left, O(m+n)). If `count < k`, search upper half (`low = mid + 1`). If `count >= k`, search lower half (`high = mid`), storing potential answer. | Binary search on answer range, count elements efficiently. | Binary Search / Matrix | O((m+n) * log(max-min)) | O(1) | `int countLE(int[][] matrix, int x) { // Staircase search O(m+n) } int low = matrix[0][0], high = matrix[rows-1][cols-1]; int ans = low; while (low <= high) { int mid = low + (high - low) / 2; if (countLE(matrix, mid) >= k) { ans = mid; high = mid - 1; } else { low = mid + 1; } }` |
| 90 | Rotting Oranges | 994 | https://leetcode.com/problems/rotting-oranges/ | Multi-source BFS. Initialize queue with all initial rotten oranges (2s). Keep track of `freshOranges` count. Perform BFS level by level. Each level signifies one minute. Dequeue rotten orange, explore 4 neighbors. If fresh neighbor (1) found, make it rotten (2), decrement `freshOranges`, enqueue neighbor. After BFS, return minutes elapsed if `freshOranges == 0`, else -1. | Multi-source BFS tracking levels (minutes) and remaining fresh count. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `// Initial pass: count fresh, add rotten to queue Queue<int[]> queue; int minutes = 0; while (!queue.isEmpty() && freshCount > 0) { int size = queue.size(); minutes++; for (int i=0; i<size; ++i) { // Dequeue, explore neighbors, rot fresh ones, decrement freshCount, enqueue new rotten } } return freshCount == 0 ? minutes : -1;` |


