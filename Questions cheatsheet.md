https://leetcode.com/problems/zigzag-conversion/




| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 1 | Two Sum | 1 | https://leetcode.com/problems/two-sum/ | Use a HashMap to store encountered numbers and their indices. For each element nums[i], check if target - nums[i] (the complement) exists in the map. If yes, return indices. If no, add nums[i] and its index to the map. | HashMap for O(1) complement lookup. | Hash Map | O(n) | O(n) | `if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i);` |
| 2 | Longest Substring Without Repeating Characters | 3 | https://leetcode.com/problems/longest-substring-without-repeating-characters/ | Use a sliding window approach with two pointers (start, end) and a Set/Map to track characters within the window [start, end). Expand end. If s.charAt(end) is in the set, shrink the window by incrementing start and removing s.charAt(start) from the set until the duplicate is removed. Update max length. | Sliding window with Set/Map for efficient duplicate checks. | Sliding Window | O(n) | O(min(n, m)) (where m is alphabet size) | `if (set.contains(s.charAt(end))) { set.remove(s.charAt(start++)); } else { set.add(s.charAt(end++)); maxLen = Math.max(maxLen, end - start); }` |
| 3 | Median of Two Sorted Arrays | 4 | https://leetcode.com/problems/median-of-two-sorted-arrays/ | Use binary search on the smaller array to find the correct partition point partitionX. Calculate the corresponding partition partitionY in the other array such that partitionX + partitionY = (n+m+1)/2. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. Adjust binary search range based on comparison. | Binary search on partitions to find median in logarithmic time. | Binary Search | O(log(min(n, m))) | O(1) | `if (maxLeftX <= minRightY && maxLeftY <= minRightX) { // Found partition } else if (maxLeftX > minRightY) { high = partitionX - 1; } else { low = partitionX + 1; }` |
| 4 | Maximum Subarray | 53 | https://leetcode.com/problems/maximum-subarray/ | Kadane's Algorithm: Iterate through the array, maintaining currentMax (max sum ending at current position) and globalMax (max sum found so far). currentMax = max(num, currentMax + num). Update globalMax = max(globalMax, currentMax). | Kadane's: Discard subarray prefix if its sum becomes negative. | Dynamic Programming / Greedy | O(n) | O(1) | `currentMax = Math.max(num, currentMax + num); globalMax = Math.max(globalMax, currentMax);` |
| 5 | Merge Intervals | 56 | https://leetcode.com/problems/merge-intervals/ | Sort intervals based on start times. Iterate through sorted intervals, merging overlapping ones. If the current interval overlaps with the last merged interval in the result list (current.start <= last.end), update the end of the last interval (last.end = max(last.end, current.end)). Otherwise, add the current interval as a new entry. | Sort by start then merge greedily. | Sorting / Greedy | O(n log n) | O(n) (for result list) or O(log n) (for sort) | `if (merged.isEmpty() || current.start > merged.get(merged.size() - 1).end) { merged.add(current); } else { merged.get(merged.size() - 1).end = Math.max(merged.get(merged.size() - 1).end, current.end); }` |
| 6 | Reverse Linked List | 206 | https://leetcode.com/problems/reverse-linked-list/ | Iterative approach: Use three pointers: prev (initially null), curr (initially head), and nextTemp. While curr is not null, store curr.next in nextTemp, set curr.next to prev, update prev to curr, and move curr to nextTemp. | Iterative reversal using three pointers (prev, curr, next). | Linked List | O(n) | O(1) | `ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp;` |
| 7 | LRU Cache | 146 | https://leetcode.com/problems/lru-cache/ | Use a HashMap for O(1) key lookup and a Doubly Linked List (DLL) to maintain the order of usage. Map keys to DLL nodes. On get or put (update), move the accessed node to the front of the DLL. On put when capacity is reached, remove the node from the tail of the DLL and the corresponding entry from the map. | HashMap + Doubly Linked List for O(1) get/put. | Hash Map / Doubly Linked List | O(1) for get and put | O(capacity) | `// On access (get/put): removeNode(node); addToFront(node); // On put full: Node tail = removeTail(); map.remove(tail.key);` |
| 8 | Generate Parentheses | 22 | https://leetcode.com/problems/generate-parentheses/ | Use backtracking (recursive approach). Maintain counts of open and close parentheses used. Add '(' if open < n. Add ')' if close < open. Base case: if length is 2*n, add the string to the result list. | Backtracking with constraints on open/close counts. | Backtracking / Recursion | O(4^n / (n^(3/2))) (Catalan Number) | O(n) (recursion stack) + O(n * 4^n / (n^(3/2))) (result storage) | `if (open < max) backtrack(list, str + '(', open + 1, close, max); if (close < open) backtrack(list, str + ')', open, close + 1, max);` |
| 9 | Lowest Common Ancestor of a Binary Tree | 236 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ | Recursive approach. Base cases: If root is null, p, or q, return root. Recursively find LCA in left and right subtrees (leftLCA, rightLCA). If both are non-null, current root is LCA. If only one is non-null, return that one. If both are null, return null. | Recursive search; LCA is the node where paths to p and q diverge. | Tree / Recursion / DFS | O(n) | O(n) (worst case, skewed tree) O(h) (average, height) | `ListNode leftLCA = lowestCommonAncestor(root.left, p, q); ListNode rightLCA = lowestCommonAncestor(root.right, p, q); if (leftLCA != null && rightLCA != null) return root; return (leftLCA != null) ? leftLCA : rightLCA;` |
| 10 | Longest Increasing Subsequence | 300 | https://leetcode.com/problems/longest-increasing-subsequence/ | DP with Memoization: Define dp[i] as the LIS ending at index i. To compute dp[i], iterate j from 0 to i-1. If nums[i] > nums[j], then dp[i] = max(dp[i], 1 + dp[j]). Alternatively, O(n log n) approach using patience sorting (maintain tails of potential LIS). | DP state dp[i] = LIS length ending at i. (Or O(n log n) patience sort). | Dynamic Programming | O(n^2) for basic DP, O(n log n) optimized | O(n) | `for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLength = Math.max(maxLength, dp[i]);` (for O(n^2) DP) |
| 11 | Search in Rotated Sorted Array | 33 | https://leetcode.com/problems/search-in-rotated-sorted-array/ | Modified Binary Search. Find the pivot point (minimum element) first OR directly adapt binary search. In each step, determine which half (left or right of mid) is sorted. Check if the target lies within the sorted half's range. Adjust low and high accordingly. | Modified binary search adapting to the rotation point. | Binary Search | O(log n) | O(1) | `if (nums[low] <= nums[mid]) { // Left half sorted if (target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; } else { // Right half sorted ... }` |
| 12 | Number of Islands | 200 | https://leetcode.com/problems/number-of-islands/ | Iterate through the grid. If a cell contains '1' and hasn't been visited, increment the island count and start a DFS or BFS from that cell to mark all connected '1's as visited (e.g., change '1' to '0' or use a separate visited array). | DFS/BFS traversal to explore and mark connected land cells. | Graph Traversal (DFS/BFS) | O(m*n) | O(m*n) (recursion stack for DFS or queue/visited array for BFS) | `if (grid[r][c] == '1') { count++; dfs(grid, r, c); // or bfs } // dfs(grid, r, c): mark grid[r][c] = '0'; explore neighbors` |
| 13 | Container With Most Water | 11 | https://leetcode.com/problems/container-with-most-water/ | Use two pointers, left at index 0 and right at index n-1. Calculate area min(height[left], height[right]) * (right - left). Update max area. Move the pointer pointing to the shorter line inward (left++ if height[left] < height[right], else right--). | Two pointers: move the shorter height pointer inward. | Two Pointers | O(n) | O(1) | `area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--;` |
| 14 | Trapping Rain Water | 42 | https://leetcode.com/problems/trapping-rain-water/ | Calculate maxLeft[i] (max height to the left of i) and maxRight[i] (max height to the right of i) for all i. The water trapped at index i is max(0, min(maxLeft[i], maxRight[i]) - height[i]). Sum these amounts. Can be optimized to O(1) space using two pointers. | Water at i depends on min(max_left, max_right) - height[i]. | Dynamic Programming / Two Pointers | O(n) | O(n) (for DP arrays) or O(1) (for Two Pointer) | `water += Math.max(0, Math.min(maxLeft[i], maxRight[i]) - height[i]); // DP <br> // Two Pointer: if (leftMax < rightMax) { water += leftMax - height[left]; left++; } else { water += rightMax - height[right]; right--; }` |
| 15 | Merge Two Sorted Lists | 21 | https://leetcode.com/problems/merge-two-sorted-lists/ | Iterative approach: Use a dummy head node. Maintain a current pointer for the merged list. Compare heads of list1 and list2. Append the smaller node to current.next and advance that list's pointer. Update current. After loop, append the remaining non-null list. | Dummy head node simplifies merging logic. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode dummy = new ListNode(0); ListNode current = dummy; ... if (list1.val <= list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; ... return dummy.next;` |
| 16 | Add Two Numbers | 2 | https://leetcode.com/problems/add-two-numbers/ | Iterate through both lists simultaneously using a dummy head for the result list. Keep track of carry. At each step, calculate sum = l1.val + l2.val + carry. The digit for the new node is sum % 10, and the new carry is sum / 10. Handle remaining nodes and final carry. | Simulate elementary addition with carry using linked lists. | Linked List / Simulation | O(max(n, m)) | O(max(n, m)) (for result list) | `int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); carry = sum / 10; curr.next = new ListNode(sum % 10); ...` |
| 17 | Binary Tree Inorder Traversal | 94 | https://leetcode.com/problems/binary-tree-inorder-traversal/ | Recursive approach: Helper function inorder(node, list). Base case: if node is null, return. Recursively call inorder(node.left, list), then add node.val to the list, then recursively call inorder(node.right, list). Iterative uses a Stack. | Standard recursive inorder traversal (Left-Root-Right). | Tree Traversal (DFS) | O(n) | O(n) (recursion stack / explicit stack) | `inorder(node.left, result); result.add(node.val); inorder(node.right, result);` |
| 18 | Validate Binary Search Tree | 98 | https://leetcode.com/problems/validate-binary-search-tree/ | Recursive approach: Pass down valid range (min, max) for each node. For a node, check if node.val > min and node.val < max. Recursively call for left child with range (min, node.val) and right child with range (node.val, max). | Recursive check passing valid range [min, max] down. | Tree Traversal (DFS) | O(n) | O(n) (recursion stack) | `return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);` |
| 19 | Binary Tree Level Order Traversal | 102 | https://leetcode.com/problems/binary-tree-level-order-traversal/ | Use Breadth-First Search (BFS) with a Queue. Initialize queue with root. While queue is not empty, get the size (levelSize). Process levelSize nodes: dequeue node, add its value to current level list, enqueue its non-null children. Add level list to result. | BFS using a queue to process nodes level by level. | Tree Traversal (BFS) | O(n) | O(w) (where w is max width of tree/queue size) | `int levelSize = queue.size(); List<Integer> currentLevel = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); ... queue.offer(child); }` |
| 20 | Serialize and Deserialize Binary Tree | 297 | https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ | Serialization (e.g., Preorder): Use DFS. Append node value to string/builder. If null, append a marker (e.g., 'null' or '#'). Recursively serialize left and right. Deserialization: Use a Queue/Iterator of the split serialized string. Build tree recursively. Read value, if marker, return null. Create node, recursively build left, then right. | Use Preorder/Level Order traversal with null markers for serialization. Rebuild recursively/iteratively during deserialization. | Tree Traversal (DFS/BFS) | O(n) | O(n) | `// Serialize (Preorder) sb.append(node.val).append(','); serializeHelper(node.left, sb); serializeHelper(node.right, sb); // Deserialize (Preorder) String val = nodes.poll(); if (val.equals("#")) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(nodes); node.right = deserializeHelper(nodes);` |
| 21 | Coin Change | 322 | https://leetcode.com/problems/coin-change/ | DP with Memoization. memo[amount] stores min coins for that amount. Base case: memo[0]=0. Recursive step: memo[amount] = 1 + min(solve(amount - coin)) for each coin c <= amount. Initialize memo with -1 (uncomputed) or Integer.MAX_VALUE. | DP state memo[i] = min coins for amount i. Check for Integer.MAX_VALUE to handle impossible cases. | Dynamic Programming | O(amount * coins) | O(amount) | `if (memo[rem] != -1) return memo[rem]; int minCoins = Integer.MAX_VALUE; for (int coin : coins) { if (rem >= coin) { int res = solve(rem - coin); if (res != Integer.MAX_VALUE) minCoins = Math.min(minCoins, 1 + res); } } memo[rem] = minCoins;` |
| 22 | Find Minimum in Rotated Sorted Array | 153 | https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ | Modified Binary Search. Compare nums[mid] with nums[high]. If nums[mid] < nums[high], the minimum is in the left half (including mid), so high = mid. Otherwise, the minimum is in the right half (mid + 1), so low = mid + 1. Loop ends when low == high. | Compare mid with high to decide which half contains the pivot/minimum. | Binary Search | O(log n) | O(1) | `if (nums[mid] < nums[high]) { high = mid; } else { low = mid + 1; }` |
| 23 | Course Schedule | 207 | https://leetcode.com/problems/course-schedule/ | Topological Sort using Kahn's Algorithm (BFS). Build adjacency list and calculate in-degrees. Initialize queue with nodes having in-degree 0. Process queue: dequeue node, decrement in-degree of neighbors. If neighbor's in-degree becomes 0, enqueue it. Count processed nodes; if count equals numCourses, return true. | Kahn's Algorithm (BFS + in-degree counting) for cycle detection. | Graph / Topological Sort | O(V+E) | O(V+E) (for adjacency list and in-degrees) | `Queue<Integer> queue = new LinkedList<>(); // Add nodes with inDegree 0 while (!queue.isEmpty()) { int course = queue.poll(); count++; for (int neighbor : adj.get(course)) { if (--inDegree[neighbor] == 0) queue.offer(neighbor); } } return count == numCourses;` |
| 24 | Word Ladder | 127 | https://leetcode.com/problems/word-ladder/ | BFS on implicit graph. Start BFS from beginWord. Each level represents one transformation. Use a Set for wordList for O(1) lookup and a Set for visited words. In each step, generate all possible 1-letter transformations of the current word. If a transformation is in wordList and not visited, add to queue and mark visited. | BFS for shortest path in unweighted graph. Generate neighbors by changing one char at a time. | Graph / BFS | O(N * M^2) (N=wordList size, M=word length) | O(N*M) (for word set and visited set/queue) | `for (int i = 0; i < word.length(); i++) { char[] chars = word.toCharArray(); for (char c = 'a'; c <= 'z'; c++) { chars[i] = c; String neighbor = new String(chars); if (wordSet.contains(neighbor) && !visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } }` |
| 25 | Group Anagrams | 49 | https://leetcode.com/problems/group-anagrams/ | Use a HashMap where the key represents the character count/sorted version of a string, and the value is a list of anagrams. Iterate through strs, generate the key for each string (e.g., sort the string or create a count array string like 'a1b1c0...'), and add the original string to the list associated with that key. | Canonical representation (sorted string or char count) as HashMap key. | Hash Map | O(N * K log K) or O(N*K) (N=num strings, K=max length) | O(N*K) (for storing anagram groups) | `char[] ca = str.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);` |
| 26 | Valid Parentheses | 20 | https://leetcode.com/problems/valid-parentheses/ | Use a Stack. Iterate through the string. If an opening bracket ('(', '{', '[') is encountered, push it onto the stack. If a closing bracket is found, check if the stack is empty or if the top element is the corresponding opening bracket. If not, return false. Pop if it matches. After iteration, the stack must be empty. | Stack to match opening/closing brackets LIFO order. | Stack | O(n) | O(n) | `if (c == '(' || c == '{' || c == '[') stack.push(c); else if (stack.isEmpty() || !isMatching(stack.pop(), c)) return false;` |
| 27 | Combination Sum | 39 | https://leetcode.com/problems/combination-sum/ | Backtracking/DFS. Define a recursive function findCombinations(index, currentSum, currentList). Base cases: if currentSum == target, add currentList to results. If currentSum > target or index >= candidates.length, return. Recursive step: Include candidates[index] (call findCombinations(index, ..., ...) again) and Exclude candidates[index] (call findCombinations(index + 1, ..., ...)). | Standard backtracking allowing element reuse. | Backtracking / Recursion | O(N^(T/M)) (approx, N=candidates, T=target, M=min candidate) | O(T/M) (recursion depth) + O(Result Size) | `// Include candidate[i] currentList.add(candidates[i]); backtrack(result, currentList, candidates, remaining - candidates[i], i); // crucial: pass i not i+1 currentList.remove(currentList.size() - 1); // Backtrack` |
| 28 | Permutations | 46 | https://leetcode.com/problems/permutations/ | Backtracking/DFS. Use a boolean used array or swap elements. Define backtrack(currentPermutation). Base case: if currentPermutation.size() == nums.length, add to results. Loop through nums: if nums[i] is not used, add it to currentPermutation, mark as used, recurse (backtrack(...)), unmark, remove from currentPermutation. | Backtracking with mechanism (visited array/swapping) to track used elements. | Backtracking / Recursion | O(N * N!) | O(N) (recursion depth) + O(N * N!) (result storage) | `if (tempList.size() == nums.length) { result.add(new ArrayList<>(tempList)); } else { for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; tempList.add(nums[i]); backtrack(result, tempList, nums, used); tempList.remove(tempList.size() - 1); used[i] = false; } }` |
| 29 | Word Search | 79 | https://leetcode.com/problems/word-search/ | Backtracking/DFS. Iterate through each cell as a potential starting point. Call DFS helper search(r, c, index). Base case: index == word.length(), return true. Check bounds, if board[r][c] != word.charAt(index), return false. Mark current cell (e.g., board[r][c] = '#'). Explore 4 neighbors recursively search(nr, nc, index + 1). If any returns true, return true. Unmark cell (backtrack) board[r][c] = originalChar. Return false if no path found. | DFS with backtracking (marking visited path). | Backtracking / DFS | O(N * M * 4^L) (N, M=dims, L=word length) | O(L) (recursion depth) | `char temp = board[r][c]; board[r][c] = '#'; // Mark visited boolean found = dfs(board, r+1, c, word, index+1) || dfs(board, r-1, c, word, index+1) || dfs(board, r, c+1, word, index+1) || dfs(board, r, c-1, word, index+1); board[r][c] = temp; // Backtrack` |
| 30 | Sudoku Solver | 37 | https://leetcode.com/problems/sudoku-solver/ | Backtracking. Find the next empty cell ('.'). Try filling it with digits '1' through '9'. For each digit, check if it's valid (using helper isValid(row, col, digit) checking row, col, and 3x3 subgrid). If valid, place digit and recursively call solve(). If recursive call returns true, return true. If not, backtrack (reset cell to '.'). If no digit works for the cell, return false. Base case: no empty cells found, return true. | Backtracking search trying digits 1-9 in empty cells, pruning invalid states. | Backtracking / Recursion | O(9^(N*N)) (with pruning, much faster in practice) | O(N*N) (recursion depth/board state) | `for (char c = '1'; c <= '9'; c++) { if (isValid(board, row, col, c)) { board[row][col] = c; if (solve(board)) return true; board[row][col] = '.'; // Backtrack } } return false;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 32 | Minimum Window Substring | 76 | https://leetcode.com/problems/minimum-window-substring/ | Sliding Window with Frequency Maps. Use two HashMaps (or arrays) `tFreq` for pattern `t` and `windowFreq` for current window in `s`. Use `required` count (distinct chars in `t`) and `formed` count (distinct chars in window matching `required` count). Expand `end` pointer, update `windowFreq` and `formed`. When `formed == required`, shrink `start` pointer, update window, check if still valid (`formed == required`), and update min window. | Sliding window with two pointers and frequency maps to track character counts. | Sliding Window / Hash Map | O(\|S\| + \|T\|) | O(\|T\|) or O(alphabet size) | `while (formed == required) { // Shrink window updateMinWindow(...); char leftChar = s.charAt(start); windowFreq[leftChar]--; if (tFreq.containsKey(leftChar) && windowFreq[leftChar] < tFreq.get(leftChar)) { formed--; } start++; }` |
| 33 | 3Sum | 15 | https://leetcode.com/problems/3sum/ | Sort the array. Iterate through the array with index `i` from 0 to n-3. For each `nums[i]`, use two pointers `left = i + 1` and `right = n - 1`. Calculate `sum = nums[i] + nums[left] + nums[right]`. If `sum == 0`, add `[nums[i], nums[left], nums[right]]` to result, increment `left`, decrement `right`, and skip duplicates. If `sum < 0`, `left++`. If `sum > 0`, `right--`. Skip duplicates for `i` as well. | Sort + Two Pointers approach after fixing one element. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) depending on sort | `while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { result.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left < right && nums[left] == nums[left+1]) left++; // Skip duplicates while (left < right && nums[right] == nums[right-1]) right--; left++; right--; } else if (sum < 0) left++; else right--; }` |
| 34 | Merge k Sorted Lists | 23 | https://leetcode.com/problems/merge-k-sorted-lists/ | Use a Min-Heap (PriorityQueue) to store the head nodes of the k lists, ordered by value. Repeatedly extract the minimum node from the heap, add it to the result list (using a dummy head), and if the extracted node has a `next`, add `next` to the heap. | Min-Heap to efficiently find the smallest current element across k lists. | Heap (Priority Queue) | O(N log k) N=total nodes, k=lists | O(k) for heap, O(N) for result list | `PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val)); for (ListNode node : lists) { if (node != null) pq.offer(node); } while (!pq.isEmpty()) { ListNode minNode = pq.poll(); current.next = minNode; current = current.next; if (minNode.next != null) pq.offer(minNode.next); }` |
| 35 | Construct Binary Tree from Preorder and Inorder Traversal | 105 | https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ | Recursive approach. Use preorder to identify the root (`preorder[preStart]`). Find the root's index (`inIndex`) in the inorder traversal (use a HashMap for O(1) lookup). Elements left of `inIndex` in inorder form the left subtree, elements right form the right subtree. Recursively build left subtree using `preorder[preStart+1 ...]` and `inorder[inStart ... inIndex-1]`. Recursively build right subtree using remaining preorder and `inorder[inIndex+1 ... inEnd]`. | Preorder gives root, Inorder splits left/right subtrees. HashMap for Inorder lookup. | Tree / Recursion / DFS / Hash Map | O(N) | O(N) for map and recursion stack | `int rootVal = preorder[preStart]; TreeNode root = new TreeNode(rootVal); int inIndex = map.get(rootVal); int leftSize = inIndex - inStart; root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, inorder, inStart, inIndex - 1, map); root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, inorder, inIndex + 1, inEnd, map);` |
| 36 | Longest Palindromic Substring | 5 | https://leetcode.com/problems/longest-palindromic-substring/ | Expand Around Center approach. Iterate through the string, considering each character `i` and each pair `(i, i+1)` as potential centers of a palindrome. For each center, expand outwards (`left--`, `right++`) while `s.charAt(left) == s.charAt(right)`. Keep track of the longest palindrome found. | Expand from center (odd and even length palindromes). | String / Dynamic Programming / Two Pointers | O(n^2) | O(1) | `for (int i = 0; i < s.length(); i++) { expandAroundCenter(s, i, i); // Odd length expandAroundCenter(s, i, i + 1); // Even length } // expandAroundCenter updates global start/maxLength` |
| 37 | Contains Duplicate | 217 | https://leetcode.com/problems/contains-duplicate/ | Use a HashSet. Iterate through the array `nums`. For each number, try to add it to the set. If `set.add(num)` returns `false`, it means the number is already in the set, so return `true`. If the loop finishes without finding duplicates, return `false`. | HashSet for O(1) average time duplicate checking. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) { if (!set.add(num)) return true; } return false;` |
| 38 | Longest Repeating Character Replacement | 424 | https://leetcode.com/problems/longest-repeating-character-replacement/ | Sliding Window. Maintain a window `[start, end]` and a frequency map (array `int[26]`) of characters in the window. Keep track of the frequency of the most frequent character (`maxFreq`). If `windowSize (end - start + 1) - maxFreq > k`, the window is invalid (too many replacements needed). Shrink the window by incrementing `start` and decrementing the count of `s.charAt(start)`. Update `maxLength` in each step. | Sliding window tracking max frequency and replacements needed. | Sliding Window / Hash Map | O(n) | O(1) (alphabet size 26) | `count[s.charAt(end) - 'A']++; maxFreq = Math.max(maxFreq, count[s.charAt(end) - 'A']); while (end - start + 1 - maxFreq > k) { count[s.charAt(start) - 'A']--; start++; // Note: maxFreq doesn't need explicit decrement here, it corrects itself } maxLength = Math.max(maxLength, end - start + 1);` |
| 39 | Sliding Window Maximum | 239 | https://leetcode.com/problems/sliding-window-maximum/ | Use a Deque (Double-Ended Queue) to store indices of elements in the current window. The deque maintains indices in decreasing order of their corresponding values in `nums`. Before adding a new index `i`, remove indices from the back whose values are less than or equal to `nums[i]`. Remove indices from the front that are out of the window `(deque.peekFirst() <= i - k)`. The maximum element for the window ending at `i` is always `nums[deque.peekFirst()]`. | Monotonic Decreasing Deque to efficiently query max in window. | Sliding Window / Deque | O(n) | O(k) | `while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) { deque.pollLast(); } deque.offerLast(i); if (deque.peekFirst() <= i - k) { deque.pollFirst(); } if (i >= k - 1) { result[i - k + 1] = nums[deque.peekFirst()]; }` |
| 40 | Linked List Cycle II | 142 | https://leetcode.com/problems/linked-list-cycle-ii/ | Floyd's Cycle-Finding Algorithm (Tortoise and Hare). Use two pointers, `slow` moving one step and `fast` moving two steps. If they meet, there's a cycle. To find the start of the cycle, reset `slow` to the head of the list. Then move both `slow` and `fast` (which is at the meeting point) one step at a time. They will meet again at the start of the cycle. | Floyd's algorithm: detect cycle, then find start node by moving one pointer from head and another from meeting point at same speed. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { // Cycle detected slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; // Cycle start } } return null;` |
| 42 | Reverse Nodes in k-Group | 25 | https://leetcode.com/problems/reverse-nodes-in-k-group/ | Recursive or Iterative. Iterative: Use a `dummy` head. Find the start (`groupPrev`) and end (`kth`) of a group of k nodes. If `kth` is null, break. Reverse the sublist from `groupPrev.next` to `kth` (using standard list reversal). Connect the previous part (`groupPrev`) to the new head of the reversed group, and connect the tail of the reversed group to the node after `kth`. Update `groupPrev` to the tail of the reversed group. | Reverse sublists of size k and reconnect them carefully. | Linked List | O(n) | O(1) iterative / O(n/k) recursive | `// Inside loop, after finding groupPrev and kth Node groupStart = groupPrev.next; Node groupEnd = kth; Node nextGroupStart = kth.next; // Reverse group from groupStart to groupEnd ... // Reconnect groupPrev.next = reversedHead; groupStart.next = nextGroupStart; // groupStart is now tail groupPrev = groupStart;` |
| 43 | Binary Tree Maximum Path Sum | 124 | https://leetcode.com/problems/binary-tree-maximum-path-sum/ | Recursive DFS approach. Define a helper function `maxGain(node)` that returns the maximum path sum starting at `node` and going downwards (either left or right). Inside `maxGain`, calculate `max(0, maxGain(node.left))` and `max(0, maxGain(node.right))`. Update a global `maxSum` variable with `node.val + leftGain + rightGain`. The function returns `node.val + max(leftGain, rightGain)`. | Recursive helper returns max gain downwards; global variable tracks max path sum possibly including split at node. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int leftGain = Math.max(0, maxGain(node.left)); int rightGain = Math.max(0, maxGain(node.right)); maxSum = Math.max(maxSum, node.val + leftGain + rightGain); // Update global return node.val + Math.max(leftGain, rightGain); // Return max path downwards` |
| 44 | Longest Common Subsequence | 1143 | https://leetcode.com/problems/longest-common-subsequence/ | DP with Memoization. `memo[i][j]` stores LCS length for `text1[i...]` and `text2[j...]`. Base case: if `i` or `j` reaches end, return 0. If `memo[i][j]` computed, return it. If `text1.charAt(i) == text2.charAt(j)`, result is `1 + solve(i+1, j+1)`. Otherwise, result is `max(solve(i+1, j), solve(i, j+1))`. Store and return result. | DP state `memo[i][j]` = LCS of suffixes starting at i,j. | Dynamic Programming | O(m*n) | O(m*n) | `if (memo[i][j] != null) return memo[i][j]; if (text1.charAt(i) == text2.charAt(j)) { memo[i][j] = 1 + solve(i + 1, j + 1, text1, text2, memo); } else { memo[i][j] = Math.max(solve(i + 1, j, text1, text2, memo), solve(i, j + 1, text1, text2, memo)); } return memo[i][j];` |
| 45 | Edit Distance | 72 | https://leetcode.com/problems/edit-distance/ | DP with Memoization. `memo[i][j]` stores min distance between `word1[i...]` and `word2[j...]`. Base cases: if `i` reaches end, return `len2 - j`; if `j` reaches end, return `len1 - i`. If `memo[i][j]` computed, return. If `word1[i] == word2[j]`, result is `solve(i+1, j+1)`. Otherwise, result is `1 + min(solve(i+1, j), solve(i, j+1), solve(i+1, j+1))` (delete, insert, replace). | DP state `memo[i][j]` = edit distance for suffixes. Consider match/replace, delete, insert options. | Dynamic Programming | O(m*n) | O(m*n) | `if (word1.charAt(i) == word2.charAt(j)) { memo[i][j] = solve(i + 1, j + 1, word1, word2, memo); } else { int delete = solve(i + 1, j, word1, word2, memo); int insert = solve(i, j + 1, word1, word2, memo); int replace = solve(i + 1, j + 1, word1, word2, memo); memo[i][j] = 1 + Math.min(delete, Math.min(insert, replace)); }` |
| 46 | Word Break | 139 | https://leetcode.com/problems/word-break/ | DP with Memoization. `memo[i]` stores whether `s[i...]` can be segmented. `memo` can be Boolean or Integer (0=uncomputed, 1=true, -1=false). Base case: if `i == s.length()`, return true. If `memo[i]` computed, return result. Iterate `j` from `i` to `s.length()-1`. If `s.substring(i, j+1)` is in `wordDict` and `solve(j+1)` returns true, set `memo[i] = true` and return true. If loop finishes, set `memo[i] = false`. | DP state `memo[i]` = can `s[i...]` be broken? Try all prefixes starting at `i`. | Dynamic Programming | O(n*m*k) n=s len, m=dict size, k=word len. Optimised O(n^2*k) or O(n^3) | O(n) | `if (memo[start] != null) return memo[start]; for (int end = start; end < s.length(); end++) { String word = s.substring(start, end + 1); if (wordDict.contains(word) && solve(end + 1, s, wordDict, memo)) { memo[start] = true; return true; } } memo[start] = false;` |
| 47 | Burst Balloons | 312 | https://leetcode.com/problems/burst-balloons/ | DP with Memoization. `memo[left][right]` stores max coins for bursting balloons *between* index `left` and `right` (exclusive). Add 1s at boundaries of `nums`. Iterate `k` from `left+1` to `right-1` representing the *last* balloon to burst in `(left, right)`. Cost is `nums[left]*nums[k]*nums[right] + solve(left, k) + solve(k, right)`. Maximize over `k`. | DP state `memo[l][r]` = max coins in `(l,r)`. Key is iterating the *last* balloon burst in the interval. | Dynamic Programming | O(n^3) | O(n^2) | `if (memo[left][right] > 0) return memo[left][right]; int maxCoins = 0; for (int k = left + 1; k < right; k++) { int coins = nums[left] * nums[k] * nums[right]; coins += solve(left, k, nums, memo) + solve(k, right, nums, memo); maxCoins = Math.max(maxCoins, coins); } memo[left][right] = maxCoins;` |
| 48 | Find First and Last Position of Element in Sorted Array | 34 | https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ | Binary Search twice. One search finds the leftmost index (`low`): if `nums[mid] == target`, potentially keep searching left (`high = mid - 1`), store `mid` as potential answer. Another search finds the rightmost index (`high`): if `nums[mid] == target`, potentially keep searching right (`low = mid + 1`), store `mid`. | Two modified binary searches: one biased left, one biased right. | Binary Search | O(log n) | O(1) | `// Find Leftmost int findBound(int[] nums, int target, boolean isFirst) { // ... inside BS loop if (nums[mid] == target) { index = mid; if (isFirst) high = mid - 1; else low = mid + 1; } //... } left = findBound(nums, target, true); right = findBound(nums, target, false);` |
| 49 | Course Schedule II | 210 | https://leetcode.com/problems/course-schedule-ii/ | Topological Sort (Kahn's or DFS). Kahn's: Same as Course Schedule I, but add dequeued nodes to a result list/array. If final count != numCourses, return empty array. DFS: Use 3 states (visiting, visited). Perform DFS. Add node to result list *after* visiting all neighbors (post-order). Reverse the result list. Detect cycles using 'visiting' state. | Topological sort storing the order. Return empty array if cycle detected. | Graph / Topological Sort | O(V+E) | O(V+E) | `// Kahn's: Add to result list after dequeuing // DFS: Add node to head of list/stack in post-order visit. Detect cycle with VISITING state. List<Integer> result = new ArrayList<>(); // Kahn's // ... add to queue, process ... result.add(course); // Add node after processing it // ... return result.stream().mapToInt(i->i).toArray(); // if count == numCourses` |
| 50 | Implement Trie (Prefix Tree) | 208 | https://leetcode.com/problems/implement-trie-prefix-tree/ | Create a `TrieNode` class containing `children` (e.g., `TrieNode[26]` or `Map<Character, TrieNode>`) and an `isEndOfWord` boolean flag. `insert`: Traverse from root, creating nodes if they don't exist. Mark `isEndOfWord` at the end. `search`: Traverse from root. If path exists and ends with `isEndOfWord`, return true. `startsWith`: Traverse from root. If path exists, return true. | Node-based structure where each node represents a character and path represents prefix/word. | Trie / Design | O(L) for ops, L=word length | O(N*L) total nodes/chars | `class TrieNode { TrieNode[] children = new TrieNode[26]; boolean isEndOfWord; } // Insert: TrieNode curr = root; for (char c : word.toCharArray()) { if (curr.children[c - 'a'] == null) curr.children[c - 'a'] = new TrieNode(); curr = curr.children[c - 'a']; } curr.isEndOfWord = true;` |
| 51 | Rotate Array | 189 | https://leetcode.com/problems/rotate-array/ | Reversal Algorithm: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining `n-k` elements. (Make sure `k = k % n`). This is O(n) time and O(1) space. | Three reversals achieve rotation in-place. | Array Manipulation | O(n) | O(1) | `k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);` |
| 52 | Sort Colors | 75 | https://leetcode.com/problems/sort-colors/ | Dutch National Flag algorithm (3-way partitioning). Use three pointers: `low=0`, `mid=0`, `high=n-1`. While `mid <= high`: If `nums[mid] == 0`, swap `nums[low]` and `nums[mid]`, increment both `low` and `mid`. If `nums[mid] == 1`, increment `mid`. If `nums[mid] == 2`, swap `nums[mid]` and `nums[high]`, decrement `high` (do not increment `mid` as swapped element needs checking). | Dutch National Flag (DNF) algorithm for 3-way partition. | Array / Two Pointers / Sorting | O(n) | O(1) | `while (mid <= high) { if (nums[mid] == 0) { swap(nums, low++, mid++); } else if (nums[mid] == 1) { mid++; } else { swap(nums, mid, high--); } }` |
| 53 | Find All Anagrams in a String | 438 | https://leetcode.com/problems/find-all-anagrams-in-a-string/ | Sliding Window with Character Counts. Maintain two frequency maps (arrays `int[26]`), one for pattern `p` (`pCount`) and one for the current window in `s` (`sCount`). Initialize window of size `p.length()`. Compare `sCount` and `pCount`. Slide the window one step at a time: decrement count for char leaving window, increment count for char entering window. Compare counts at each step. | Sliding window with frequency map comparison. | Sliding Window / Hash Map | O(\|S\|) | O(1) (alphabet size 26) | `int[] pCount = new int[26]; int[] sCount = new int[26]; // Fill pCount, initial sCount for (int i = pLen; i < sLen; i++) { if (Arrays.equals(sCount, pCount)) result.add(i - pLen); sCount[s.charAt(i - pLen) - 'a']--; sCount[s.charAt(i) - 'a']++; } // Final check for last window` |
| 54 | Two Sum II - Input Array Is Sorted | 167 | https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ | Use two pointers, `left` starting at index 0 and `right` starting at index `n-1`. Calculate `sum = numbers[left] + numbers[right]`. If `sum == target`, return `[left + 1, right + 1]`. If `sum < target`, increment `left` to increase the sum. If `sum > target`, decrement `right` to decrease the sum. | Two pointers moving inwards on a sorted array. | Two Pointers | O(n) | O(1) | `while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } else if (sum < target) { left++; } else { right--; } }` |
| 55 | Reorder List | 143 | https://leetcode.com/problems/reorder-list/ | 1. Find the middle node using slow/fast pointers. 2. Reverse the second half of the list starting from `middle.next`. Set `middle.next = null` to split lists. 3. Merge the first half and the reversed second half: Interleave nodes one by one from each half. | Find Mid -> Reverse 2nd Half -> Merge Alternately. | Linked List / Two Pointers | O(n) | O(1) | `// 1. Find Middle ListNode slow = head, fast = head; //... // 2. Reverse Second Half ListNode secondHead = reverse(slow.next); slow.next = null; // Split // 3. Merge ListNode first = head; while (secondHead != null) { ListNode temp1 = first.next; ListNode temp2 = secondHead.next; first.next = secondHead; secondHead.next = temp1; first = temp1; secondHead = temp2; }` |
| 56 | Sort List | 148 | https://leetcode.com/problems/sort-list/ | Use Merge Sort. Base case: if list is empty or has one node, return it. Find the middle of the list using slow/fast pointers. Split the list into two halves. Recursively sort the left half (`sortList(head)`) and the right half (`sortList(middle)`). Merge the two sorted halves using a standard merge function (like merge two sorted lists). | Merge Sort adapted for Linked Lists. | Linked List / Sorting / Recursion / Merge Sort | O(n log n) | O(log n) recursion stack | `// Find middle ListNode mid = getMid(head); // Split ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); // Merge return merge(left, right);` |
| 57 | Diameter of Binary Tree | 543 | https://leetcode.com/problems/diameter-of-binary-tree/ | Use DFS. Define a helper function `height(node)` that returns the height of the subtree rooted at `node`. Inside this function, recursively calculate `leftHeight = height(node.left)` and `rightHeight = height(node.right)`. The diameter *passing through* `node` is `leftHeight + rightHeight`. Update a global/instance variable `maxDiameter = max(maxDiameter, leftHeight + rightHeight)`. The function `height(node)` returns `1 + max(leftHeight, rightHeight)`. | DFS calculating height; diameter is max(leftHeight + rightHeight) across all nodes. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int maxDiameter = 0; int height(TreeNode node) { if (node == null) return 0; int leftH = height(node.left); int rightH = height(node.right); maxDiameter = Math.max(maxDiameter, leftH + rightH); return 1 + Math.max(leftH, rightH); }` |
| 58 | Kth Smallest Element in a BST | 230 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/ | Inorder Traversal (Recursive or Iterative). Perform an inorder traversal (Left, Root, Right) which visits nodes in ascending order for a BST. Maintain a counter. When the counter reaches `k`, the current node's value is the answer. Iterative using a stack is common. | Inorder traversal visits BST nodes in sorted order. | Tree / BST / Inorder Traversal | O(H + k) avg, O(N) worst | O(H) avg, O(N) worst (stack) | `Stack<TreeNode> stack = new Stack<>(); while (true) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (--k == 0) return root.val; root = root.right; }` |
| 59 | Partition Equal Subset Sum | 416 | https://leetcode.com/problems/partition-equal-subset-sum/ | DP (Memoization). Calculate total sum. If odd, return false. Target sum is `totalSum / 2`. Define `memo[i][s]` = can subset sum `s` be formed using elements up to index `i`. Base cases: `s=0` is true. `i<0` or `s<0` is false. Recurrence: `solve(i-1, s)` (exclude `nums[i]`) OR `solve(i-1, s - nums[i])` (include `nums[i]`). | Reduce to Subset Sum problem with target = totalSum / 2. | Dynamic Programming | O(n * sum) | O(n * sum) | `Boolean[][] memo; boolean solve(int[] nums, int i, int target) { if (target == 0) return true; if (i < 0 || target < 0) return false; if (memo[i][target] != null) return memo[i][target]; boolean include = solve(nums, i - 1, target - nums[i]); boolean exclude = solve(nums, i - 1, target); memo[i][target] = include || exclude; return memo[i][target]; }` |
| 60 | Longest Palindromic Subsequence | 516 | https://leetcode.com/problems/longest-palindromic-subsequence/ | DP with Memoization. `memo[i][j]` stores the length of the LPS for the substring `s[i..j]`. Base case: `memo[i][i] = 1`. If `s.charAt(i) == s.charAt(j)`, then `memo[i][j] = 2 + solve(i+1, j-1)`. If not equal, `memo[i][j] = max(solve(i+1, j), solve(i, j-1))`. | DP state `memo[i][j]` = LPS length in `s[i..j]`. Match ends or take max of subproblems. | Dynamic Programming | O(n^2) | O(n^2) | `Integer[][] memo; int solve(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != null) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) { memo[i][j] = 2 + solve(s, i + 1, j - 1); } else { memo[i][j] = Math.max(solve(s, i + 1, j), solve(s, i, j - 1)); } return memo[i][j]; }` |
| 61 | Palindrome Partitioning | 131 | https://leetcode.com/problems/palindrome-partitioning/ | Backtracking/DFS. Define `backtrack(start, currentList)`. Iterate `end` from `start` to `n-1`. Check if `s.substring(start, end + 1)` is a palindrome. If yes, add it to `currentList`, recurse `backtrack(end + 1, currentList)`, then remove the substring (backtrack). Base case: `start == n`, add `currentList` to results. | Backtracking exploring all partitions, checking palindrome property for each part. | Backtracking / Recursion | O(N * 2^N) | O(N) recursion depth | `for (int end = start; end < s.length(); end++) { if (isPalindrome(s, start, end)) { currentList.add(s.substring(start, end + 1)); backtrack(end + 1, currentList, s, result); currentList.remove(currentList.size() - 1); // Backtrack } }` |
| 62 | Decode Ways | 91 | https://leetcode.com/problems/decode-ways/ | DP with Memoization. `memo[i]` stores ways to decode `s[i...]`. Base case: `memo[n] = 1`. If `s[i] == '0'`, `memo[i] = 0`. One-digit decode: `ways = solve(i+1)`. Two-digit decode: If `i+1 < n` and `s[i..i+1]` is '10'-'26', `ways += solve(i+2)`. Store result in `memo[i]`. | DP state `memo[i]` = ways to decode suffix `s[i...]`. Handle '0' and 1/2 digit checks. | Dynamic Programming | O(n) | O(n) | `if (memo[i] != null) return memo[i]; if (s.charAt(i) == '0') return 0; int ways = solve(i + 1, s, memo); if (i + 1 < s.length()) { int twoDigit = Integer.parseInt(s.substring(i, i + 2)); if (twoDigit >= 10 && twoDigit <= 26) { ways += solve(i + 2, s, memo); } } memo[i] = ways;` |
| 63 | Longest Increasing Path in a Matrix | 329 | https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ | DP (Memoization) + DFS. `memo[r][c]` stores LIP length starting at `(r, c)`. Initialize memo with 0. Iterate through all cells, call DFS if `memo[r][c] == 0`. DFS(r, c): If `memo[r][c] > 0` return it. Calculate `maxPath = 1`. Explore 4 neighbors `(nr, nc)`. If valid and `matrix[nr][nc] > matrix[r][c]`, `maxPath = max(maxPath, 1 + dfs(nr, nc))`. Store `memo[r][c] = maxPath`. | DFS with memoization to avoid recomputing LIP from same cell. | DFS / Dynamic Programming | O(m*n) | O(m*n) | `if (memo[r][c] > 0) return memo[r][c]; int maxLen = 1; for (int[] dir : directions) { int nr = r + dir[0], nc = c + dir[1]; if (/* valid neighbor */ && matrix[nr][nc] > matrix[r][c]) { maxLen = Math.max(maxLen, 1 + dfs(matrix, nr, nc, memo)); } } memo[r][c] = maxLen;` |
| 64 | Pacific Atlantic Water Flow | 417 | https://leetcode.com/problems/pacific-atlantic-water-flow/ | DFS/BFS from both oceans. Create two boolean matrices `pacific` and `atlantic`. Start DFS/BFS from all border cells adjacent to Pacific, mark reachable cells in `pacific`. Do the same for Atlantic border cells and `atlantic` matrix. Iterate through the grid, if `pacific[r][c]` and `atlantic[r][c]` are both true, add `(r, c)` to result. | Start search from ocean boundaries inwards. | DFS / BFS | O(m*n) | O(m*n) | `// dfs(matrix, r, c, visited, prevHeight) for (int i = 0; i < rows; i++) { dfs(matrix, i, 0, pacific, Integer.MIN_VALUE); // Pacific border dfs(matrix, i, cols - 1, atlantic, Integer.MIN_VALUE); // Atlantic border } // ... same for top/bottom borders ... List<List<Integer>> result = new ArrayList<>(); for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) if (pacific[r][c] && atlantic[r][c]) result.add(Arrays.asList(r,c));` |
| 65 | Reconstruct Itinerary | 332 | https://leetcode.com/problems/reconstruct-itinerary/ | Hierholzer's algorithm variation using DFS. Build graph where `adj<String, PriorityQueue<String>>` stores destinations lexicographically. Start DFS from "JFK". In `dfs(airport)`: While neighbors exist, `dfs(neighbor)`. Add `airport` to the front of the result list *after* visiting all neighbors (post-order traversal). | Post-order DFS traversal on graph with sorted adjacency lists (MinHeap). | DFS / Graph / Eulerian Path | O(E log E) or O(E) if radix sort | O(V+E) | `Map<String, PriorityQueue<String>> adj; LinkedList<String> result; void dfs(String airport) { PriorityQueue<String> neighbors = adj.get(airport); while (neighbors != null && !neighbors.isEmpty()) { dfs(neighbors.poll()); } result.addFirst(airport); // Add post-visit }` |
| 66 | Design Twitter | 355 | https://leetcode.com/problems/design-twitter/ | Use HashMaps: `userMap<userId, UserObject>`. `UserObject` contains `Set<Integer> following` and `List<Tweet> tweets`. `Tweet` class has `id`, `timestamp`. `postTweet`: Add tweet to user's tweet list (keep it sorted/limited). `getNewsFeed`: Get user's tweets + tweets from all followees. Use a Max-Heap (PriorityQueue) ordered by timestamp to merge these tweet lists and get the top 10 recent. | HashMaps for users/following, Lists/Heaps for tweets. | Design / Hash Map / Heap | O(F*T*logK) feed, O(1) follow/post (F=following, T=tweets/user, K=10) | O(Users + Tweets + Follows) | `class User { Set<Integer> following = new HashSet<>(); LinkedList<Tweet> tweets = new LinkedList<>(); } Map<Integer, User> userMap; // getNewsFeed PriorityQueue<Tweet> maxHeap = new PriorityQueue<>((a,b)->b.timestamp-a.timestamp); // Add self tweets + followee tweets to heap... poll top 10` |
| 67 | Word Search II | 212 | https://leetcode.com/problems/word-search-ii/ | Build a Trie from the `words`. Perform DFS on the `board` starting from each cell. In the DFS function `dfs(r, c, currentNode)`, check bounds, visited status. Get char `board[r][c]`. If `currentNode` doesn't have child for char, return. Move to child node. If `childNode.word != null`, add it to result and set `childNode.word = null` (avoid duplicates). Mark cell visited, explore 4 neighbors, unmark cell. | Trie stores dictionary words for efficient prefix checking during board DFS. | Trie / DFS / Backtracking | O(M*N*4*3^(L-1)) M,N=dims, L=max word len. Dominated by Trie build + DFS. | O(Total Chars in words) for Trie | `void dfs(char[][] board, int r, int c, TrieNode node, List<String> result) { //... base cases ... char ch = board[r][c]; TrieNode child = node.children[ch - 'a']; if (child == null) return; if (child.word != null) { result.add(child.word); child.word = null; // Avoid duplicates } board[r][c] = '#'; // Mark visited // dfs neighbors... board[r][c] = ch; // Unmark }` |
| 68 | Design Add and Search Words Data Structure | 211 | https://leetcode.com/problems/design-add-and-search-words-data-structure/ | Use a Trie structure (`TrieNode` with children and `isEndOfWord`). `addWord` is standard Trie insertion. `search(word)` needs modification: If char is '.', recursively call `search` on all non-null children of the current node and return true if any succeed. If char is a letter, follow the specific child branch. If path doesn't exist, return false. | Trie with modified search to handle '.' wildcard by exploring all children. | Trie / Design / DFS | O(L) add, O(N*26^L) search worst-case (.), N=nodes, L=len | O(Total Chars) for Trie | `boolean searchHelper(String word, int k, TrieNode node) { if (k == word.length()) return node.isEndOfWord; char ch = word.charAt(k); if (ch == '.') { for (TrieNode child : node.children) { if (child != null && searchHelper(word, k + 1, child)) return true; } return false; } else { // Standard Trie traversal } }` |
| 69 | Longest Valid Parentheses | 32 | https://leetcode.com/problems/longest-valid-parentheses/ | Stack approach: Push indices of '(' onto stack. When ')' is encountered: if stack not empty, pop index `start`. Length is `current_index - start + 1`. Update `maxLength`. Alternative DP: `dp[i]` = length of LVP *ending* at `i`. If `s[i] == ')'`: if `s[i-1] == '('`, `dp[i] = dp[i-2] + 2`. If `s[i-1] == ')'` and matching '(' exists at `i - dp[i-1] - 1`, `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`. | Stack stores indices to calculate length upon finding matching ')', or DP relation. | Stack / Dynamic Programming | O(n) | O(n) stack/DP array | `// Stack approach Stack<Integer> stack = new Stack<>(); stack.push(-1); // Base for length calculation for (int i=0; i<s.length(); ++i) { if (s.charAt(i) == '(') stack.push(i); else { stack.pop(); if (stack.isEmpty()) stack.push(i); // New base else maxLen = Math.max(maxLen, i - stack.peek()); } }` |
| 70 | Remove Invalid Parentheses | 301 | https://leetcode.com/problems/remove-invalid-parentheses/ | BFS Approach: Start BFS with the initial string. Use a queue and a set `visited` to avoid cycles. At each level, process strings from the queue. If a string is valid, add it to the result list. If result is found, stop exploring deeper levels (since we want minimum removals). Generate next level strings by removing one '(' or ')' from each current string and adding to queue if not visited. | Level-order BFS guarantees finding shortest paths (minimum removals) first. | BFS / String Manipulation | O(N * 2^N) worst case | O(N * 2^N) visited set | `Queue<String> queue; Set<String> visited; List<String> result; boolean found = false; while (!queue.isEmpty()) { String curr = queue.poll(); if (isValid(curr)) { result.add(curr); found = true; } if (found) continue; // Found min removals level for (int i = 0; i < curr.length(); i++) { // Generate next strings by removing one char... if (!visited.contains(nextStr)) { queue.offer(nextStr); visited.add(nextStr); } } }` |
| 71 | Combination Sum II | 40 | https://leetcode.com/problems/combination-sum-ii/ | Backtracking with sorting to handle duplicates. Sort `candidates`. Define `backtrack(startIndex, currentSum, currentList)`. Base cases: `currentSum == target` (add copy of `currentList`), `currentSum > target` (return). Loop `i` from `startIndex` to `n-1`. **Crucial**: If `i > startIndex && candidates[i] == candidates[i-1]`, continue (skip duplicate combination). Add `candidates[i]` to list, recurse `backtrack(i + 1, ...)`, backtrack (remove). | Sort + skip duplicates in backtracking loop (`i > startIndex`). Use `i+1` in recursion. | Backtracking / Recursion | O(2^N) | O(N) recursion depth | `Arrays.sort(candidates); // ... backtrack function ... for (int i = start; i < candidates.length; i++) { if (i > start && candidates[i] == candidates[i - 1]) continue; // Skip duplicates if (candidates[i] > remaining) break; // Pruning tempList.add(candidates[i]); backtrack(result, tempList, candidates, remaining - candidates[i], i + 1); // Use i+1 tempList.remove(tempList.size() - 1); }` |
| 72 | Move Zeroes | 283 | https://leetcode.com/problems/move-zeroes/ | Two Pointers (Slow/Fast or Read/Write). Initialize `writePointer = 0`. Iterate through array with `readPointer` from 0 to `n-1`. If `nums[readPointer]` is not zero, set `nums[writePointer] = nums[readPointer]` and increment `writePointer`. After loop, fill remaining positions from `writePointer` to `n-1` with zeros. | In-place modification using a write pointer for non-zero elements. | Array / Two Pointers | O(n) | O(1) | `int insertPos = 0; for (int num : nums) { if (num != 0) { nums[insertPos++] = num; } } while (insertPos < nums.length) { nums[insertPos++] = 0; }` |
| 73 | Minimum Size Subarray Sum | 209 | https://leetcode.com/problems/minimum-size-subarray-sum/ | Sliding Window. Initialize `start = 0`, `currentSum = 0`, `minLength = Integer.MAX_VALUE`. Iterate `end` from 0 to `n-1`. Add `nums[end]` to `currentSum`. While `currentSum >= target`: update `minLength = Math.min(minLength, end - start + 1)`, subtract `nums[start]` from `currentSum`, and increment `start`. Return `minLength` or 0 if not found. | Sliding window expands right, shrinks left when sum condition met. | Sliding Window / Two Pointers | O(n) | O(1) | `while (end < nums.length) { currentSum += nums[end]; while (currentSum >= target) { minLength = Math.min(minLength, end - start + 1); currentSum -= nums[start]; start++; } end++; }` |
| 74 | 3Sum Closest | 16 | https://leetcode.com/problems/3sum-closest/ | Sort array. Initialize `closestSum`. Iterate `i` from 0 to `n-3`. Use two pointers `left = i + 1`, `right = n - 1`. Calculate `currentSum = nums[i] + nums[left] + nums[right]`. If `abs(currentSum - target) < abs(closestSum - target)`, update `closestSum = currentSum`. If `currentSum == target`, return target. If `currentSum < target`, `left++`. Else `right--`. Skip duplicates for `i` not strictly needed but good practice. | Sort + Two Pointers, track sum closest to target. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) sort | `Arrays.sort(nums); int closestSum = nums[0] + nums[1] + nums[2]; // Initial guess for (int i = 0; i < nums.length - 2; i++) { int left = i + 1, right = nums.length - 1; while (left < right) { int currentSum = nums[i] + nums[left] + nums[right]; if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) { closestSum = currentSum; } if (currentSum < target) left++; else if (currentSum > target) right--; else return target; // Exact match } }` |
| 75 | 4Sum | 18 | https://leetcode.com/problems/4sum/ | Sort array. Use nested loops: outer loop `i`, inner loop `j`. Skip duplicates for `i` and `j`. Inside `j` loop, use two pointers `left = j + 1`, `right = n - 1` to find pairs summing to `target - nums[i] - nums[j]`. Calculate `currentSum`. If equal to target, add quadruplet, increment `left`, decrement `right`, skip duplicates for `left` and `right`. If `sum < target`, `left++`. If `sum > target`, `right--`. | Sort + Nested Loops + Two Pointers. Handle duplicates at all levels. | Two Pointers / Sorting | O(n^3) | O(log n) or O(n) sort | `// Outer loops for i, j (with duplicate checks) // Inner two pointers int twoSumTarget = target - nums[i] - nums[j]; int left = j + 1, right = n - 1; while (left < right) { int sum = nums[left] + nums[right]; if (sum == twoSumTarget) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // Skip duplicates for left & right left++; right--; } else if (sum < twoSumTarget) left++; else right--; }` |
| 76 | Palindrome Linked List | 234 | https://leetcode.com/problems/palindrome-linked-list/ | Find middle node using slow/fast pointers. Reverse the second half of the list starting from `middle.next`. Compare the first half (from `head`) with the reversed second half node by node. Restore list afterwards if needed (reverse second half again). | Find Mid -> Reverse 2nd Half -> Compare 1st and Reversed 2nd. | Linked List / Two Pointers | O(n) | O(1) | `ListNode mid = findMiddle(head); ListNode secondHead = reverse(mid.next); // mid.next = null if needed boolean isPalindrome = true; while (secondHead != null) { if (head.val != secondHead.val) { isPalindrome = false; break; } head = head.next; secondHead = secondHead.next; }` |
| 77 | Intersection of Two Linked Lists | 160 | https://leetcode.com/problems/intersection-of-two-linked-lists/ | Two Pointers approach: Initialize `pA = headA`, `pB = headB`. Traverse both. If `pA` reaches end, redirect it to `headB`. If `pB` reaches end, redirect it to `headA`. They will meet at the intersection node (or null if no intersection) after at most two passes through combined lists. | Pointers traverse both lists; switching heads aligns them for meeting at intersection. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode pA = headA, pB = headB; while (pA != pB) { pA = (pA == null) ? headB : pA.next; pB = (pB == null) ? headA : pB.next; } return pA; // Returns intersection node or null` |
| 78 | Invert Binary Tree | 226 | https://leetcode.com/problems/invert-binary-tree/ | Recursive DFS: Base case: if `node == null`, return null. Swap `node.left` and `node.right`. Recursively call `invertTree(node.left)` and `invertTree(node.right)`. Return `node`. Iterative BFS also works. | Recursively swap left and right children. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `if (root == null) return null; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root;` |
| 79 | Binary Tree Right Side View | 199 | https://leetcode.com/problems/binary-tree-right-side-view/ | BFS (Level Order Traversal). Use a queue. In each level, iterate through all nodes currently in the queue (`levelSize`). Keep track of the value of the *last* node processed at each level. Add this last node's value to the result list. | Level order traversal, adding the last node encountered at each level. | Tree / BFS | O(n) | O(w) max width | `Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (i == levelSize - 1) { result.add(node.val); // Add last element } if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } }` |
| 80 | Subtree of Another Tree | 572 | https://leetcode.com/problems/subtree-of-another-tree/ | Recursive approach. Define `isSubtree(root, subRoot)`. Base case: `subRoot` is null -> true. `root` is null -> false. Check if `root` and `subRoot` form the same tree using `isSameTree(root, subRoot)`. If yes, return true. Otherwise, return `isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)`. `isSameTree` checks equality recursively. | Check if same tree at current node OR if subtree exists in left OR right child. | Tree / Recursion / DFS | O(m*n) worst case, O(m+n) avg | O(h) recursion depth | `boolean isSameTree(TreeNode p, TreeNode q) { // Standard same tree check } boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); }` |
| 81 | Balanced Binary Tree | 110 | https://leetcode.com/problems/balanced-binary-tree/ | Recursive DFS. Helper function `checkHeight(node)` returns height if balanced, -1 otherwise. Base case: null node returns 0. Get left/right heights recursively. If either is -1 or `abs(leftH - rightH) > 1`, return -1. Else, return `1 + max(leftH, rightH)`. Main function checks if `checkHeight(root) != -1`. | Combine height calculation and balance check in one recursive pass. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int checkHeight(TreeNode node) { if (node == null) return 0; int leftH = checkHeight(node.left); if (leftH == -1) return -1; int rightH = checkHeight(node.right); if (rightH == -1) return -1; if (Math.abs(leftH - rightH) > 1) return -1; return 1 + Math.max(leftH, rightH); }` |
| 82 | Symmetric Tree | 101 | https://leetcode.com/problems/symmetric-tree/ | Recursive helper `isMirror(node1, node2)`. Checks if two trees are mirror images. Base cases: Both null -> true; one null -> false. Return `(node1.val == node2.val) && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left)`. Initial call: `isMirror(root.left, root.right)`. | Recursive comparison of left subtree with mirror image of right subtree. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `boolean isMirror(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }` |
| 83 | Populating Next Right Pointers in Each Node | 116 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ | Level Order Traversal (BFS) or Optimized Iterative/Recursive using existing `next`. BFS: Standard level order, connect `prev.next = current` within each level. Optimized Iterative (O(1) space): Use two pointers `levelStart` and `curr`. Iterate `levelStart` down levels. Inner loop uses `curr` to traverse current level using `next` pointers, setting `curr.left.next = curr.right` and `curr.right.next = curr.next != null ? curr.next.left : null`. | Use BFS or leverage perfect tree structure for O(1) space iteration using `next` pointers. | Tree / BFS / DFS | O(n) | O(w) BFS / O(1) optimized | `// Optimized Iterative (O(1) space) Node levelStart = root; while (levelStart != null && levelStart.left != null) { Node curr = levelStart; while (curr != null) { curr.left.next = curr.right; if (curr.next != null) curr.right.next = curr.next.left; curr = curr.next; } levelStart = levelStart.left; }` |
| 84 | Minimum Path Sum | 64 | https://leetcode.com/problems/minimum-path-sum/ | DP (Tabulation in-place). `grid[r][c]` stores min path sum to reach `(r, c)`. Initialize first row and first column based on previous cell. For other cells `(r, c)`, `grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])`. Result is `grid[m-1][n-1]`. | DP state `dp[r][c]` = min sum to reach cell `(r,c)`. In-place update. | Dynamic Programming | O(m*n) | O(1) (in-place) / O(m*n) memo | `for (int r = 0; r < m; r++) { for (int c = 0; c < n; c++) { if (r == 0 && c == 0) continue; else if (r == 0) grid[r][c] += grid[r][c-1]; else if (c == 0) grid[r][c] += grid[r-1][c]; else grid[r][c] += Math.min(grid[r-1][c], grid[r][c-1]); } }` |
| 85 | Coin Change II | 518 | https://leetcode.com/problems/coin-change-ii/ | DP (Unbounded Knapsack). `dp[i]` = number of ways to make amount `i`. Initialize `dp[0] = 1`. Iterate through each `coin` in `coins`. For each `coin`, iterate through amounts `j` from `coin` up to `amount`. Update `dp[j] = dp[j] + dp[j - coin]`. Result is `dp[amount]`. | DP state `dp[i]` = number of combinations for amount `i`. Outer loop coins, inner loop amounts. | Dynamic Programming | O(amount * coins) | O(amount) | `int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } }` |
| 86 | House Robber II | 213 | https://leetcode.com/problems/house-robber-ii/ | Reduce to two House Robber I problems. Because first and last houses cannot be robbed together, calculate max profit for `nums[0...n-2]` (excluding last) and max profit for `nums[1...n-1]` (excluding first). Return the maximum of these two results. Use standard House Robber I DP logic for subproblems. | Solve two subproblems excluding first/last house respectively. | Dynamic Programming | O(n) | O(1) (using optimized HR I) | `if (nums.length == 1) return nums[0]; int max1 = robHelper(nums, 0, nums.length - 2); int max2 = robHelper(nums, 1, nums.length - 1); return Math.max(max1, max2); // robHelper implements House Robber I DP` |
| 87 | Unique Paths II | 63 | https://leetcode.com/problems/unique-paths-ii/ | DP (Tabulation in-place or separate DP array). `dp[r][c]` = number of paths to `(r, c)`. If `obstacleGrid[r][c] == 1`, `dp[r][c] = 0`. Else, `dp[r][c] = dp[r-1][c] + dp[r][c-1]`. Handle first row/col initialization carefully considering obstacles. Start `dp[0][0] = 1` if no obstacle. | DP state `dp[r][c]` = unique paths to `(r,c)`. Set paths to 0 if obstacle. | Dynamic Programming | O(m*n) | O(m*n) or O(n) space | `dp[r][c] = 0; // If obstacleGrid[r][c] == 1 else if (r==0 && c==0) dp[r][c] = 1; else if (r==0) dp[r][c] = dp[r][c-1]; else if (c==0) dp[r][c] = dp[r-1][c]; else dp[r][c] = dp[r-1][c] + dp[r][c-1];` |
| 88 | Search a 2D Matrix | 74 | https://leetcode.com/problems/search-a-2d-matrix/ | Treat matrix as a sorted 1D array of size `m*n`. Perform standard binary search. Map 1D index `mid` back to 2D coordinates: `row = mid / cols`, `col = mid % cols`. Compare `matrix[row][col]` with target. | Binary search on flattened matrix indices. | Binary Search | O(log(m*n)) | O(1) | `int low = 0, high = rows * cols - 1; while (low <= high) { int mid = low + (high - low) / 2; int row = mid / cols; int col = mid % cols; if (matrix[row][col] == target) return true; else if (matrix[row][col] < target) low = mid + 1; else high = mid - 1; }` |
| 89 | Kth Smallest Element in a Sorted Matrix | 378 | https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ | Binary Search on value range `[matrix[0][0], matrix[m-1][n-1]]`. For a `mid` value, count elements `<= mid` using a staircase search (start top-right or bottom-left, O(m+n)). If `count < k`, search upper half (`low = mid + 1`). If `count >= k`, search lower half (`high = mid`), storing potential answer. | Binary search on answer range, count elements efficiently. | Binary Search / Matrix | O((m+n) * log(max-min)) | O(1) | `int countLE(int[][] matrix, int x) { // Staircase search O(m+n) } int low = matrix[0][0], high = matrix[rows-1][cols-1]; int ans = low; while (low <= high) { int mid = low + (high - low) / 2; if (countLE(matrix, mid) >= k) { ans = mid; high = mid - 1; } else { low = mid + 1; } }` |
| 90 | Rotting Oranges | 994 | https://leetcode.com/problems/rotting-oranges/ | Multi-source BFS. Initialize queue with all initial rotten oranges (2s). Keep track of `freshOranges` count. Perform BFS level by level. Each level signifies one minute. Dequeue rotten orange, explore 4 neighbors. If fresh neighbor (1) found, make it rotten (2), decrement `freshOranges`, enqueue neighbor. After BFS, return minutes elapsed if `freshOranges == 0`, else -1. | Multi-source BFS tracking levels (minutes) and remaining fresh count. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `// Initial pass: count fresh, add rotten to queue Queue<int[]> queue; int minutes = 0; while (!queue.isEmpty() && freshCount > 0) { int size = queue.size(); minutes++; for (int i=0; i<size; ++i) { // Dequeue, explore neighbors, rot fresh ones, decrement freshCount, enqueue new rotten } } return freshCount == 0 ? minutes : -1;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 91 | Surrounded Regions | 130 | https://leetcode.com/problems/surrounded-regions/ | DFS/BFS from borders. Iterate through border cells `(r, c)`. If `board[r][c] == 'O'`, start DFS/BFS and mark connected 'O's as 'E' (escaped). Then, iterate board again: 'O' → 'X' (surrounded), 'E' → 'O' (not surrounded). | Start from borders to find non-surrounded 'O's first, then flip remaining 'O's. | DFS / BFS / Graph | O(m*n) | O(m*n) recursion/queue | `void capture(char[][] board, int r, int c) { // DFS/BFS marking 'O' to 'E' } for (int r=0; r<rows; ++r) { if (board[r][0]=='O') capture(board,r,0); if (board[r][cols-1]=='O') capture(board,r,cols-1); } // ... top/bottom ... for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) { if (board[r][c]=='O') board[r][c]='X'; else if (board[r][c]=='E') board[r][c]='O'; }` |
| 92 | Shortest Path in Binary Matrix | 1091 | https://leetcode.com/problems/shortest-path-in-binary-matrix/ | BFS on grid. Queue stores `int[]{row, col}`. Use grid for visited/distance (set `grid[r][c] = distance`). Start from `(0,0)` with distance 1. Explore 8 neighbors. Return distance when `(n-1,n-1)` reached, or -1 if queue empty. Check `grid[0][0]` and `grid[n-1][n-1]` are 0. | BFS for shortest path in unweighted grid with 8-directional moves. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `Queue<int[]> queue = new LinkedList<>(); if (grid[0][0] == 1) return -1; queue.offer(new int[]{0, 0}); grid[0][0] = 1; int distance = 1; while (!queue.isEmpty()) { // Process level if (r == rows - 1 && c == cols - 1) return distance; // Explore 8 neighbors, set grid[nr][nc]=distance+1 }` |
| 93 | Cheapest Flights Within K Stops | 787 | https://leetcode.com/problems/cheapest-flights-within-k-stops/ | Modified Dijkstra. PriorityQueue stores `(cost, city, stops)`. Use `minCost[city][stops]` for pruning. Relax neighbors if `stops < k`. Alternatively, Bellman-Ford: relax edges `k+1` times with `newCosts` array. | Track stops in state to limit path length. | Graph / Dijkstra / Bellman-Ford | O(E + V log V) Dijkstra / O(k*E) Bellman-Ford | O(V*k) Dijkstra / O(V) Bellman-Ford | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); pq.offer(new int[]{0, src, 0}); int[][] minCost = new int[n][k + 2]; // Fill INF while (!pq.isEmpty()) { // Poll, relax neighbors if stops < k+1 }` |
| 94 | Network Delay Time | 743 | https://leetcode.com/problems/network-delay-time/ | Dijkstra's. Build adjacency list `Map<Integer, List<int[]>>`. Initialize `minTime[node]` with infinity, `minTime[k] = 0`. PriorityQueue stores `(time, node)`. Relax neighbors if shorter path found. Return max `minTime` or -1 if unreachable nodes exist. | Standard Dijkstra for shortest paths from source. | Graph / Dijkstra | O(E log V) | O(V+E) | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); int[] minTime = new int[n + 1]; Arrays.fill(minTime, Integer.MAX_VALUE); minTime[k] = 0; pq.offer(new int[]{0, k}); while (!pq.isEmpty()) { // Poll, relax neighbors }` |
| 95 | Design Tic-Tac-Toe | 348 | https://leetcode.com/problems/design-tic-tac-toe/ | O(1) move check. Use `rows[n]`, `cols[n]`, `diagonal1`, `diagonal2`. Player 1: +1, Player 2: -1. After move, check if `abs(rows[r]) == n`, `abs(cols[c]) == n`, or diagonals equal `n`. Return winner. | Sum row/col/diagonal to detect win in O(1). | Design / Array | O(1) per move | O(n) | `int[] rows; int[] cols; int diag1, diag2; int size; int move(int row, int col, int player) { int val = (player == 1) ? 1 : -1; rows[row] += val; cols[col] += val; if (row == col) diag1 += val; if (row + col == size - 1) diag2 += val; if (Math.abs(rows[row])==size || ...) return player; return 0; }` |
| 96 | Evaluate Reverse Polish Notation | 150 | https://leetcode.com/problems/evaluate-reverse-polish-notation/ | Stack-based. For each token: if number, push to stack; if operator, pop two numbers (op2, op1), compute `op1 op op2`, push result. Return final stack value. | Stack evaluates RPN by processing operators immediately. | Stack | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); for (String token : tokens) { if (isOperator(token)) { int op2 = stack.pop(); int op1 = stack.pop(); stack.push(evaluate(op1, op2, token)); } else { stack.push(Integer.parseInt(token)); } } return stack.pop();` |
| 97 | Basic Calculator | 224 | https://leetcode.com/problems/basic-calculator/ | Stack for parentheses. Track `result`, `number`, `sign`. For '(', push `result` and `sign`, reset `result`. For ')', compute expression, multiply by popped sign, add popped result. Add `number * sign` to result for digits. | Stack manages nested expressions and signs. | Stack / String | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int result = 0; int number = 0; int sign = 1; for (char c : s.toCharArray()) { if (c == '(') { stack.push(result); stack.push(sign); result = 0; sign = 1; } else if (c == ')') { result += sign * number; number = 0; result *= stack.pop(); result += stack.pop(); } }` |
| 98 | Basic Calculator II | 227 | https://leetcode.com/problems/basic-calculator-ii/ | No-Stack approach. Track `result`, `lastNum`, `currentNum`, `operation`. For '+' or '-': `result += lastNum`, update `lastNum`. For '*' or '/': update `lastNum = lastNum op currentNum`. Handle final number. | Process */ immediately, delay +/- by tracking last number. | Stack / String | O(n) | O(1) | `int result = 0, lastNum = 0, currentNum = 0; char operation = '+'; for (int i=0; i<s.length(); ++i) { if (!Character.isDigit(c) && c != ' ' || i == s.length() - 1) { if (operation == '+') { result += lastNum; lastNum = currentNum; } else if (operation == '-') { result += lastNum; lastNum = -currentNum; } else if (operation == '*') lastNum *= currentNum; else lastNum /= currentNum; operation = c; currentNum = 0; } } result += lastNum;` |
| 99 | Letter Combinations of a Phone Number | 17 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/ | Backtracking. Map digits to letters. Recurse with `backtrack(index, current)`. Base case: `index == digits.length()`, add `current`. For each letter of current digit, append and recurse. | Explore all letter combinations recursively. | Backtracking / Recursion / String | O(4^N * N) | O(N) recursion depth | `Map<Character, String> map; List<String> result; void backtrack(int index, StringBuilder current, String digits) { if (index == digits.length()) { result.add(current.toString()); return; } String letters = map.get(digits.charAt(index)); for (char c : letters.toCharArray()) { current.append(c); backtrack(index + 1, current, digits); current.deleteCharAt(current.length() - 1); } }` |
| 100 | K Closest Points to Origin | 973 | https://leetcode.com/problems/k-closest-points-to-origin/ | Max-Heap of size `k`. Store points in heap ordered by descending distance squared. For each point: add to heap; if size > k, poll max. Return heap contents. | Max-Heap maintains k smallest distances. | Heap (Priority Queue) / Sorting | O(N log k) | O(k) | `PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])); for (int[] point : points) { maxHeap.offer(point); if (maxHeap.size() > k) maxHeap.poll(); } int[][] result = new int[k][2]; while (k-- > 0) result[k] = maxHeap.poll();` |
| 101 | Squares of a Sorted Array | 977 | https://leetcode.com/problems/squares-of-a-sorted-array/ | Two pointers (`left=0`, `right=n-1`). Compare squares of `nums[left]` and `nums[right]`. Place larger square at end of result array (`k=n-1`). Move pointer with larger square inward. | Largest squares come from ends of sorted array. | Two Pointers | O(n) | O(n) | `int[] result = new int[n]; int left = 0, right = n - 1; for (int k = n - 1; k >= 0; k--) { if (Math.abs(nums[left]) > Math.abs(nums[right])) { result[k] = nums[left] * nums[left++]; } else { result[k] = nums[right] * nums[right--]; } }` |
| 102 | Max Consecutive Ones III | 1004 | https://leetcode.com/problems/max-consecutive-ones-iii/ | Sliding window. Track `zeroCount` in window. Expand `right` pointer, increment `zeroCount` for zeros. If `zeroCount > k`, shrink window (`left++`), decrement `zeroCount`. Update `maxLen`. | Track zeros in window to ensure at most k flips. | Sliding Window | O(n) | O(1) | `int left = 0, zeroCount = 0, maxLen = 0; for (int right = 0; right < nums.length; right++) { if (nums[right] == 0) zeroCount++; while (zeroCount > k) { if (nums[left] == 0) zeroCount--; left++; } maxLen = Math.max(maxLen, right - left + 1); }` |
| 103 | Contains Duplicate II | 219 | https://leetcode.com/problems/contains-duplicate-ii/ | HashMap stores last index of each number. For each `nums[i]`, check if in map and `i - map.get(nums[i]) <= k`. Update map with current index. | Map tracks indices to check distance constraint. | Hash Map / Sliding Window (implicit) | O(n) | O(min(n, k)) | `Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; i++) { if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k) return true; map.put(nums[i], i); } return false;` |
| 104 | Permutation in String | 567 | https://leetcode.com/problems/permutation-in-string/ | Sliding window with frequency arrays. Use `s1Count[26]` for `s1` and `s2Count[26]` for window in `s2`. Initialize window of `s1.length()`. Slide window, updating counts. Check if arrays equal. | Compare frequency arrays to detect permutation. | Sliding Window / Frequency Map | O(L1 + L2) | O(1) (alphabet size) | `int[] s1Count = new int[26]; int[] s2Count = new int[26]; for (char c : s1.toCharArray()) s1Count[c - 'a']++; for (int i = 0; i < s2.length(); i++) { s2Count[s2.charAt(i) - 'a']++; if (i >= s1.length()) s2Count[s2.charAt(i - s1.length()) - 'a']--; if (Arrays.equals(s1Count, s2Count)) return true; }` |
| 105 | Trapping Rain Water II | 407 | https://leetcode.com/problems/trapping-rain-water-ii/ | Min-Heap PriorityQueue with cells `(r, c, height)`. Add boundary cells to heap, mark visited. Poll min height cell, process neighbors. For each neighbor, water trapped = `max(0, currentHeight - neighborHeight)`. Update neighbor height and add to heap. | Min-Heap ensures processing cells by increasing height, simulating water flow. | Priority Queue / BFS variant | O(m*n log(m*n)) | O(m*n) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); boolean[][] visited = new boolean[m][n]; // Add boundary cells to pq while (!pq.isEmpty()) { int[] cell = pq.poll(); // Process neighbors, calculate water, update height }` |
| 106 | Swap Nodes in Pairs | 24 | https://leetcode.com/problems/swap-nodes-in-pairs/ | Iterative with dummy node. For each pair, swap `prev.next` and `prev.next.next`. Update pointers: `prev`, `first`, `second`. Connect to next pair. | Dummy node simplifies head case; swap pairs in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0, head); ListNode prev = dummy; while (prev.next != null && prev.next.next != null) { ListNode first = prev.next; ListNode second = first.next; prev.next = second; first.next = second.next; second.next = first; prev = first; }` |
| 107 | Reverse Linked List II | 92 | https://leetcode.com/problems/reverse-linked-list-ii/ | Locate `prev` (before segment), `start` (segment start), `end` (segment end), `next_group` (after segment). Reverse segment, connect `prev` to new head, old `start` to `next_group`. | Identify four key nodes and reverse segment in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for (int i = 1; i < left; i++) prev = prev.next; ListNode start = prev.next; ListNode end = start; for (int i = left; i < right; i++) end = end.next; ListNode next_group = end.next; // Reverse segment and connect` |
| 108 | Populating Next Right Pointers in Each Node II | 117 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ | Iterative O(1) space. Use `next` pointers of previous level to traverse current level. Maintain `levelHead` (dummy for next level) and `prev` to link nodes within level. | Use existing `next` pointers to avoid extra space. | Tree Traversal / Linked List | O(n) | O(1) | `Node dummy = new Node(0); Node levelHead = dummy; Node curr = root; while (curr != null) { while (curr != null) { if (curr.left != null) { levelHead.next = curr.left; levelHead = levelHead.next; } if (curr.right != null) { levelHead.next = curr.right; levelHead = levelHead.next; } curr = curr.next; } curr = dummy.next; dummy.next = null; levelHead = dummy; }` |
| 109 | Construct Tree from Given Inorder and Preorder Traversal | N/A | https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ | Recursive. Preorder’s first element is root. Find root in inorder to split left/right subtrees. Use HashMap for O(1) inorder lookup. Recurse on subtrees. | Preorder gives root; inorder splits subtrees. | Recursion / Tree Construction | O(n) | O(n) (map + recursion) | `Map<Integer, Integer> inorderMap = new HashMap<>(); for (int i = 0; i < inorder.length; i++) inorderMap.put(inorder[i], i); return buildTreeHelper(preorder, 0, preorder.length - 1, 0, inorder.length - 1, inorderMap);` |
| 110 | Reverse a Linked List in Groups of Given Size | N/A | https://www.geeksforgeeks.org/reverse-a-linked-list-in-groups-of-given-size/ | Iterative. Use dummy node. For each group of k nodes, check if exists, reverse, and connect `prevGroupEnd` to new head, old head to next group. | Reverse k nodes and reconnect segments. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prevGroupEnd = dummy; while (head != null) { ListNode groupStart = head; int count = 0; while (head != null && count < k) { head = head.next; count++; } if (count == k) { ListNode reversedHead = reverse(groupStart, k); prevGroupEnd.next = reversedHead; prevGroupEnd = groupStart; } }` |
| 111 | Knapsack Problem 0/1 | N/A | https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/ | DP Memoization. `dp(index, capacity)` = max value from `index` onwards with given capacity. Recurrence: max(include `values[index]` if possible, exclude). | State: (index, remaining capacity). | Dynamic Programming | O(n * capacity) | O(n * capacity) | `Map<String, Integer> memo = new HashMap<>(); int solve(int i, int capacity, int[] weights, int[] values) { if (i == weights.length || capacity == 0) return 0; String key = i + "-" + capacity; if (memo.containsKey(key)) return memo.get(key); int include = (weights[i] <= capacity) ? values[i] + solve(i + 1, capacity - weights[i], weights, values) : -1; int exclude = solve(i + 1, capacity, weights, values); memo.put(key, Math.max(include, exclude)); return memo.get(key); }` |
| 112 | Egg Dropping Puzzle | N/A | https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/ | DP Memoization. `dp(eggs, floors)` = min trials needed. For each floor k, max of `dp(eggs-1, k-1)` (breaks) and `dp(eggs, floors-k)` (survives). Minimize over k. | State: (eggs, floors); minimize max outcomes. | Dynamic Programming | O(eggs * floors^2) | O(eggs * floors) | `Map<String, Integer> memo = new HashMap<>(); int solve(int eggs, int floors) { if (floors <= 1) return floors; if (eggs == 1) return floors; String key = eggs + "-" + floors; if (memo.containsKey(key)) return memo.get(key); int minTrials = Integer.MAX_VALUE; for (int k = 1; k <= floors; k++) { int res = Math.max(solve(eggs - 1, k - 1), solve(eggs, floors - k)); minTrials = Math.min(minTrials, res); } memo.put(key, minTrials + 1); return minTrials + 1; }` |
| 113 | Search Insert Position | 35 | https://leetcode.com/problems/search-insert-position/ | Binary search. If target found, return index. Else, return `low` where search converges (insertion point). | Binary search finds exact or insertion position. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return low;` |
| 114 | Binary Search | 704 | https://leetcode.com/problems/binary-search/ | Standard binary search. Compare target with mid element, adjust `low` or `high`. Return index if found, -1 otherwise. | Classic divide-and-conquer on sorted array. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return -1;` |
| 115 | Search in Rotated Sorted Array II | 81 | https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ | Binary search handling duplicates. If `nums[mid] == nums[low] == nums[high]`, skip duplicates (`low++`, `high--`). Else, check which half is sorted and if target lies in it. | Handle duplicates by shrinking ambiguous cases. | Binary Search | O(log n) avg, O(n) worst | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return true; if (nums[mid] == nums[low] && nums[mid] == nums[high]) { low++; high--; continue; } // Check sorted half and target range }` |
| 116 | Middle of the Linked List | 876 | https://leetcode.com/problems/middle-of-the-linked-list/ | Slow and fast pointers. Slow moves one step, fast moves two. When fast reaches end, slow is at middle. | Fast pointer doubles speed to find middle. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;` |
| 117 | A Product Array Puzzle | N/A | https://www.geeksforgeeks.org/a-product-array-puzzle/ | Compute `left[i]` (product of `arr[0...i-1]`) and `right[i]` (product of `arr[i+1...n-1]`). Result `prod[i] = left[i] * right[i]`. Avoid division. | Precompute left and right products for each index. | Array Manipulation | O(n) | O(n) | `int[] left = new int[n]; int[] right = new int[n]; left[0] = 1; for (int i = 1; i < n; i++) left[i] = left[i-1] * arr[i-1]; right[n-1] = 1; for (int i = n-2; i >= 0; i--) right[i] = right[i+1] * arr[i+1]; int[] prod = new int[n]; for (int i = 0; i < n; i++) prod[i] = left[i] * right[i];` |
| 118 | Find the Smallest Window in a String Containing All Characters of Another String | N/A | https://www.geeksforgeeks.org/find-the-smallest-window-in-a-string-containing-all-characters-of-another-string/ | Sliding window. Use `patternMap` and `windowMap`. Expand window until valid (`formed == required`). Shrink from left, update min window if smaller. | Track matching characters with frequency maps. | Sliding Window / Frequency Map | O(S + T) | O(1) (alphabet size) | `Map<Character, Integer> patternMap = new HashMap<>(); Map<Character, Integer> windowMap = new HashMap<>(); int required = patternMap.size(); int formed = 0; int left = 0, minLen = Integer.MAX_VALUE, minStart = 0; for (int right = 0; right < s.length(); right++) { // Expand and shrink logic }` |
| 119 | Swapping Nodes in a Linked List | 1721 | https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ | Find k-th node from start (`kFromStart`) and k-th from end (`kFromEnd`) using two pointers. Swap their values. | Use two pointers to locate k-th from end efficiently. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; for (int i = 0; i < k-1; i++) fast = fast.next; ListNode kFromStart = fast; while (fast.next != null) { fast = fast.next; slow = slow.next; } ListNode kFromEnd = slow; int temp = kFromStart.val; kFromStart.val = kFromEnd.val; kFromEnd.val = temp;` |
| 120 | Odd Even Linked List | 328 | https://leetcode.com/problems/odd-even-linked-list/ | Maintain `oddPtr` and `evenPtr` to build odd and even lists. Connect odd nodes to odd, even to even. Link odd tail to even head. | Separate odd and even nodes, then reconnect. | Linked List Manipulation | O(n) | O(1) | `ListNode oddHead = head; ListNode evenHead = head.next; ListNode oddPtr = oddHead; ListNode evenPtr = evenHead; while (evenPtr != null && evenPtr.next != null) { oddPtr.next = evenPtr.next; oddPtr = oddPtr.next; evenPtr.next = oddPtr.next; evenPtr = evenPtr.next; } oddPtr.next = evenHead;` |
| 121 | Construct Binary Tree from String | 536 | https://leetcode.com/problems/construct-binary-tree-from-string/ | Recursive. Parse number as root. Find matching parentheses for left/right subtrees. Recurse on substrings. | Parse string, handle nested parentheses for subtrees. | Recursion / Tree Construction | O(n) | O(n) (recursion stack) | `int[] build(String s, int start) { // Returns [node, endIndex] // Parse number, find '(' and matching ')', recurse for left/right } TreeNode construct(String s) { return build(s, 0)[0]; }` |
| 122 | Lowest Common Ancestor of a Binary Tree II | 1644 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ | Recursive LCA. Track if `p` and `q` found. Return LCA only if both found. If node is `p` or `q`, check other in subtrees. | Verify `p` and `q` exist before returning LCA. | Tree Traversal / Recursion | O(n) | O(h) | `boolean[] found = new boolean[2]; TreeNode lca(TreeNode root, TreeNode p, TreeNode q) { TreeNode result = lcaHelper(root, p, q); return found[0] && found[1] ? result : null; } TreeNode lcaHelper(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; if (root == p) { found[0] = true; return root; } if (root == q) { found[1] = true; return root; } TreeNode left = lcaHelper(root.left, p, q); TreeNode right = lcaHelper(root.right, p, q); if (left != null && right != null) return root; return left != null ? left : right; }` |
| 123 | Lowest Common Ancestor of a Binary Tree III | 1650 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ | Use parent pointers. Traverse from `p` to root, store in `Set`. Traverse from `q`, return first node in `Set`. | Parent pointers allow path tracing to find intersection. | Tree Traversal / Hash Set | O(h) | O(h) | `Set<Node> visited = new HashSet<>(); while (p != null) { visited.add(p); p = p.parent; } while (q != null) { if (visited.contains(q)) return q; q = q.parent; } return null;` |
| 124 | Check if a Binary Tree is Subtree of Another Binary Tree | N/A | https://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/ | Recursive. Check if tree rooted at each node of `T` is identical to `S`. Use `isIdentical` helper to compare trees. | Traverse `T`, check identity with `S` at each node. | Tree Traversal / Recursion | O(m*n) worst, O(n) avg | O(max(h_T, h_S)) | `boolean isIdentical(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return t1.val == t2.val && isIdentical(t1.left, t2.left) && isIdentical(t1.right, t2.right); } boolean isSubtree(TreeNode T, TreeNode S) { if (T == null) return false; if (isIdentical(T, S)) return true; return isSubtree(T.left, S) || isSubtree(T.right, S); }` |
| 125 | Flattening a Linked List | N/A | https://www.geeksforgeeks.org/flattening-a-linked-list/ | Recursive. Flatten `next` list, merge current `down` list with flattened result using sorted merge. | Merge sorted `down` lists recursively. | Linked List / Recursion | O(N * M) | O(N) (recursion) | `Node merge(Node list1, Node list2) { // Standard merge sorted lists } Node flatten(Node root) { if (root == null || root.next == null) return root; root.next = flatten(root.next); return merge(root, root.next); }` |
| 126 | Subset Sum Problem | N/A | https://www.geeksforgeeks.org/subset-sum-problem-dp-25/ | DP Memoization. `dp(index, target)` = can `target` be formed from `index` onwards. Recurrence: include or exclude `arr[index]`. | State: (index, target sum); try include/exclude. | Dynamic Programming | O(n * target_sum) | O(n * target_sum) | `Map<String, Boolean> memo = new HashMap<>(); boolean solve(int i, int target, int[] arr) { if (target == 0) return true; if (i == arr.length) return false; String key = i + "-" + target; if (memo.containsKey(key)) return memo.get(key); boolean include = arr[i] <= target ? solve(i + 1, target - arr[i], arr) : false; boolean exclude = solve(i + 1, target, arr); memo.put(key, include || exclude); return memo.get(key); }` |
| 127 | Partition Problem | N/A | https://www.geeksforgeeks.org/partition-problem-dp-18/ | Subset Sum variant. If total sum is even, check if subset with `totalSum / 2` exists using Subset Sum DP. | Reduce to Subset Sum with target = totalSum / 2. | Dynamic Programming | O(n * total_sum) | O(n * total_sum) | `int totalSum = 0; for (int num : arr) totalSum += num; if (totalSum % 2 != 0) return false; return solve(0, totalSum / 2, arr, new HashMap<>()); // Subset Sum logic` |
| 128 | Minimum Coins Make Given Value | N/A | https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-given-value/ | DP Memoization. `dp(value)` = min coins for `value`. Recurrence: min(1 + `dp(value - coin)`) for valid coins. | State: remaining value; try each coin. | Dynamic Programming | O(target_value * num_coins) | O(target_value) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int value, int[] coins) { if (value == 0) return 0; if (value < 0) return -1; if (memo.containsKey(value)) return memo.get(value); int minCoins = Integer.MAX_VALUE; for (int coin : coins) { int res = solve(value - coin, coins); if (res != -1) minCoins = Math.min(minCoins, res + 1); } memo.put(value, minCoins == Integer.MAX_VALUE ? -1 : minCoins); return memo.get(value); }` |
| 129 | Matrix Chain Multiplication | N/A | https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/ | DP Memoization. `dp(i, j)` = min multiplications for matrices `i` to `j`. Recurrence: min(`dp(i, k) + dp(k+1, j) + p[i-1]*p[k]*p[j]`) for k. | State: (start, end indices); try all splits. | Dynamic Programming | O(n^3) | O(n^2) | `int[][] memo; int solve(int i, int j, int[] p) { if (i == j) return 0; if (memo[i][j] != -1) return memo[i][j]; int minCost = Integer.MAX_VALUE; for (int k = i; k < j; k++) { int cost = solve(i, k, p) + solve(k + 1, j, p) + p[i - 1] * p[k] * p[j]; minCost = Math.min(minCost, cost); } return memo[i][j] = minCost; }` |
| 130 | Maximum Sum Increasing Subsequence | N/A | https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/ | DP. `dp[i]` = max sum of increasing subsequence ending at `i`. For each `i`, check `j < i` where `arr[i] > arr[j]`, update `dp[i]`. | Iterate previous indices for increasing property. | Dynamic Programming | O(n^2) | O(n) | `int[] dp = new int[n]; for (int i = 0; i < n; i++) dp[i] = arr[i]; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (arr[i] > arr[j]) dp[i] = Math.max(dp[i], dp[j] + arr[i]); } } int maxSum = 0; for (int sum : dp) maxSum = Math.max(maxSum, sum);` |
| 131 | Minimum Insertion Steps to Make a String Palindrome | N/A | https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindromic-string-dp-28/ | DP. Find Longest Palindromic Subsequence (LPS). Result = `s.length() - LPS`. `dp(i, j)` = LPS length for `s[i..j]`. Recurrence: if `s[i] == s[j]`, `2 + dp(i+1, j-1)`; else, max of subproblems. | Use LPS to compute min insertions. | Dynamic Programming | O(n^2) | O(n^2) | `int[][] memo; int lps(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != 0) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) return memo[i][j] = 2 + lps(s, i + 1, j - 1); return memo[i][j] = Math.max(lps(s, i + 1, j), lps(s, i, j - 1)); } // Result: s.length() - lps(s, 0, s.length() - 1)` |
| 132 | Search an Element in a Sorted and Pivoted Array | N/A | https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/ | Binary search. Check if left or right half is sorted. If target lies in sorted half, search there; else, search other half. | Identify sorted portion and narrow search. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[low] <= nums[mid] && target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; }` |
| 133 | Find the Maximum j – i Such that arr[j] > arr[i] | N/A | https://www.geeksforgeeks.org/find-the-maximum-j-i-such-that-arrj-arri/ | Create `LMin[i]` (min from 0 to i) and `RMax[j]` (max from j to n-1). Use two pointers `i`, `j`. If `RMax[j] > LMin[i]`, try next `j`; else, next `i`. Track max `j-i`. | Precompute min/max arrays, use two pointers. | Array / Two Pointers | O(n) | O(n) | `int[] LMin = new int[n]; int[] RMax = new int[n]; LMin[0] = arr[0]; for (int i = 1; i < n; i++) LMin[i] = Math.min(arr[i], LMin[i-1]); RMax[n-1] = arr[n-1]; for (int j = n-2; j >= 0; j--) RMax[j] = Math.max(arr[j], RMax[j+1]); int i = 0, j = 0, maxDiff = -1; while (i < n && j < n) { if (RMax[j] > LMin[i]) { maxDiff = Math.max(maxDiff, j - i); j++; } else i++; }` |
| 134 | Insert into a Sorted Circular Linked List | 708 | https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/ | Find insertion point: where `node.val <= insertVal <= node.next.val`, or at list’s “break” (max to min), or if all equal. Insert new node. Handle empty/single node cases. | Handle sorted segment, break point, and equal values. | Linked List / Circular | O(n) | O(1) | `if (head == null) { Node newNode = new Node(insertVal); newNode.next = newNode; return newNode; } Node curr = head; while (true) { if (curr.val <= insertVal && insertVal <= curr.next.val || curr.val > curr.next.val && (insertVal >= curr.val || insertVal <= curr.next.val)) { Node newNode = new Node(insertVal); newNode.next = curr.next; curr.next = newNode; break; } curr = curr.next; if (curr == head) break; }` |
| 135 | Binary Tree Upside Down | 156 | https://leetcode.com/problems/binary-tree-upside-down/ | Iterative. Left child becomes root, root becomes right child, right child becomes left child. Use pointers `curr`, `prev`, `next` to transform bottom-up. | Transform tree level by level using pointer updates. | Tree Transformation | O(n) | O(1) | `Node curr = root; Node prev = null; Node next = null; while (curr != null) { next = curr.left; curr.left = prev; prev = curr.right; curr.right = curr; curr = next; } return prev;` |
| 136 | Boundary Traversal of Binary Tree | N/A | https://www.geeksforgeeks.org/boundary-traversal-of-binary-tree/ | Traverse left boundary (top-down, exclude leaf), leaves (inorder), right boundary (bottom-up, exclude leaf). Handle duplicates and single-node cases. | Split into three traversals, avoid duplicate leaves. | Tree Traversal | O(n) | O(h) | `void leftBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; result.add(node.val); leftBoundary(node.left != null ? node.left : node.right, result); } void leaves(TreeNode node, List<Integer> result) { if (node == null) return; if (node.left == null && node.right == null) result.add(node.val); leaves(node.left, result); leaves(node.right, result); } void rightBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; rightBoundary(node.right != null ? node.right : node.left, result); result.add(node.val); }` |
| 137 | Clone a Binary Tree with Random Pointers | N/A | https://www.geeksforgeeks.org/clone-binary-tree-with-random-pointers/ | Two-pass. First: create nodes and map original to clones. Second: set `left`, `right`, `random` pointers using map. | Map ensures correct pointer assignments. | Tree Traversal / Hash Map | O(n) | O(n) | `Map<Node, Node> map = new HashMap<>(); Node clone(Node root) { if (root == null) return null; if (map.containsKey(root)) return map.get(root); Node newNode = new Node(root.val); map.put(root, newNode); newNode.left = clone(root.left); newNode.right = clone(root.right); newNode.random = clone(root.random); return newNode; }` |
| 138 | Convert an Arbitrary Binary Tree to a Tree that Holds Children Sum Property | N/A | https://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/ | Post-order. Recurse on children. If node value < children sum, set node value to sum. If node value > sum, increase children to match (propagate down). | Adjust node or children values post-order. | Tree Traversal / Recursion | O(n^2) worst case | O(h) | `void convert(Node node) { if (node == null || (node.left == null && node.right == null)) return; convert(node.left); convert(node.right); int childSum = (node.left != null ? node.left.val : 0) + (node.right != null ? node.right.val : 0); if (node.val <= childSum) node.val = childSum; else incrementChildren(node, node.val - childSum); } void incrementChildren(Node node, int diff) { if (node.left != null) node.left.val += diff; else if (node.right != null) node.right.val += diff; }` |
| 139 | Print Nodes at Distance k from Given Node in Binary Tree | N/A | https://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root/ | Two parts: nodes k distance below target (DFS), and nodes k distance via ancestors (track distance to target, print in other subtree). | Handle downward and ancestor paths separately. | Tree Traversal / Recursion | O(n) | O(h) | `int printKDistance(Node root, Node target, int k) { if (root == null) return -1; if (root == target) { printBelow(root, k); return 0; } int leftDist = printKDistance(root.left, target, k); if (leftDist != -1) { if (leftDist + 1 == k) System.out.println(root.val); else printBelow(root.right, k - leftDist - 2); return leftDist + 1; } // Similar for right subtree } void printBelow(Node node, int k) { if (node == null || k < 0) return; if (k == 0) System.out.println(node.val); printBelow(node.left, k-1); printBelow(node.right, k-1); }` |
| 140 | Longest Bitonic Subsequence | N/A | https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/ | DP. Compute `lis[i]` (LIS ending at i) and `lds[i]` (LDS starting at i). Max bitonic length = `lis[i] + lds[i] - 1` for any i. | Combine LIS and LDS through each index. | Dynamic Programming | O(n^2) | O(n) | `int[] lis = new int[n]; int[] lds = new int[n]; for (int i = 0; i < n; i++) lis[i] = 1; for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j]) lis[i] = Math.max(lis[i], lis[j] + 1); for (int i = 0; i < n; i++) lds[i] = 1; for (int i = n-2; i >= 0; i--) for (int j = n-1; j > i; j--) if (arr[i] > arr[j]) lds[i] = Math.max(lds[i], lds[j] + 1); int maxLen = 0; for (int i = 0; i < n; i++) maxLen = Math.max(maxLen, lis[i] + lds[i] - 1);` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 141 | Rod Cutting | N/A | https://www.geeksforgeeks.org/cutting-a-rod-dp-13/ | Dynamic Programming (Memoization). Define `dp(length)` as max value for rod of length `length`. Recurrence: `dp(l) = max(price[i] + dp(l - i - 1))` for `i` from 0 to `l-1` (cuts of length `i+1`). Base case: `dp(0) = 0`. | State is remaining rod length. Maximize value by trying all possible first cuts. | Dynamic Programming (Memoization) | O(n^2) | O(n) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int length, int[] price) { if (length == 0) return 0; if (memo.containsKey(length)) return memo.get(length); int maxVal = Integer.MIN_VALUE; for (int i = 0; i < length; i++) maxVal = Math.max(maxVal, price[i] + solve(length - (i + 1), price)); memo.put(length, maxVal); return maxVal; }` |
| 142 | Min Cost Path | N/A | https://www.geeksforgeeks.org/min-cost-path-dp-6/ | Dynamic Programming (Memoization). Define `dp(r, c)` as min cost to reach `(r, c)` from `(0, 0)`. Recurrence: `dp(r, c) = grid[r][c] + min(dp(r-1, c), dp(r, c-1), dp(r-1, c-1))`. Base case: `dp(0, 0) = grid[0][0]`. Handle boundaries. | State is current cell. Minimize cost from valid neighbors (up, left, diagonal). | Dynamic Programming, Grid Traversal | O(rows * cols) | O(rows * cols) | `int[][] memo; int solve(int r, int c, int[][] grid) { if (r < 0 || c < 0) return Integer.MAX_VALUE; if (r == 0 && c == 0) return grid[0][0]; if (memo[r][c] != -1) return memo[r][c]; int minPrevCost = Math.min(Math.min(solve(r - 1, c, grid), solve(r, c - 1, grid)), solve(r - 1, c - 1, grid)); return memo[r][c] = grid[r][c] + minPrevCost; }` |
| 143 | Maximize Greatness of an Array | 2592 | https://leetcode.com/problems/maximize-greatness-of-an-array/ | Sort array. Use two pointers: `p1` for permuted array, `p2` for original sorted array. For each `nums[p1]`, find smallest `nums[p2]` where `nums[p2] > nums[p1]`. Increment greatness and both pointers if found, else advance `p2`. | Greedy: pair each element with smallest greater element. | Sorting, Two Pointers, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); int p1 = 0, p2 = 0, greatness = 0; while (p1 < nums.length && p2 < nums.length) { if (p2 < nums.length && nums[p2] > nums[p1]) { greatness++; p1++; p2++; } else p2++; } return greatness;` |
| 144 | Count Complete Subarrays in an Array | 2799 | https://leetcode.com/problems/count-complete-subarrays-in-an-array/ | Find `k` (distinct elements in array). Use sliding window with frequency map. Expand until window has `k` distinct elements. Count subarrays ending at `right` starting from `left` or later. Shrink `left` and repeat. | Count valid subarrays by tracking distinct elements in window. | Sliding Window, Frequency Map | O(n) | O(D) | `int distinctCount = new HashSet<>(Arrays.asList(Arrays.stream(nums).boxed().toArray())).size(); Map<Integer, Integer> windowFreq = new HashMap<>(); int left = 0, count = 0; for (int right = 0; right < nums.length; right++) { windowFreq.put(nums[right], windowFreq.getOrDefault(nums[right], 0) + 1); while (windowFreq.size() == distinctCount) { count += nums.length - right; windowFreq.put(nums[left], windowFreq.get(nums[left]) - 1); if (windowFreq.get(nums[left]) == 0) windowFreq.remove(nums[left]); left++; } } return count;` |
| 145 | Maximum Number of Upgradable Servers | 1947 | https://leetcode.com/problems/maximum-number-of-upgradable-servers/ | Recursive DP on tree/graph. For each server, compute max upgradable servers in subtree for two states: upgraded or not. Use memoization to store results. Consider dependencies (parent must be upgraded). | State: (server, isUpgraded). Recurse on children, aggregate results. | Dynamic Programming, Tree/Graph Traversal | O(n) | O(n) | `Map<Integer, int[]> memo; int[] solve(int serverId, int parentId, List<List<Integer>> adj, int[] cost, int[] value) { if (memo.containsKey(serverId)) return memo.get(serverId); int[] result = new int[2]; // [upgraded, notUpgraded] // Recurse on children, compute max for both states return result; }` |
| 146 | Double a Number Represented as a Linked List | 2816 | https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/ | Recursive approach. Process list from right to left via recursion. Double each digit, handle carry. Return carry for previous digit. Use dummy node for potential leading digit. | Recurse to process least significant digits first, propagate carry. | Linked List, Recursion | O(n) | O(n) | `int doubleHelper(ListNode node) { if (node == null) return 0; int carry = doubleHelper(node.next); int newVal = node.val * 2 + carry; node.val = newVal % 10; return newVal / 10; } ListNode doubleIt(ListNode head) { int carry = doubleHelper(head); if (carry > 0) { ListNode newHead = new ListNode(carry); newHead.next = head; return newHead; } return head; }` |
| 147 | Merge In Between Linked Lists | 1669 | https://leetcode.com/problems/merge-in-between-linked-lists/ | Locate node at `a-1` and `b` in `list1`. Find `list2` head and tail. Connect `a-1` to `list2` head, `list2` tail to `b.next`. | Identify and relink four key pointers. | Linked List Manipulation | O(a + b) | O(1) | `ListNode nodeBeforeA = head; for (int i = 0; i < a - 1; i++) nodeBeforeA = nodeBeforeA.next; ListNode nodeB = head; for (int i = 0; i < b; i++) nodeB = nodeB.next; ListNode list2Tail = list2; while (list2Tail.next != null) list2Tail = list2Tail.next; nodeBeforeA.next = list2; list2Tail.next = nodeB.next;` |
| 148 | Valid Anagram | 242 | https://leetcode.com/problems/valid-anagram/ | Use frequency array for lowercase letters. Increment counts for `s`, decrement for `t`. Check if all counts are zero. | Identical character frequencies indicate anagrams. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (char c : t.toCharArray()) count[c - 'a']--; for (int i : count) if (i != 0) return false; return true;` |
| 149 | Longest Consecutive Sequence | 128 | https://leetcode.com/problems/longest-consecutive-sequence/ | Use HashSet for O(1) lookups. For each number, if it’s a sequence start (`num-1` not in set), count consecutive numbers (`num+1`, `num+2`, ...). Track max length. | Only count from sequence starts to avoid redundant work. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) set.add(num); int maxLen = 0; for (int num : nums) { if (!set.contains(num - 1)) { int currentNum = num; int currentLen = 0; while (set.contains(currentNum)) { currentLen++; currentNum++; } maxLen = Math.max(maxLen, currentLen); } } return maxLen;` |
| 150 | Find the Duplicate Number | 287 | https://leetcode.com/problems/find-the-duplicate-number/ | Floyd’s Tortoise and Hare. Treat array as linked list (`index i` points to `nums[i]`). Find cycle meeting point, then cycle start (duplicate). | Array forms a cycle due to duplicate. Cycle start is the duplicate. | Cycle Detection | O(n) | O(1) | `int tortoise = nums[0]; int hare = nums[0]; do { tortoise = nums[tortoise]; hare = nums[nums[hare]]; } while (tortoise != hare); tortoise = nums[0]; while (tortoise != hare) { tortoise = nums[tortoise]; hare = nums[hare]; } return hare;` |
| 151 | Kth Largest Element in an Array | 215 | https://leetcode.com/problems/kth-largest-element-in-an-array/ | QuickSelect. Partition around pivot. If pivot position is `n-k`, return pivot. If less, recurse right; if greater, recurse left. | Partition to narrow search for kth largest. | QuickSelect | O(n) avg | O(log n) | `int quickSelect(int[] nums, int low, int high, int k) { int pivot = partition(nums, low, high); if (pivot == nums.length - k) return nums[pivot]; if (pivot < nums.length - k) return quickSelect(nums, pivot + 1, high, k); return quickSelect(nums, low, pivot - 1, k); }` |
| 152 | Find Median from Data Stream | 295 | https://leetcode.com/problems/find-median-from-data-stream/ | Use max-heap for lower half, min-heap for upper half. Keep max-heap size equal or one more than min-heap. Median is max-heap top or average of both tops. | Two heaps split data for O(log n) insertion, O(1) median. | Two Heaps | O(log n) add, O(1) median | O(n) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); void addNum(int num) { maxHeap.offer(num); minHeap.offer(maxHeap.poll()); if (maxHeap.size() < minHeap.size()) maxHeap.offer(minHeap.poll()); } double findMedian() { return maxHeap.size() > minHeap.size() ? maxHeap.peek() : (maxHeap.peek() + minHeap.peek()) / 2.0; }` |
| 153 | Valid Palindrome | 125 | https://leetcode.com/problems/valid-palindrome/ | Two pointers from start and end. Skip non-alphanumeric, compare lowercase alphanumeric chars. | Ignore non-alphanumeric, case-insensitive comparison. | Two Pointers, String | O(n) | O(1) | `int left = 0, right = s.length() - 1; while (left < right) { char l = s.charAt(left), r = s.charAt(right); if (!Character.isLetterOrDigit(l)) left++; else if (!Character.isLetterOrDigit(r)) right--; else if (Character.toLowerCase(l) != Character.toLowerCase(r)) return false; else { left++; right--; } } return true;` |
| 154 | Longest Common Prefix | 14 | https://leetcode.com/problems/longest-common-prefix/ | Compare chars at same index across all strings. Stop at mismatch or end of any string. | First mismatch determines prefix length. | String | O(S) | O(1) | `if (strs.length == 0) return ""; for (int i = 0; i < strs[0].length(); i++) { char c = strs[0].charAt(i); for (int j = 1; j < strs.length; j++) { if (i >= strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); } } return strs[0];` |
| 155 | Regular Expression Matching | 10 | https://leetcode.com/problems/regular-expression-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `.` and `*`. If `*`, try zero or more matches. Else, check direct match. | Recurrence based on pattern chars and `*`. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '.' || pattern.charAt(j) == text.charAt(i))); if (j + 1 < pattern.length() && pattern.charAt(j + 1) == '*') return memo[i][j] = (solve(text, pattern, i, j + 2) || (firstMatch && solve(text, pattern, i + 1, j))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 156 | Wildcard Matching | 44 | https://leetcode.com/problems/wildcard-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `?` and `*`. If `*`, try zero or more chars. If `?` or char match, advance both. | Recurrence based on `?` and `*` handling. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; if (pattern.charAt(j) == '*') return memo[i][j] = (solve(text, pattern, i, j + 1) || (i < text.length() && solve(text, pattern, i + 1, j))); boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '?' || pattern.charAt(j) == text.charAt(i))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 157 | First Unique Character in a String | 387 | https://leetcode.com/problems/first-unique-character-in-a-string/ | Use frequency array. Count char occurrences in first pass. In second pass, return index of first char with count 1. | Two passes: count frequencies, find first unique. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (int i = 0; i < s.length(); i++) if (count[s.charAt(i) - 'a'] == 1) return i; return -1;` |
| 158 | Intersection of Two Arrays | 349 | https://leetcode.com/problems/intersection-of-two-arrays/ | HashSet for `nums1`. Check `nums2` elements in set, add to result set, remove from set to avoid duplicates. | Set for O(1) lookups, ensure unique results. | Hash Set | O(m + n) | O(min(m, n)) | `Set<Integer> set1 = new HashSet<>(); for (int num : nums1) set1.add(num); Set<Integer> resultSet = new HashSet<>(); for (int num : nums2) if (set1.contains(num)) resultSet.add(num); return resultSet.toArray(new Integer[0]);` |
| 159 | Intersection of Two Arrays II | 350 | https://leetcode.com/problems/intersection-of-two-arrays-ii/ | HashMap for `nums1` frequencies. For `nums2`, add to result if count > 0, decrement count. | Frequency map handles duplicates correctly. | Hash Map | O(m + n) | O(min(m, n)) | `Map<Integer, Integer> freq = new HashMap<>(); for (int num : nums1) freq.put(num, freq.getOrDefault(num, 0) + 1); List<Integer> resultList = new ArrayList<>(); for (int num : nums2) if (freq.containsKey(num) && freq.get(num) > 0) { resultList.add(num); freq.put(num, freq.get(num) - 1); } return resultList.stream().mapToInt(i -> i).toArray();` |
| 160 | Sliding Window Median | 480 | https://leetcode.com/problems/sliding-window-median/ | Two heaps: max-heap for lower half, min-heap for upper half. Add/remove elements as window slides, balance heaps. Median from heap tops. | Heaps maintain sorted window for O(log k) updates. | Sliding Window, Two Heaps | O(n log k) | O(k) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); for (int i = 0; i < nums.length; i++) { // Add nums[i], remove nums[i-k], balance, compute median }` |
| 161 | Find K Pairs with Smallest Sums | 373 | https://leetcode.com/problems/find-k-pairs-with-smallest-sums/ | Min-PQ with `(sum, i, j)`. Start with `(nums1[i] + nums2[0], i, 0)`. Extract min, add to result, push next pair `(nums1[i] + nums2[j+1], i, j+1)` if valid. Repeat k times. | PQ explores sums in order, next pair from same `i`. | Priority Queue | O(k log k) | O(k) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); for (int i = 0; i < Math.min(k, nums1.length); i++) pq.offer(new int[]{nums1[i] + nums2[0], i, 0}); List<List<Integer>> result = new ArrayList<>(); while (k-- > 0 && !pq.isEmpty()) { int[] curr = pq.poll(); result.add(Arrays.asList(nums1[curr[1]], nums2[curr[2]])); if (curr[2] + 1 < nums2.length) pq.offer(new int[]{nums1[curr[1]] + nums2[curr[2] + 1], curr[1], curr[2] + 1}); }` |
| 162 | Kth Largest Element in a Stream | 703 | https://leetcode.com/problems/kth-largest-element-in-a-stream/ | Min-PQ of size `k`. Add new number, if size > `k`, remove smallest. Top is kth largest. | Min-heap maintains k largest elements. | Priority Queue | O(log k) per add | O(k) | `PriorityQueue<Integer> pq; int k; KthLargest(int k, int[] nums) { this.k = k; pq = new PriorityQueue<>(); for (int num : nums) { pq.offer(num); if (pq.size() > k) pq.poll(); } } int add(int val) { pq.offer(val); if (pq.size() > k) pq.poll(); return pq.peek(); }` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 163 | String to Integer (atoi) | 8 | https://leetcode.com/problems/string-to-integer-atoi/ | Parse the string character by character: skip leading whitespace, read optional sign ('+' or '-'), then read digits until a non-digit or end of string. Convert digits to integer by multiplying current result by 10 and adding new digit. Check for overflow before each multiplication to prevent exceeding Integer.MAX_VALUE or Integer.MIN_VALUE. | Check for overflow before multiplying by 10 (e.g., if result > Integer.MAX_VALUE / 10, or equal and next digit > 7). Handle edge cases like empty strings or invalid inputs. | String Parsing, Edge Cases | O(n) | O(1) | `int index = 0, sign = 1, result = 0; while (index < s.length() && s.charAt(index) == ' ') index++; if (index < s.length() && (s.charAt(index) == '+' || s.charAt(index) == '-')) { sign = s.charAt(index) == '+' ? 1 : -1; index++; } while (index < s.length() && Character.isDigit(s.charAt(index))) { int digit = s.charAt(index) - '0'; if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; result = result * 10 + digit; index++; } return result * sign;` |
| 164 | Reverse Words in a String | 151 | https://leetcode.com/problems/reverse-words-in-a-string/ | Trim leading/trailing spaces, split string by one or more spaces using regex `\\s+`. Reverse the resulting array of words, then join with a single space. Handle cases with multiple consecutive spaces or empty strings. | Use `trim()` and `split("\\s+")` to handle multiple spaces efficiently. Reverse the word array in-place or via Collections.reverse for simplicity. | String Manipulation, Array Reversal | O(n) | O(n) | `String[] words = s.trim().split("\\s+"); Collections.reverse(Arrays.asList(words)); return String.join(" ", words);` |
| 165 | Valid Palindrome II | 680 | https://leetcode.com/problems/valid-palindrome-ii/ | Use two pointers starting from string ends. If characters match, move pointers inward. On mismatch, check if skipping either the left or right character results in a palindrome by calling a helper function to verify the remaining substring. | Allow one character skip by testing both options (skip left or right) on mismatch. Use a helper function to avoid duplicating palindrome check logic. | Two Pointers, String Manipulation | O(n) | O(1) | `boolean isPalindrome(String s, int left, int right) { while (left < right) if (s.charAt(left++) != s.charAt(right--)) return false; return true; } int left = 0, right = s.length() - 1; while (left < right) { if (s.charAt(left) != s.charAt(right)) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); left++; right--; } return true;` |
| 166 | Reverse String | 344 | https://leetcode.com/problems/reverse-string/ | Use two pointers: one at the start, one at the end of the char array. Swap characters at these pointers and move them toward the center until they meet. Perform swaps in-place to avoid extra space. | In-place swap using a temporary variable ensures O(1) space. Move pointers only when necessary to minimize operations. | Two Pointers, Array Manipulation | O(n) | O(1) | `int left = 0, right = s.length - 1; while (left < right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; }` |
| 167 | Encode and Decode Strings | 271 | https://leetcode.com/problems/encode-and-decode-strings/ | Encode: For each string, prepend its length followed by '#' delimiter, then append the string itself. Concatenate all encoded strings. Decode: Parse the encoded string by reading the length up to '#', then extract that many characters as a string. Repeat until the input is consumed. | Use length prefix with a delimiter to uniquely identify string boundaries. Ensure parsing handles empty strings and varying lengths. | String Serialization | O(N) | O(N) | `public String encode(List<String> strs) { StringBuilder sb = new StringBuilder(); for (String s : strs) sb.append(s.length()).append("#").append(s); return sb.toString(); } public List<String> decode(String s) { List<String> result = new ArrayList<>(); int i = 0; while (i < s.length()) { int j = i; while (s.charAt(j) != '#') j++; int len = Integer.parseInt(s.substring(i, j)); result.add(s.substring(j + 1, j + 1 + len)); i = j + 1 + len; } return result; }` |
| 168 | Decode String | 394 | https://leetcode.com/problems/decode-string/ | Use two stacks: one for counts, one for partial strings. Iterate through the string: for digits, build the count; for '[', push current count and string, reset them; for ']', pop count and string, repeat current string count times, append to popped string; for letters, append to current string. | Stacks handle nested brackets by saving state (count and partial string) at each '['. Pop and process on ']'. | Stack, String Manipulation | O(n * m) | O(n) | `Stack<Integer> countStack = new Stack<>(); Stack<StringBuilder> stringStack = new Stack<>(); StringBuilder currentString = new StringBuilder(); int k = 0; for (char c : s.toCharArray()) { if (Character.isDigit(c)) k = k * 10 + (c - '0'); else if (c == '[') { countStack.push(k); stringStack.push(currentString); k = 0; currentString = new StringBuilder(); } else if (c == ']') { StringBuilder temp = currentString; currentString = stringStack.pop(); int count = countStack.pop(); for (int i = 0; i < count; i++) currentString.append(temp); } else currentString.append(c); } return currentString.toString();` |
| 169 | Interleaving String | 97 | https://leetcode.com/problems/interleaving-string/ | Use dynamic programming with memoization. Define `dp(i, j)` as a boolean indicating if `s1[0..i-1]` and `s2[0..j-1]` interleave to form `s3[0..i+j-1]`. Recurrence: true if `s1[i-1] == s3[i+j-1]` and `dp(i-1, j)` is true, or `s2[j-1] == s3[i+j-1]` and `dp(i, j-1)` is true. Base case: `dp(0, 0) = true`. | Memoize to avoid recomputing overlapping subproblems. Check both sources (`s1` or `s2`) for each `s3` character. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String s1, String s2, String s3, int i, int j) { int k = i + j; if (k == s3.length()) return i == s1.length() && j == s2.length(); if (i > s1.length() || j > s2.length()) return false; if (memo[i][j] != null) return memo[i][j]; boolean res = false; if (i < s1.length() && s1.charAt(i) == s3.charAt(k)) res = solve(s1, s2, s3, i + 1, j); if (!res && j < s2.length() && s2.charAt(j) == s3.charAt(k)) res = solve(s1, s2, s3, i, j + 1); return memo[i][j] = res; } boolean isInterleave(String s1, String s2, String s3) { if (s1.length() + s2.length() != s3.length()) return false; memo = new Boolean[s1.length() + 1][s2.length() + 1]; return solve(s1, s2, s3, 0, 0); }` |
| 170 | Find the Difference | 389 | https://leetcode.com/problems/find-the-difference/ | Use a frequency array for lowercase letters. Increment counts for `s`, decrement for `t`. The character with a count of -1 is the added character in `t`. Alternatively, XOR all characters in `s` and `t` to find the differing character. | Negative count in frequency array directly identifies the added character. XOR cancels paired characters, leaving the extra one. | Frequency Map, Bit Manipulation | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (char c : t.toCharArray()) { count[c - 'a']--; if (count[c - 'a'] < 0) return c; } return ' ';` |
| 171 | Kth Smallest Product of Two Sorted Arrays | 2040 | https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/ | Binary search on the product range (e.g., [-10^10, 10^10]). For each candidate `mid`, count pairs `(nums1[i], nums2[j])` with product <= `mid` using two pointers, handling positive and negative numbers separately. Adjust search range based on whether count is >= `k`. | Efficiently count pairs <= `mid` by leveraging sorted arrays and two pointers for each quadrant (positive/negative combinations). | Binary Search, Two Pointers | O((m + n) log(max_val)) | O(1) | `long countPairsLessThanOrEqual(int[] nums1, int[] nums2, long target) { long count = 0; for (int i = 0; i < nums1.length; i++) { int j = nums2.length - 1; if (nums1[i] > 0) while (j >= 0 && (long) nums1[i] * nums2[j] > target) j--; else if (nums1[i] < 0) { j = 0; while (j < nums2.length && (long) nums1[i] * nums2[j] > target) j++; count += nums2.length - j; } else if (target >= 0) count += nums2.length; } return count; } long low = -10_000_000_001L, high = 10_000_000_001L; long ans = high; while (low <= high) { long mid = low + (high - low) / 2; long count = countPairsLessThanOrEqual(nums1, nums2, mid); if (count >= k) { ans = mid; high = mid - 1; } else low = mid + 1; } return ans;` |
| 172 | Shortest Palindrome | 214 | https://leetcode.com/problems/shortest-palindrome/ | Find the longest palindromic prefix using KMP’s LPS array on `s + "#" + reverse(s)`. The last LPS value gives the length of the longest palindromic prefix. Prepend the reverse of the remaining suffix to `s`. | KMP’s LPS array efficiently computes the longest palindromic prefix by treating the problem as a pattern matching task. | String, KMP | O(n) | O(n) | `int[] computeLPS(String s) { int[] lps = new int[s.length()]; int len = 0, i = 1; while (i < s.length()) { if (s.charAt(i) == s.charAt(len)) lps[i++] = ++len; else if (len > 0) len = lps[len - 1]; else lps[i++] = 0; } return lps; } String reversedS = new StringBuilder(s).reverse().toString(); String temp = s + "#" + reversedS; int[] lps = computeLPS(temp); int len = lps[temp.length() - 1]; return reversedS.substring(0, s.length() - len) + s;` |
| 173 | Text Justification | 68 | https://leetcode.com/problems/text-justification/ | Greedy: For each line, fit as many words as possible within `maxWidth`. Calculate gaps and distribute spaces: base spaces per gap, extra spaces left to right. Last line is left-justified with single spaces and padded with spaces to `maxWidth`. Handle single-word lines. | Compute total spaces and gaps, distribute evenly, and handle special cases (last line, single word) separately. | String, Array | O(L) | O(L) | `List<String> result = new ArrayList<>(); int index = 0; while (index < words.length) { int count = words[index].length(), last = index + 1; while (last < words.length && count + 1 + words[last].length() <= maxWidth) { count += 1 + words[last].length(); last++; } StringBuilder line = new StringBuilder(); if (last == words.length || last - index == 1) { for (int i = index; i < last; i++) line.append(words[i]).append(" "); while (line.length() < maxWidth) line.append(" "); } else { int gaps = last - index - 1; int totalSpaces = maxWidth - (count - gaps); int baseSpaces = totalSpaces / gaps; int extraSpaces = totalSpaces % gaps; for (int i = index; i < last; i++) { line.append(words[i]); if (i < last - 1) for (int j = 0; j < baseSpaces + (i - index < extraSpaces ? 1 : 0); j++) line.append(" "); } } result.add(line.toString().substring(0, maxWidth)); index = last; } return result;` |
| 174 | String Compression | 443 | https://leetcode.com/problems/string-compression/ | Use two pointers: `read` to scan characters, `write` to place compressed result. Count consecutive repeating characters, write the character, and if count > 1, write its digits. Modify array in-place and return new length. | In-place modification requires careful index management. Convert count to chars for multi-digit counts. | Two Pointers, String | O(n) | O(1) | `int write = 0, read = 0; while (read < chars.length) { char currentChar = chars[read]; int count = 0; while (read < chars.length && chars[read] == currentChar) { read++; count++; } chars[write++] = currentChar; if (count > 1) for (char digit : Integer.toString(count).toCharArray()) chars[write++] = digit; } return write;` |
| 175 | Longest Common Prefix Using Sorting | N/A | https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/ | Sort the array of strings. The longest common prefix is the common prefix of the first and last strings in the sorted array, as they bound the lexicographical range. Compare characters until mismatch or end. | Sorting ensures the prefix is common to all strings, as it’s shared by the lexicographically smallest and largest strings. | Sorting, String | O(n log n * m) | O(1) | `if (strs.length == 0) return ""; Arrays.sort(strs); String s1 = strs[0]; String s2 = strs[strs.length - 1]; int i = 0; while (i < s1.length() && i < s2.length() && s1.charAt(i) == s2.charAt(i)) i++; return s1.substring(0, i);` |
| 176 | Group Shifted Strings | 249 | https://leetcode.com/problems/group-shifted-strings/ | For each string, compute a shift pattern by calculating the difference (mod 26) between consecutive characters, starting from the first character. Use a HashMap to group strings by their pattern. Return grouped lists. | Normalize shifts by subtracting the first character’s value (mod 26) to create a canonical pattern. Empty strings have an empty pattern. | Hash Map, String | O(N * L) | O(N * L) | `Map<String, List<String>> map = new HashMap<>(); for (String s : strings) { StringBuilder pattern = new StringBuilder(); if (s.length() > 0) for (int i = 1; i < s.length(); i++) pattern.append((s.charAt(i) - s.charAt(0) + 26) % 26).append("#"); map.computeIfAbsent(pattern.toString(), k -> new ArrayList<>()).add(s); } return new ArrayList<>(map.values());` |
| 177 | Valid Word Abbreviation | 408 | https://leetcode.com/problems/valid-word-abbreviation/ | Use two pointers: one for word, one for abbreviation. If characters match, advance both. If abbreviation has a digit, read the full number (handle leading zeros), skip that many characters in word. Ensure both pointers reach their ends. | Parse multi-digit numbers in abbreviation and validate no leading zeros. Check word length matches after skips. | Two Pointers, String | O(w + a) | O(1) | `int wordPtr = 0, abbrPtr = 0; while (abbrPtr < abbr.length()) { if (wordPtr < word.length() && abbr.charAt(abbrPtr) == word.charAt(wordPtr)) { wordPtr++; abbrPtr++; } else if (Character.isDigit(abbr.charAt(abbrPtr))) { if (abbr.charAt(abbrPtr) == '0') return false; int num = 0; while (abbrPtr < abbr.length() && Character.isDigit(abbr.charAt(abbrPtr))) num = num * 10 + (abbr.charAt(abbrPtr++) - '0'); wordPtr += num; } else return false; } return wordPtr == word.length();` |
| 178 | String Transformation | 2750 | https://leetcode.com/problems/string-transformation/ | Check if `s` can transform to `t` via consistent character mapping. Use two HashMaps: `sToT` maps characters from `s` to `t`, `tToS` ensures one-to-one or many-to-one mapping. Verify lengths match and mappings are consistent. | Ensure bidirectional consistency in mappings to detect invalid transformations (e.g., one `s` char mapping to multiple `t` chars). | Hash Map, String | O(n) | O(1) | `if (s.length() != t.length()) return false; Map<Character, Character> sToT = new HashMap<>(); Map<Character, Character> tToS = new HashMap<>(); for (int i = 0; i < s.length(); i++) { char c1 = s.charAt(i), c2 = t.charAt(i); if (!sToT.containsKey(c1)) sToT.put(c1, c2); if (!tToS.containsKey(c2)) tToS.put(c2, c1); if (sToT.get(c1) != c2 || tToS.get(c2) != c1) return false; } return true;` |
| 179 | Count Vowel Substrings of a String | 2062 | https://leetcode.com/problems/count-vowel-substrings-of-a-string/ | Use nested loops to generate substrings. For each substring, track vowels using a set. If the substring contains only vowels and all five vowels (`a, e, i, o, u`), increment count. Break early if a non-vowel is encountered. | Early termination on non-vowels reduces unnecessary checks. Set ensures all five vowels are present in O(1) lookup. | String, Frequency Set | O(n^2) | O(1) | `int count = 0; Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u')); for (int i = 0; i < word.length(); i++) { Set<Character> currentVowels = new HashSet<>(); for (int j = i; j < word.length(); j++) { char c = word.charAt(j); if (!vowels.contains(c)) break; currentVowels.add(c); if (currentVowels.size() == 5) count++; } } return count;` |
| 180 | Add Two Integers | 2235 | https://leetcode.com/problems/add-two-integers/ | Perform standard integer addition using the `+` operator. Constraints ensure no overflow for typical 32-bit integers. | No special trick; direct addition suffices given problem constraints. | Arithmetic | O(1) | O(1) | `return num1 + num2;` |
| 181 | Add Binary | 67 | https://leetcode.com/problems/add-binary/ | Add binary strings from right to left, maintaining a carry. For each position, sum the digits (if any) and carry, append `sum % 2` to result, update carry as `sum / 2`. Reverse the result string. | Simulate manual binary addition, handling different string lengths and carry propagation. | String, Arithmetic | O(max(a.length(), b.length())) | O(max(a.length(), b.length())) | `StringBuilder result = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1, carry = 0; while (i >= 0 || j >= 0 || carry > 0) { int sum = carry; if (i >= 0) sum += a.charAt(i--) - '0'; if (j >= 0) sum += b.charAt(j--) - '0'; result.append(sum % 2); carry = sum / 2; } return result.reverse().toString();` |
| 182 | Multiply Strings | 43 | https://leetcode.com/problems/multiply-strings/ | Simulate digit-by-digit multiplication. Use an array to store intermediate results, where index `i+j` and `i+j+1` hold the product of digits at positions `i` and `j`. Process carries and convert to string, skipping leading zeros. | Use an array to manage place values and carries, avoiding direct string manipulation until the end. | String, Arithmetic | O(m*n) | O(m + n) | `int[] product = new int[num1.length() + num2.length()]; for (int i = num1.length() - 1; i >= 0; i--) { for (int j = num2.length() - 1; j >= 0; j--) { int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + product[p2]; product[p2] = sum % 10; product[p1] += sum / 10; } } StringBuilder sb = new StringBuilder(); for (int num : product) if (!(sb.length() == 0 && num == 0)) sb.append(num); return sb.length() == 0 ? "0" : sb.toString();` |
| 183 | Divide Two Integers | 29 | https://leetcode.com/problems/divide-two-integers/ | Use bitwise shifts to subtract multiples of the divisor from the dividend. Convert to long to avoid overflow, handle signs separately, and check for edge cases like `Integer.MIN_VALUE / -1`. | Bitwise left shifts allow subtracting large multiples of the divisor, reducing iterations. | Arithmetic, Bit Manipulation | O(log N) | O(1) | `long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); long quotient = 0; int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1; while (ldividend >= ldivisor) { long temp = ldivisor, multiple = 1; while (ldividend >= (temp << 1)) { temp <<= 1; multiple <<= 1; } ldividend -= temp; quotient += multiple; } quotient *= sign; if (quotient > Integer.MAX_VALUE) return Integer.MAX_VALUE; if (quotient < Integer.MIN_VALUE) return Integer.MIN_VALUE; return (int) quotient;` |
| 184 | Pow(x, n) | 50 | https://leetcode.com/problems/powx-n/ | Use binary exponentiation: if `n` is even, `x^n = (x^(n/2))^2`; if odd, `x^n = x * (x^(n/2))^2`. For negative `n`, compute `1/x` and make `n` positive. Handle edge cases like `n = 0`. | Exponentiation by squaring reduces the number of multiplications to O(log n). | Arithmetic, Recursion | O(log |n|) | O(log |n|) | `double myPow(double x, int n) { if (n == 0) return 1.0; if (n < 0) { x = 1.0 / x; if (n == Integer.MIN_VALUE) return x * myPow(x, Integer.MAX_VALUE); n = -n; } if (n % 2 == 0) return myPow(x * x, n / 2); else return x * myPow(x * x, n / 2); }` |
| 185 | Sqrt(x) | 69 | https://leetcode.com/problems/sqrtx/ | Binary search on `[0, x]` to find the largest integer `mid` such that `mid * mid <= x`. Use `long` for `mid * mid` to prevent overflow. Return the floor of the square root. | Binary search efficiently narrows down to the integer square root, handling large inputs. | Binary Search | O(log x) | O(1) | `int low = 0, high = x; int ans = 0; while (low <= high) { long mid = low + (high - low) / 2; long square = mid * mid; if (square == x) return (int) mid; if (square < x) { ans = (int) mid; low = mid + 1; } else high = mid - 1; } return ans;` |
| 186 | Reverse Integer | 7 | https://leetcode.com/problems/reverse-integer/ | Extract digits one by one using modulo and division. Build reversed number by multiplying current result by 10 and adding the digit. Check for overflow before each step. | Check overflow before multiplying by 10 to prevent exceeding integer bounds. | Arithmetic | O(log |x|) | O(1) | `long reversed = 0; while (x != 0) { int digit = x % 10; x /= 10; reversed = reversed * 10 + digit; if (reversed > Integer.MAX_VALUE || reversed < Integer.MIN_VALUE) return 0; } return (int) reversed;` |
| 187 | Palindrome Number | 9 | https://leetcode.com/problems/palindrome-number/ | Reverse the second half of the number and compare with the first half. Handle negative numbers (not palindromes) and numbers ending in 0 (only 0 is a palindrome). Stop reversing when the original number is less than or equal to the reversed part. | Reverse only half the number to avoid full reversal, handling both even and odd digit counts. | Arithmetic | O(log n) | O(1) | `if (x < 0 || (x % 10 == 0 && x != 0)) return false; int reversedHalf = 0; while (x > reversedHalf) { reversedHalf = reversedHalf * 10 + x % 10; x /= 10; } return x == reversedHalf || x == reversedHalf / 10;` |
| 188 | Power of Two | 231 | https://leetcode.com/problems/power-of-two/ | Check if `n` is positive and has exactly one set bit using `n & (n - 1) == 0`. A power of two has only one bit set in its binary representation. | Bitwise operation `n & (n - 1)` removes the least significant set bit, making it zero for powers of two. | Bit Manipulation | O(1) | O(1) | `return n > 0 && (n & (n - 1)) == 0;` |
| 189 | Power of Three | 326 | https://leetcode.com/problems/power-of-three/ | Repeatedly divide `n` by 3 until it’s no longer divisible or becomes 1. If it becomes 1, `n` is a power of three. Handle non-positive numbers. | Iterative division by 3 is simple and effective. Alternatively, check if `n` divides the largest power of 3 within integer range. | Arithmetic | O(log_3 n) | O(1) | `if (n <= 0) return false; while (n % 3 == 0) n /= 3; return n == 1;` |
| 190 | Power of Four | 342 | https://leetcode.com/problems/power-of-four/ | Check if `n` is a power of two (`n > 0 && n & (n - 1) == 0`) and satisfies `n % 3 == 1`, as powers of four (1, 4, 16, ...) are congruent to 1 mod 3. | Combine power-of-two check with modulo 3 to distinguish powers of four from other powers of two. | Bit Manipulation | O(1) | O(1) | `return n > 0 && (n & (n - 1)) == 0 && (n % 3 == 1);` |
| 191 | Valid Perfect Square | 367 | https://leetcode.com/problems/valid-perfect-square/ | Binary search on `[1, num]` to find an integer `mid` such that `mid * mid == num`. Use `long` to prevent overflow in `mid * mid`. Return true if found, false otherwise. | Binary search ensures exact match for perfect squares, handling large inputs efficiently. | Binary Search | O(log num) | O(1) | `if (num < 0) return false; if (num <= 1) return true; long low = 1, high = num; while (low <= high) { long mid = low + (high - low) / 2; long square = mid * mid; if (square == num) return true; if (square < num) low = mid + 1; else high = mid - 1; } return false;` |
| 192 | Sum of Square Numbers | 633 | https://leetcode.com/problems/sum-of-square-numbers/ | Use two pointers: `left` starts at 0, `right` at `sqrt(c)`. Compute `left^2 + right^2`. If equal to `c`, return true; if less, increment `left`; if more, decrement `right`. Use `long` to prevent overflow. | Two pointers efficiently explore all possible square sums, leveraging the bounded range `[0, sqrt(c)]`. | Two Pointers | O(sqrt(c)) | O(1) | `int left = 0; int right = (int) Math.sqrt(c); while (left <= right) { long sum = (long) left * left + (long) right * right; if (sum == c) return true; if (sum < c) left++; else right--; } return false;` |
| 193 | Count Primes | 204 | https://leetcode.com/problems/count-primes/ | Use Sieve of Eratosthenes: initialize a boolean array up to `n` as true, mark 0 and 1 as non-prime, and for each prime `p`, mark its multiples starting from `p*p` as non-prime. Count remaining primes. | Start marking multiples from `p*p` since smaller multiples are already marked by smaller primes. | Sieve | O(n log log n) | O(n) | `if (n <= 2) return 0; boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int p = 2; p * p < n; p++) if (isPrime[p]) for (int i = p * p; i < n; i += p) isPrime[i] = false; int count = 0; for (int i = 2; i < n; i++) if (isPrime[i]) count++; return count;` |
| 194 | Add Digits | 258 | https://leetcode.com/problems/add-digits/ | Use the digital root formula: if `num > 0`, result is `(num - 1) % 9 + 1`; if `num == 0`, result is 0. This computes the single-digit sum of digits in O(1). | Digital root leverages congruence modulo 9, avoiding iterative digit summation. | Arithmetic | O(1) | O(1) | `if (num == 0) return 0; return (num - 1) % 9 + 1;` |
| 195 | Fizz Buzz | 412 | https://leetcode.com/problems/fizz-buzz/ | Iterate from 1 to `n`. Check divisibility: if divisible by 15, append “FizzBuzz”; by 3, “Fizz”; by 5, “Buzz”; else, the number as a string. Store results in a list. | Check divisibility by 15 first to handle the combined case efficiently. | Iteration | O(n) | O(n) | `List<String> result = new ArrayList<>(); for (int i = 1; i <= n; i++) { if (i % 15 == 0) result.add("FizzBuzz"); else if (i % 3 == 0) result.add("Fizz"); else if (i % 5 == 0) result.add("Buzz"); else result.add(Integer.toString(i)); } return result;` |
| 196 | Number of 1 Bits | 191 | https://leetcode.com/problems/number-of-1-bits/ | Use Brian Kernighan’s algorithm: repeatedly unset the least significant set bit using `n & (n - 1)` and count iterations until `n` is 0. | `n & (n - 1)` removes the rightmost set bit, making it faster than checking each bit. | Bit Manipulation | O(k) | O(1) | `int count = 0; while (n != 0) { n = n & (n - 1); count++; } return count;` |
| 197 | Reverse Bits | 190 | https://leetcode.com/problems/reverse-bits/ | Iterate 32 times: left shift the result, add the least significant bit of `n` using `n & 1`, and right shift `n` (unsigned). | Use unsigned right shift (`>>>`) to handle sign extension correctly for negative numbers. | Bit Manipulation | O(1) | O(1) | `int reversed = 0; for (int i = 0; i < 32; i++) { reversed <<= 1; reversed |= (n & 1); n >>>= 1; } return reversed;` |
| 198 | Sum of Two Integers | 371 | https://leetcode.com/problems/sum-of-two-integers/ | Use bitwise operations: `x ^ y` computes sum without carry, `(x & y) << 1` computes carry. Repeat until carry is 0, updating `x` as sum and `y` as carry. | XOR handles bit addition, AND with left shift captures carry, iterating until no carry remains. | Bit Manipulation | O(log n) | O(1) | `while (y != 0) { int carry = x & y; x = x ^ y; y = carry << 1; } return x;` |
| 199 | Factor Combinations | 254 | https://leetcode.com/problems/factor-combinations/ | Use backtracking: recurse on remaining number `num` starting from a minimum factor `startFactor`. If `num` is divisible by `i`, add `i` to current combination, recurse on `num/i` with `i` as new minimum. Backtrack by removing `i`. Add combination when `num == 1`. | Start from `startFactor` to ensure non-decreasing order and avoid duplicates. Check up to `sqrt(num)` for efficiency. | Recursion, Backtracking | O(k * 2^k) | O(log n) | `List<List<Integer>> result = new ArrayList<>(); void findFactors(List<List<Integer>> result, List<Integer> current, int num, int startFactor) { if (num == 1 && current.size() > 0) { result.add(new ArrayList<>(current)); return; } for (int i = startFactor; i <= Math.sqrt(num) || i == num; i++) if (num % i == 0) { current.add(i); findFactors(result, current, num / i, i); current.remove(current.size() - 1); } } findFactors(result, new ArrayList<>(), n, 2); return result;` |
| 200 | Binomial Coefficient | N/A | https://www.geeksforgeeks.org/binomial-coefficient-dp-9/ | Use dynamic programming based on Pascal’s Identity: `C(n, k) = C(n-1, k-1) + C(n-1, k)`. Build a 2D DP table where `dp[i][j]` is `C(i, j)`. Base cases: `C(i, 0) = C(i, i) = 1`. | Pascal’s Triangle structure allows efficient computation by reusing previous values. | Dynamic Programming | O(n*k) | O(n*k) | `int[][] dp = new int[n + 1][k + 1]; for (int i = 0; i <= n; i++) { for (int j = 0; j <= Math.min(i, k); j++) { if (j == 0 || j == i) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } } return dp[n][k];` |
| 201 | Check if Given Number is Perfect Square | N/A | https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ | Compute the integer square root using `Math.sqrt()`, cast to `long`, and check if squaring it equals the original number. Alternatively, use binary search for exact integer square root. | Casting `sqrt` to `long` avoids floating-point precision issues. Binary search is an alternative for precision. | Arithmetic | O(1) | O(1) | `long root = (long) Math.sqrt(num); return root * root == num;` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 202 | Minimum Number of Squares Whose Sum Equals to Given Number N | N/A | https://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/ | Use dynamic programming with memoization. Define `dp(n)` as the minimum number of perfect squares summing to `n`. For each `n`, iterate over all perfect squares `i*i <= n`, compute `1 + dp(n - i*i)`, and take the minimum. Base cases: `dp(0) = 0`, `dp(negative) = infinity`. Memoize results to avoid recomputation. Alternatively, use bottom-up DP for O(1) space. | Iterate only up to `sqrt(n)` for perfect squares to reduce iterations. Use `Integer.MAX_VALUE` to handle invalid cases and avoid overflow in comparisons. | Dynamic Programming (Memoization) | O(n * sqrt(n)) | O(n) | `int[] memo = new int[n + 1]; Arrays.fill(memo, -1); int solve(int k) { if (k == 0) return 0; if (k < 0) return Integer.MAX_VALUE; if (memo[k] != -1) return memo[k]; int minSquares = Integer.MAX_VALUE; for (int i = 1; i * i <= k; i++) { int next = solve(k - i * i); if (next != Integer.MAX_VALUE) minSquares = Math.min(minSquares, 1 + next); } return memo[k] = minSquares; } return solve(n);` |
| 203 | Count Ways To Reach The Nth Stair | N/A | https://www.geeksforgeeks.org/count-ways-reach-nth-stair/ | Use dynamic programming with memoization. Define `dp(k)` as the number of ways to reach stair `k` using 1 or 2 steps. Recurrence: `dp(k) = dp(k-1) + dp(k-2)`. Base cases: `dp(0) = 1`, `dp(1) = 1`. Memoize to avoid recomputation. Alternatively, use iterative DP with O(1) space for Fibonacci-like sequence. | Recognize as Fibonacci sequence shifted by one (dp(0) = 1). Use modulo 10^9+7 if large outputs are expected. | Dynamic Programming (Memoization), Fibonacci Sequence | O(n) | O(n) | `int[] memo = new int[n + 1]; Arrays.fill(memo, -1); int solve(int k) { if (k == 0 || k == 1) return 1; if (memo[k] != -1) return memo[k]; return memo[k] = (solve(k - 1) + solve(k - 2)) % 1000000007; } return solve(n);` |
| 204 | Fibonacci Number | 509 | https://leetcode.com/problems/fibonacci-number/ | Calculate the n-th Fibonacci number using dynamic programming with memoization. Define `fib(i)` as the i-th Fibonacci number: `fib(i) = fib(i-1) + fib(i-2)`. Base cases: `fib(0) = 0`, `fib(1) = 1`. Memoize to avoid recomputation. For efficiency, use iterative DP with O(1) space. | Use iterative approach with two variables to achieve O(1) space, avoiding stack overflow for large `n`. | Dynamic Programming (Iterative), Fibonacci Sequence | O(n) | O(1) | `if (n == 0) return 0; if (n == 1) return 1; int prev2 = 0, prev1 = 1; for (int i = 2; i <= n; i++) { int curr = prev1 + prev2; prev2 = prev1; prev1 = curr; } return prev1;` |
| 205 | Fibonacci Numbers | N/A | https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ | Same as Fibonacci Number (204). Calculate the n-th Fibonacci number using iterative dynamic programming for optimal space. Define `fib(i) = fib(i-1) + fib(i-2)`. Base cases: `fib(0) = 0`, `fib(1) = 1`. Use two variables to track previous values. | Iterative approach with O(1) space is more efficient than memoization for large `n`. Apply modulo 10^9+7 if needed. | Dynamic Programming (Iterative), Fibonacci Sequence | O(n) | O(1) | `if (n == 0) return 0; if (n == 1) return 1; int prev2 = 0, prev1 = 1; for (int i = 2; i <= n; i++) { int curr = prev1 + prev2; prev2 = prev1; prev1 = curr; } return prev1;` |
| 206 | Maximum Odd Binary Number | 2864 | https://leetcode.com/problems/maximum-odd-binary-number/ | To maximize an odd binary number, place one '1' at the rightmost position (least significant bit). Count total '1's and '0's in the input string. Place remaining '1's (count-1) at the leftmost positions, followed by all '0's, then the final '1'. | Ensure oddness by fixing the last bit as '1'. Maximize value by placing other '1's at higher-order bits. | String Manipulation, Counting | O(n) | O(n) | `int ones = 0; for (char c : s.toCharArray()) if (c == '1') ones++; StringBuilder sb = new StringBuilder(); for (int i = 0; i < ones - 1; i++) sb.append('1'); for (int i = 0; i < s.length() - ones; i++) sb.append('0'); sb.append('1'); return sb.toString();` |
| 207 | Calculate Amount Paid in Taxes | 2303 | https://leetcode.com/problems/calculate-amount-paid-in-taxes/ | Iterate through tax brackets. For each bracket `[upper, percent]`, calculate taxable income as `min(income - prevUpper, upper - prevUpper)`. Compute tax as `(taxableAmount * percent) / 100.0` and add to total. Update `prevUpper` to current `upper`. Stop if income is fully taxed. | Track `prevUpper` to compute taxable income per bracket. Use double for precise tax calculations. | Array Iteration, Calculation | O(n) | O(1) | `double totalTax = 0; int prevUpper = 0; for (int[] bracket : brackets) { int upper = bracket[0], percent = bracket[1]; if (income <= prevUpper) break; int taxableAmount = Math.min(income - prevUpper, upper - prevUpper); totalTax += (double) taxableAmount * percent / 100.0; prevUpper = upper; } return totalTax;` |
| 208 | Spiral Matrix | 54 | https://leetcode.com/problems/spiral-matrix/ | Traverse the matrix in a spiral order using four pointers: `top`, `bottom`, `left`, `right`. For each layer: traverse right (top row), down (right column), left (bottom row), up (left column). Update boundaries after each traversal. Stop when `top > bottom` or `left > right`. Handle single row/column cases. | Check boundaries before each traversal to avoid duplicates (e.g., single row). Use `result` list to store spiral order. | Matrix Traversal, Simulation | O(m*n) | O(1) | `List<Integer> result = new ArrayList<>(); int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.add(matrix[top][j]); top++; if (top > bottom) break; for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); right--; if (left > right) break; for (int j = right; j >= left; j--) result.add(matrix[bottom][j]); bottom--; if (top > bottom) break; for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); left++; } return result;` |
| 209 | Rotate Image | 48 | https://leetcode.com/problems/rotate-image/ | Rotate a square matrix 90 degrees clockwise in-place. First, transpose the matrix (swap `matrix[i][j]` with `matrix[j][i]` for `i <= j`). Then, reverse each row using two pointers. No extra space needed. | Transpose only upper triangle (`i <= j`) to avoid redundant swaps. Row reversal ensures correct orientation. | Matrix Manipulation, In-place Algorithm | O(n^2) | O(1) | `int n = matrix.length; for (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i < n; i++) { for (int j = 0; j < n / 2; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[i][n - 1 - j]; matrix[i][n - 1 - j] = temp; } }` |
| 210 | Set Matrix Zeroes | 73 | https://leetcode.com/problems/set-matrix-zeros/ | Use the first row and first column as markers to indicate which rows/columns should be zeroed. First, check if first row/column need zeroing. Then, scan the matrix (excluding first row/column) to mark zeros in first row/column. Finally, zero out rows/columns based on markers, handling first row/column last. | Use matrix itself as extra space to avoid O(m+n) space. Handle first row/column separately to avoid overwriting markers prematurely. | Matrix Manipulation, In-place Algorithm | O(m*n) | O(1) | `boolean firstRowZero = false, firstColZero = false; for (int j = 0; j < matrix[0].length; j++) if (matrix[0][j] == 0) firstRowZero = true; for (int i = 0; i < matrix.length; i++) if (matrix[i][0] == 0) firstColZero = true; for (int i = 1; i < matrix.length; i++) for (int j = 1; j < matrix[0].length; j++) if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; } for (int i = 1; i < matrix.length; i++) if (matrix[i][0] == 0) for (int j = 1; j < matrix[0].length; j++) matrix[i][j] = 0; for (int j = 1; j < matrix[0].length; j++) if (matrix[0][j] == 0) for (int i = 1; i < matrix.length; i++) matrix[i][j] = 0; if (firstRowZero) for (int j = 0; j < matrix[0].length; j++) matrix[0][j] = 0; if (firstColZero) for (int i = 0; i < matrix.length; i++) matrix[i][0] = 0;` |
| 211 | Valid Sudoku | 36 | https://leetcode.com/problems/valid-sudoku/ | Check each row, column, and 3x3 subgrid for duplicate digits (1-9). Use a HashSet to track seen entries, encoding each as a string (e.g., "4 in row 0"). For each cell, if not '.', check for conflicts in row, column, and box (box index = `(i/3)*3 + j/3`). Return false on any duplicate. | Encode constraints as unique strings for O(1) lookup. Compute box index efficiently to avoid separate loops. | Hash Set, Matrix Traversal | O(1) (fixed 9x9 grid) | O(1) | `Set<String> seen = new HashSet<>(); for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { char number = board[i][j]; if (number != '.') { if (!seen.add(number + " in row " + i) || !seen.add(number + " in column " + j) || !seen.add(number + " in block " + (i / 3) + "-" + (j / 3))) return false; } } } return true;` |
| 212 | Maximal Square | 221 | https://leetcode.com/problems/maximal-square/ | Use dynamic programming. Define `dp[i][j]` as the side length of the largest square ending at `(i,j)`. If `matrix[i][j] == '1'`, then `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`. Track maximum side length. Return `maxSide * maxSide`. | Use min of three neighbors to ensure a valid square. Initialize first row/column for base cases. | Dynamic Programming, Matrix DP | O(m*n) | O(m*n) | `int m = matrix.length, n = matrix[0].length; int[][] dp = new int[m][n]; int maxSide = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == '1') { dp[i][j] = 1; if (i > 0 && j > 0) dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])); maxSide = Math.max(maxSide, dp[i][j]); } } } return maxSide * maxSide;` |
| 213 | 01 Matrix | 542 | https://leetcode.com/problems/01-matrix/ | Use multi-source BFS. Initialize a queue with all cells containing 0 and set their distance to 0. Mark all 1s as `Integer.MAX_VALUE`. For each cell in the queue, update its four neighbors’ distances to `dist[curr] + 1` if smaller. Continue until queue is empty. | Start BFS from all 0s simultaneously to compute shortest paths to 1s. Use matrix as distance storage to save space. | BFS (Multi-Source), Matrix Traversal | O(m*n) | O(m*n) | `int m = matrix.length, n = matrix[0].length; int[][] dist = new int[m][n]; Queue<int[]> q = new LinkedList<>(); for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == 0) { q.offer(new int[]{i, j}); dist[i][j] = 0; } else dist[i][j] = Integer.MAX_VALUE; } } int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}}; while (!q.isEmpty()) { int[] curr = q.poll(); for (int[] dir : dirs) { int r = curr[0] + dir[0], c = curr[1] + dir[1]; if (r >= 0 && r < m && c >= 0 && c < n && dist[r][c] > dist[curr[0]][curr[1]] + 1) { dist[r][c] = dist[curr[0]][curr[1]] + 1; q.offer(new int[]{r, c}); } } } return dist;` |
| 214 | Print a Given Matrix in Spiral Form | N/A | https://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/ | Same as Spiral Matrix (208). Use four pointers (`top`, `bottom`, `left`, `right`) to traverse matrix in spiral order: right, down, left, up. Update boundaries after each traversal. Stop when boundaries cross. | Check boundaries before each traversal to handle single row/column cases correctly. | Matrix Traversal, Simulation | O(m*n) | O(1) | `List<Integer> result = new ArrayList<>(); int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.add(matrix[top][j]); top++; if (top > bottom) break; for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); right--; if (left > right) break; for (int j = right; j >= left; j--) result.add(matrix[bottom][j]); bottom--; if (top > bottom) break; for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); left++; } return result;` |
| 215 | Search in a Row Wise and Column Wise Sorted Matrix | N/A | https://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/ | Start from top-right corner (`row=0, col=n-1`). If current element equals target, return true. If less than target, move down (row++); if greater, move left (col--). Continue until out of bounds. | Top-right corner allows binary-search-like elimination of rows or columns based on comparisons. | Matrix Traversal, Two Pointers | O(m + n) | O(1) | `int row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] == target) return true; if (matrix[row][col] < target) row++; else col--; } return false;` |
| 216 | Time Based Key-Value Store | 981 | https://leetcode.com/problems/time-based-key-value-store/ | Use a HashMap where keys are strings and values are TreeMaps mapping timestamps to values. For `set(key, value, timestamp)`, add to `key`’s TreeMap. For `get(key, timestamp)`, use `floorEntry(timestamp)` to find the value with the largest timestamp <= given timestamp. | TreeMap’s `floorEntry` provides O(log N) lookup for the most recent timestamp. Handle empty cases with empty string return. | Hash Map, Sorted Map | O(log N) for get, O(1) for set | O(N) | `Map<String, TreeMap<Integer, String>> store = new HashMap<>(); void set(String key, String value, int timestamp) { store.computeIfAbsent(key, k -> new TreeMap<>()).put(timestamp, value); } String get(String key, int timestamp) { TreeMap<Integer, String> timestamps = store.get(key); if (timestamps == null) return ""; Map.Entry<Integer, String> entry = timestamps.floorEntry(timestamp); return entry == null ? "" : entry.getValue(); }` |
| 217 | Design Hit Counter | 362 | https://leetcode.com/problems/design-hit-counter/ | Use a queue to store timestamps of hits. For `hit(timestamp)`, add timestamp to queue. For `getHits(timestamp)`, remove timestamps older than `timestamp - 300` from the front, then return queue size. | Queue ensures O(1) amortized operations. Clean up old timestamps only during `getHits` to optimize `hit`. | Queue, Sliding Window | O(1) amortized | O(N) | `Queue<Integer> timestamps = new LinkedList<>(); void hit(int timestamp) { timestamps.offer(timestamp); } int getHits(int timestamp) { while (!timestamps.isEmpty() && timestamps.peek() <= timestamp - 300) timestamps.poll(); return timestamps.size(); }` |
| 218 | Logger Rate Limiter | 359 | https://leetcode.com/problems/logger-rate-limiter/ | Use a HashMap to store message -> last printed timestamp. For each message, check if it’s absent or if `timestamp >= lastPrinted + 10`. If true, update timestamp and return true; else return false. | HashMap provides O(1) average lookup. Only store messages seen within the last 10 seconds for efficiency. | Hash Map, Time-based Logic | O(1) | O(N) | `Map<String, Integer> lastPrinted = new HashMap<>(); boolean shouldPrintMessage(int timestamp, String message) { if (!lastPrinted.containsKey(message) || timestamp >= lastPrinted.get(message) + 10) { lastPrinted.put(message, timestamp); return true; } return false; }` |
| 219 | Design In-Memory File System | 588 | https://leetcode.com/problems/design-in-memory-file-system/ | Use a tree-like structure with a root node. Each node (Dir) contains a TreeMap of children (name -> Dir or File). Files store content as a StringBuilder. Implement `ls` (list sorted children), `mkdir` (create directory path), `addContentToFile` (append to file), `readContentFromFile` (return file content). | Split paths and traverse/create nodes iteratively. Use TreeMap for sorted `ls` output. | Tree, Hash Map | O(L) average | O(S) | `class Dir { TreeMap<String, Object> children = new TreeMap<>(); } class File { StringBuilder content = new StringBuilder(); } Dir root = new Dir(); List<String> ls(String path) { Object node = navigate(path); if (node instanceof File) return List.of(path.substring(path.lastIndexOf("/") + 1)); Dir dir = (Dir) node; return new ArrayList<>(dir.children.keySet()); } void mkdir(String path) { navigate(path, true); } void addContentToFile(String filePath, String content) { File file = (File) navigate(filePath, true); file.content.append(content); } String readContentFromFile(String filePath) { File file = (File) navigate(filePath, false); return file.content.toString(); } Object navigate(String path, boolean create) { ... }` |
| 220 | All O`one Data Structure | 432 | https://leetcode.com/problems/all-oone-data-structure/ | Use a HashMap (`keyToNode`) and a doubly linked list of Buckets (frequency -> Set of keys). Each Bucket has a frequency and a Set of keys. `inc`/`dec` moves keys between Buckets, updating the list. Maintain head/tail for min/max frequency access. | Doubly linked list ensures O(1) Bucket updates. Set in Buckets allows O(1) key removal. | Hash Map, Doubly Linked List | O(1) | O(N) | `class AllOne { class Bucket { int freq; Set<String> keys = new HashSet<>(); Bucket prev, next; Bucket(int f) { freq = f; } } Map<String, Bucket> keyToNode = new HashMap<>(); Bucket head = new Bucket(0), tail = new Bucket(0); { head.next = tail; tail.prev = head; } void inc(String key) { ... } void dec(String key) { ... } String getMaxKey() { return tail.prev == head ? "" : tail.prev.keys.iterator().next(); } String getMinKey() { return head.next == tail ? "" : head.next.keys.iterator().next(); } }` |
| 221 | LFU Cache | 460 | https://leetcode.com/problems/lfu-cache/ | Use three HashMaps: `cache` (key -> Node), `keyToFreq` (key -> frequency), `freqToList` (frequency -> DoublyLinkedList). Each Node has key, value, frequency. Evict least frequent, least recently used node when full. Update frequencies on get/put. | Maintain LRU order within each frequency list. Track `minFreq` for eviction. | Hash Map, Doubly Linked List | O(1) | O(Capacity) | `class LFUCache { class Node { int key, value, freq; Node prev, next; } class DoublyLinkedList { Node head = new Node(), tail = new Node(); ... } Map<Integer, Node> cache = new HashMap<>(); Map<Integer, Integer> keyToFreq = new HashMap<>(); Map<Integer, DoublyLinkedList> freqToList = new HashMap<>(); int minFreq, capacity; public LFUCache(int capacity) { this.capacity = capacity; } public int get(int key) { ... } public void put(int key, int value) { ... } }` |
| 222 | Design Memory Allocator | 2502 | https://leetcode.com/problems/design-memory-allocator/ | Use an array to represent memory, where each cell stores an `mID` (0 for free). For `allocate`, find a contiguous block of `size` zeros, set to `mID`, return start index. For `free`, set all cells with given `mID` to 0, return count. | Linear scan for allocation is simple. Track freed cells by counting matches during `free`. | Array Manipulation, Simulation | O(N) | O(N) | `class Allocator { int[] memory; Allocator(int n) { memory = new int[n]; } int allocate(int size, int mID) { int start = -1; for (int i = 0; i < memory.length; i++) { if (memory[i] == 0) { if (start == -1) start = i; if (i - start + 1 == size) { for (int j = start; j <= i; j++) memory[j] = mID; return start; } } else start = -1; } return -1; } int free(int mID) { int count = 0; for (int i = 0; i < memory.length; i++) if (memory[i] == mID) { memory[i] = 0; count++; } return count; } }` |
| 223 | Design a Data Structure for LRU Cache | N/A | https://www.geeksforgeeks.org/lru-cache-implementation/ | Use a HashMap (key -> Node) and a doubly linked list for O(1) operations. `get` moves node to front. `put` adds to front, evicts tail if over capacity. Use dummy head/tail for easier list manipulation. | Dummy nodes simplify list operations. HashMap ensures O(1) access to nodes. | Hash Map, Doubly Linked List | O(1) | O(Capacity) | `class LRUCache { class Node { int key, value; Node prev, next; } Map<Integer, Node> map = new HashMap<>(); Node head = new Node(), tail = new Node(); int capacity; LRUCache(int capacity) { this.capacity = capacity; head.next = tail; tail.prev = head; } int get(int key) { Node node = map.get(key); if (node == null) return -1; moveToHead(node); return node.value; } void put(int key, int value) { Node node = map.get(key); if (node != null) { node.value = value; moveToHead(node); } else { node = new Node(); node.key = key; node.value = value; addNode(node); map.put(key, node); if (map.size() > capacity) { Node lru = tail.prev; removeNode(lru); map.remove(lru.key); } } } void addNode(Node node) { ... } void removeNode(Node node) { ... } void moveToHead(Node node) { ... } }` |
| 224 | Jump Game | 55 | https://leetcode.com/problems/jump-game/ | Greedy approach: Track the maximum reachable index (`maxReach`). Iterate through array; if current index is reachable (`i <= maxReach`), update `maxReach` as `max(maxReach, i + nums[i])`. Return true if `maxReach >= n-1`. | Single pass with greedy updates ensures efficiency. Early termination if `maxReach` covers end. | Greedy, Array Iteration | O(n) | O(1) | `int maxReach = 0; for (int i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); if (maxReach >= nums.length - 1) return true; } return true;` |
| 225 | Jump Game II | 45 | https://leetcode.com/problems/jump-game-ii/ | Greedy approach: Track `currentReach` (end of current jump) and `maxReach` (farthest reachable with next jump). When reaching `currentReach`, increment jumps and update `currentReach` to `maxReach`. | Greedy selection of farthest reach per jump minimizes jump count. Implicit BFS levels. | Greedy, Array Iteration | O(n) | O(1) | `int jumps = 0, currentReach = 0, maxReach = 0; for (int i = 0; i < nums.length - 1; i++) { maxReach = Math.max(maxReach, i + nums[i]); if (i == currentReach) { jumps++; currentReach = maxReach; } } return jumps;` |
| 226 | Gas Station | 134 | https://leetcode.com/problems/gas-station/ | Greedy approach: Compute total gas and cost. Track `currentGas` and reset `startStation` when `currentGas < 0`. If `totalGas >= totalCost`, return `startStation`; else return -1. | If total gas is sufficient, a valid start exists. Reset start after negative `currentGas` to skip invalid segments. | Greedy, Array Iteration | O(n) | O(1) | `int totalGas = 0, totalCost = 0, currentGas = 0, startStation = 0; for (int i = 0; i < gas.length; i++) { totalGas += gas[i]; totalCost += cost[i]; currentGas += gas[i] - cost[i]; if (currentGas < 0) { startStation = i + 1; currentGas = 0; } } return totalGas >= totalCost ? startStation : -1;` |
| 227 | Candy | 135 | https://leetcode.com/problems/candy/ | Two-pass greedy: Left pass gives more candies if rating > left neighbor. Right pass ensures more candies if rating > right neighbor, taking max with current count. Sum candies. | Two passes handle both neighbor constraints independently. Use `long` for sum to avoid overflow. | Two Passes, Array Manipulation | O(n) | O(n) | `int n = ratings.length; int[] candies = new int[n]; Arrays.fill(candies, 1); for (int i = 1; i < n; i++) if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1; for (int i = n - 2; i >= 0; i--) if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1); long totalCandies = 0; for (int candy : candies) totalCandies += candy; return (int) totalCandies;` |
| 228 | Non-overlapping Intervals | 435 | https://leetcode.com/problems/non-overlapping-intervals/ | Sort intervals by end time. Track `end` of last selected interval. If current interval’s start < `end`, increment count (overlap); else update `end`. Return count. | Sorting by end time ensures greedy selection maximizes non-overlapping intervals. | Sorting, Greedy | O(n log n) | O(1) | `Arrays.sort(intervals, (a, b) -> a[1] - b[1]); int count = 0, end = intervals[0][1]; for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] < end) count++; else end = intervals[i][1]; } return count;` |
| 229 | Maximum Profit in Job Scheduling | 1235 | https://leetcode.com/problems/maximum-profit-in-job-scheduling/ | Sort jobs by end time. Use DP with memoization: `dp(i)` is max profit from index `i` onward. For each job, compute profit by including it (find next non-overlapping job via binary search) or excluding it. | Binary search finds next job efficiently. Memoization avoids recomputing subproblems. | Dynamic Programming, Binary Search | O(n log n) | O(n) | `int[][] jobs = new int[n][3]; for (int i = 0; i < n; i++) jobs[i] = new int[]{startTime[i], endTime[i], profit[i]}; Arrays.sort(jobs, (a, b) -> a[1] - b[1]); Integer[] memo = new Integer[n]; int solve(int i) { if (i >= jobs.length) return 0; if (memo[i] != null) return memo[i]; int exclude = solve(i + 1); int next = Arrays.binarySearch(jobs, i + 1, jobs.length, new int[]{jobs[i][1], 0, 0}, (a, b) -> a[0] - b[0]); next = next < 0 ? -(next + 1) : next; int include = jobs[i][2] + solve(next); return memo[i] = Math.max(exclude, include); } return solve(0);` |
| 230 | Minimum Number of Refueling Stops | 871 | https://leetcode.com/problems/minimum-number-of-refueling-stops/ | Use a max-heap to store fuel from stations passed. Track `currentFuel`. For each station, consume fuel to reach it. If `currentFuel < 0`, refuel from heap (max fuel first), increment stops. If still negative, return -1. | Greedy refueling with max fuel optimizes stops. Heap ensures O(log n) access to max fuel. | Greedy, Priority Queue | O(n log n) | O(n) | `PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a); int stops = 0, currentFuel = startFuel, prevPos = 0; for (int[] station : stations) { int pos = station[0], fuel = station[1]; currentFuel -= (pos - prevPos); while (currentFuel < 0 && !pq.isEmpty()) { currentFuel += pq.poll(); stops++; } if (currentFuel < 0) return -1; pq.offer(fuel); prevPos = pos; } currentFuel -= (target - prevPos); while (currentFuel < 0 && !pq.isEmpty()) { currentFuel += pq.poll(); stops++; } return currentFuel >= 0 ? stops : -1;` |
| 231 | Can I Win | 464 | https://leetcode.com/problems/can-i-win/ | Use DP with bitmask memoization. `dp(mask, total)` is true if the current player can win with used numbers (`mask`) and current sum (`total`). For each unused number, check if it meets `desiredTotal` or if opponent loses after picking it. | Bitmask tracks used numbers efficiently. Memoize `(mask, total)` to handle large states. | Dynamic Programming, Bit Manipulation | O(2^n * n) | O(2^n) | `Map<Long, Boolean> memo = new HashMap<>(); boolean canWin(int mask, int total, int maxChoosableInteger, int desiredTotal) { if (total >= desiredTotal) return true; long key = ((long) mask << 32) | total; if (memo.containsKey(key)) return memo.get(key); for (int i = 1; i <= maxChoosableInteger; i++) { if ((mask & (1 << (i - 1))) == 0) { if (!canWin(mask | (1 << (i - 1)), total + i, maxChoosableInteger, desiredTotal)) { memo.put(key, true); return true; } } } memo.put(key, false); return false; } boolean canIWin(int maxChoosableInteger, int desiredTotal) { if (desiredTotal == 0) return true; if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false; return canWin(0, 0, maxChoosableInteger, desiredTotal); }` |
| 232 | Task Scheduler | 621 | https://leetcode.com/problems/task-scheduler/ | Count task frequencies. The most frequent task determines minimum time: `(maxFreq - 1) * n` idle slots plus tasks. Fill idle slots with other tasks. Return max of total tasks and calculated slots. | Formula `(maxFreq - 1) * n + maxFreq` accounts for idle slots. Adjust for ties in max frequency. | Frequency Map, Greedy | O(n) | O(1) | `int[] freq = new int[26]; for (char task : tasks) freq[task - 'A']++; Arrays.sort(freq); int maxFreq = freq[25]; int idleSlots = (maxFreq - 1) * n; for (int i = 24; i >= 0 && freq[i] > 0; i--) idleSlots -= Math.min(freq[i], maxFreq - 1); return Math.max(tasks.length, tasks.length + Math.max(0, idleSlots));` |
| 233 | Task Scheduler II | 2365 | https://leetcode.com/problems/task-scheduler-ii/ | Use a HashMap to track last execution day of each task. For each task, if it was executed within `space` days, wait until `lastDay + space + 1`. Update `currentDay` and `lastExecDay`. | Track last execution to enforce cooldown. Advance `currentDay` only when necessary. | Hash Map, Simulation | O(n) | O(U) | `Map<Integer, Long> lastExecDay = new HashMap<>(); long currentDay = 0; for (int task : tasks) { if (lastExecDay.containsKey(task) && currentDay - lastExecDay.get(task) <= space) currentDay = lastExecDay.get(task) + space + 1; lastExecDay.put(task, currentDay); currentDay++; } return currentDay;` |
| 234 | Maximum Coin Collection | N/A | https://www.geeksforgeeks.org/maximum-coin-collection/ | Use dynamic programming. Define `dp[i][j]` as max coins collected reaching `(i,j)` moving right or down. Recurrence: `dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])`. Initialize first row/column. | Standard grid DP. Space can be optimized to O(n) by using only previous row. | Dynamic Programming, Grid Traversal | O(m*n) | O(m*n) | `int m = grid.length, n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for (int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j]; for (int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0]; for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[i][j] = grid[i][j] + Math.max(dp[i-1][j], dp[i][j-1]); return dp[m-1][n-1];` |



| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 235 | Single Number | 136 | https://leetcode.com/problems/single-number/ | Iterate through the array and XOR all elements. Since XORing a number with itself is 0 and XOR is associative, paired numbers cancel out, leaving the single number. Handle edge case: array of length 1. | XOR cancels pairs, leaving the unique number. Use `^=` for concise iteration. | Bit Manipulation (XOR) | O(n) | O(1) | `int result = 0; for (int num : nums) result ^= num; return result;` |
| 236 | Single Number II | 137 | https://leetcode.com/problems/single-number-ii/ | Count bits at each position (0 to 31). For each bit position, sum the occurrences of 1s across all numbers. If the sum modulo 3 is 1, set that bit in the result. Handle negative numbers by considering the sign bit. | Bit sum modulo 3 identifies the single number’s bits. Use `>>` and `&` for bit operations. | Bit Manipulation, Counting | O(n) | O(1) | `int singleNumber = 0; for (int i = 0; i < 32; i++) { int bitSum = 0; for (int num : nums) bitSum += ((num >> i) & 1); if (bitSum % 3 != 0) singleNumber |= (1 << i); } return singleNumber;` |
| 237 | Counting Bits | 338 | https://leetcode.com/problems/counting-bits/ | Use dynamic programming with bit manipulation. For each `i`, the number of 1s is the number of 1s in `i >> 1` (i/2) plus the last bit (`i & 1`). Initialize `ans[0] = 0`. Iterate from 1 to `n`. | Relate `i` to `i/2` and add the last bit. Avoid explicit bit counting for efficiency. | Dynamic Programming, Bit Manipulation | O(n) | O(n) | `int[] ans = new int[n + 1]; for (int i = 1; i <= n; i++) ans[i] = ans[i >> 1] + (i & 1); return ans;` |
| 238 | Find Kth Bit in Nth Binary String | 1545 | https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/ | Recursively compute the k-th bit of S_n. Base case: S_1 = "0". For S_n, length is `2^n - 1`. Midpoint is `(2^n - 1) / 2 + 1`. If `k == mid`, return '1'. If `k < mid`, recurse on S_{n-1}. If `k > mid`, map to index in S_{n-1} as `2*mid - k` and invert the result. | Map k to S_{n-1} and handle inversion for second half. Use bit shifts for length calculation. | Recursion, String Manipulation | O(n) | O(n) | `char findKthBit(int n, int k) { if (n == 1) return '0'; int mid = (1 << n - 1); if (k == mid) return '1'; if (k < mid) return findKthBit(n - 1, k); return findKthBit(n - 1, 2 * mid - k) == '0' ? '1' : '0'; }` |
| 239 | Subarray Sum Equals K | 560 | https://leetcode.com/problems/subarray-sum-equals-k/ | Use prefix sums with a HashMap to store frequency of sums. For each index, compute cumulative sum. If `sum - k` exists in the map, add its frequency to the count. Update map with current sum. Initialize map with `{0: 1}` for subarrays starting at index 0. | Prefix sum difference identifies subarrays summing to k. Map tracks sum frequencies. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - k, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 240 | Continuous Subarray Sum | 523 | https://leetcode.com/problems/continuous-subarray-sum/ | Use prefix sums modulo k with a HashMap to store remainder -> index. If a remainder repeats at index `j` (previously at `i`), the subarray `[i+1, j]` sums to a multiple of k. Ensure `j - i > 1`. Handle `k == 0` by checking sum directly. Initialize map with `{0: -1}`. | Same remainder modulo k implies subarray sum is divisible by k. Check subarray length. | Hash Map, Prefix Sum, Modular Arithmetic | O(n) | O(min(n, k)) | `Map<Integer, Integer> remainderMap = new HashMap<>(); remainderMap.put(0, -1); int currentSum = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; int remainder = k == 0 ? currentSum : currentSum % k; if (remainderMap.containsKey(remainder) && i - remainderMap.get(remainder) > 1) return true; if (!remainderMap.containsKey(remainder)) remainderMap.put(remainder, i); } return false;` |
| 241 | Count Subarray Sums Divisible by K | 974 | https://leetcode.com/problems/subarray-sums-divisible-by-k/ | Use prefix sums modulo k with a HashMap to count remainder frequencies. For each index, compute cumulative sum modulo k (handle negative remainders). Add frequency of current remainder to count. Update map. Initialize with `{0: 1}`. | Count subarrays by tracking remainder frequencies. Adjust negative remainders with `+k`. | Hash Map, Prefix Sum, Modular Arithmetic | O(n) | O(k) | `Map<Integer, Integer> remainderCounts = new HashMap<>(); remainderCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; int remainder = ((currentSum % k) + k) % k; count += remainderCounts.getOrDefault(remainder, 0); remainderCounts.put(remainder, remainderCounts.getOrDefault(remainder, 0) + 1); } return count;` |
| 242 | Count Binary Subarrays with Given Sum | 930 | https://leetcode.com/problems/binary-subarrays-with-sum/ | Same as Subarray Sum Equals K (239). Use prefix sums with a HashMap. For each index, compute cumulative sum. If `sum - goal` exists, add its frequency to count. Update map. Initialize with `{0: 1}`. | Identical to Subarray Sum Equals K, optimized for binary array but same logic applies. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - goal, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 243 | Contiguous Array | 525 | https://leetcode.com/problems/contiguous-array/ | Replace 0s with -1s to find longest subarray with sum 0. Use prefix sums with a HashMap to store sum -> first index. If sum repeats at index `j` (previously at `i`), subarray `[i+1, j]` has sum 0. Track max length. Initialize with `{0: -1}`. | Convert to sum-0 problem by mapping 0 to -1. Length is `j - i`. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> sumIndexMap = new HashMap<>(); sumIndexMap.put(0, -1); int currentSum = 0, maxLen = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i] == 1 ? 1 : -1; if (sumIndexMap.containsKey(currentSum)) maxLen = Math.max(maxLen, i - sumIndexMap.get(currentSum)); else sumIndexMap.put(currentSum, i); } return maxLen;` |
| 244 | Minimum Operations to Reduce X to Zero | 1658 | https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/ | Find longest subarray with sum `totalSum - x`. Use prefix sums with a HashMap to store sum -> index. Compute cumulative sum. If `sum - target` exists, update max length. Minimize operations as `n - maxLen`. Initialize with `{0: -1}`. | Transform to longest subarray problem. Operations = array length - subarray length. | Hash Map, Prefix Sum | O(n) | O(n) | `long totalSum = 0; for (int num : nums) totalSum += num; long targetSum = totalSum - x; if (targetSum < 0) return -1; Map<Long, Integer> sumIndexMap = new HashMap<>(); sumIndexMap.put(0L, -1); long currentSum = 0; int maxLen = -1; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; if (sumIndexMap.containsKey(currentSum - targetSum)) maxLen = Math.max(maxLen, i - sumIndexMap.get(currentSum - targetSum)); sumIndexMap.put(currentSum, i); } return maxLen == -1 ? -1 : nums.length - maxLen;` |
| 245 | Subarrays Count with Sum Equal to 0 | N/A | https://www.geeksforgeeks.org/print-all-subarrays-with-0-sum/ | Same as Subarray Sum Equals K (239) with `k = 0`. Use prefix sums with a HashMap to count frequency of sums. If a sum repeats, add its frequency to count. Initialize with `{0: 1}`. | Count zero-sum subarrays using prefix sum frequency. Identical to k=0 case. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Long, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0L, 1); long currentSum = 0; int count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 246 | Subarrays Count with Sum = K | N/A | https://www.geeksforgeeks.org/subarrays-with-sum-k/ | Identical to Subarray Sum Equals K (239). Use prefix sums with a HashMap. For each index, compute cumulative sum. If `sum - k` exists, add its frequency. Update map. Initialize with `{0: 1}`. | Direct application of prefix sum technique for arbitrary k. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Long, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0L, 1); long currentSum = 0; int count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - k, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 247 | Print All Subarrays with 0 Sum | N/A | https://www.geeksforgeeks.org/print-all-subarrays-with-0-sum/ | Use prefix sums with a HashMap mapping sum to list of indices. If a sum repeats, print subarrays from each previous index + 1 to current index. Initialize with `{0: [-1]}`. Note: Printing increases time complexity based on output size. | Store indices for each sum to print all subarrays. Handle printing in O(max_occurrences). | Hash Map, Prefix Sum | O(n + S) (S = subarray count) | O(n) | `Map<Long, List<Integer>> sumIndices = new HashMap<>(); sumIndices.put(0L, new ArrayList<>(List.of(-1))); long currentSum = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; if (sumIndices.containsKey(currentSum)) { for (int prevIndex : sumIndices.get(currentSum)) System.out.println("Subarray from " + (prevIndex + 1) + " to " + i); } sumIndices.computeIfAbsent(currentSum, k -> new ArrayList<>()).add(i); }` |
| 248 | Number of Provinces | 547 | https://leetcode.com/problems/number-of-provinces/ | Use Union-Find to count connected components. Initialize each city in its own set. For each connection, union the cities. Count distinct sets (roots). Alternatively, use DFS to count components. | Union-Find efficiently merges connected cities. Count roots for province count. | Union-Find, Graph | O(n^2 * α(n)) | O(n) | `int[] parent = new int[n]; int count = n; for (int i = 0; i < n; i++) parent[i] = i; int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px != py) { parent[px] = py; count--; } } for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (isConnected[i][j] == 1) union(i, j); return count;` |
| 249 | Accounts Merge | 721 | https://leetcode.com/problems/accounts-merge/ | Use Union-Find to group emails. Map each email to an ID and name. Union emails in the same account. Group emails by their root, then map to names and sort. Return merged accounts. | Union-Find groups emails efficiently. Sort emails for output consistency. | Union-Find, Hash Map | O(A * E * α(E) + E log E) | O(A * E) | `Map<String, Integer> emailToId = new HashMap<>(); Map<String, String> emailToName = new HashMap<>(); int id = 0; for (List<String> account : accounts) for (int i = 1; i < account.size(); i++) { String email = account.get(i); emailToId.putIfAbsent(email, id++); emailToName.put(email, account.get(0)); } int[] parent = new int[id]; for (int i = 0; i < id; i++) parent[i] = i; int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } for (List<String> account : accounts) for (int i = 2; i < account.size(); i++) parent[find(emailToId.get(account.get(i)))] = find(emailToId.get(account.get(1))); Map<Integer, List<String>> groups = new HashMap<>(); for (String email : emailToId.keySet()) groups.computeIfAbsent(find(emailToId.get(email)), k -> new ArrayList<>()).add(email); List<List<String>> result = new ArrayList<>(); for (List<String> emails : groups.values()) { Collections.sort(emails); List<String> account = new ArrayList<>(); account.add(emailToName.get(emails.get(0))); account.addAll(emails); result.add(account); } return result;` |
| 250 | Minesweeper | 529 | https://leetcode.com/problems/minesweeper/ | Use DFS to reveal cells. If clicked cell is 'M', set to 'X'. If 'E', count adjacent mines. If count > 0, set to digit; if 0, set to 'B' and recurse on neighbors. Use visited set to avoid cycles. | DFS reveals connected blank cells efficiently. Count mines using 8-directional check. | DFS, Matrix Traversal | O(m*n) | O(m*n) | `void updateBoard(char[][] board, int[] click) { int r = click[0], c = click[1]; if (board[r][c] == 'M') { board[r][c] = 'X'; return; } dfs(board, r, c, new boolean[board.length][board[0].length]); } void dfs(char[][] board, int r, int c, boolean[][] visited) { if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || visited[r][c] || board[r][c] != 'E') return; visited[r][c] = true; int mines = countMines(board, r, c); if (mines > 0) { board[r][c] = (char) ('0' + mines); return; } board[r][c] = 'B'; int[][] dirs = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; for (int[] dir : dirs) dfs(board, r + dir[0], c + dir[1], visited); } int countMines(char[][] board, int r, int c) { int count = 0; for (int i = -1; i <= 1; i++) for (int j = -1; j <= 1; j++) if (i != 0 || j != 0) if (r + i >= 0 && r + i < board.length && c + j >= 0 && c + j < board[0].length && board[r + i][c + j] == 'M') count++; return count; }` |
| 251 | Robot Room Cleaner | 489 | https://leetcode.com/problems/robot-room-cleaner/ | Use backtracking (DFS). Clean current cell, mark as visited. Try all four directions. If move is possible, recurse, then backtrack by moving back and restoring direction. Use a set for visited cells. | Backtrack with explicit direction handling. Visited set prevents cycles. | Backtracking, DFS | O(N * 4) | O(N) | `Set<String> visited = new HashSet<>(); int[][] dirs = {{-1,0},{0,1},{1,0},{0,-1}}; void cleanRoom(Robot robot) { clean(0, 0, 0, robot); } void clean(int r, int c, int dir, Robot robot) { visited.add(r + "," + c); robot.clean(); for (int i = 0; i < 4; i++) { int newDir = (dir + i) % 4; int nr = r + dirs[newDir][0], nc = c + dirs[newDir][1]; if (!visited.contains(nr + "," + nc) && robot.move()) { clean(nr, nc, newDir, robot); robot.turnLeft(); robot.turnLeft(); robot.move(); robot.turnRight(); robot.turnRight(); } robot.turnRight(); } }` |
| 252 | The Maze | 490 | https://leetcode.com/problems/the-maze/ | Use BFS to find if the ball can stop at the destination. From each stop point, roll in all four directions until hitting a wall. Add stop points to queue if unvisited. Check if destination is reached. | BFS explores all stop points. Roll until wall for each direction. | BFS, Matrix Traversal | O(m*n) | O(m*n) | `boolean hasPath(int[][] maze, int[] start, int[] destination) { int m = maze.length, n = maze[0].length; boolean[][] visited = new boolean[m][n]; Queue<int[]> q = new LinkedList<>(); q.offer(start); visited[start[0]][start[1]] = true; int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}}; while (!q.isEmpty()) { int[] curr = q.poll(); if (curr[0] == destination[0] && curr[1] == destination[1]) return true; for (int[] dir : dirs) { int r = curr[0], c = curr[1]; while (r + dir[0] >= 0 && r + dir[0] < m && c + dir[1] >= 0 && c + dir[1] < n && maze[r + dir[0]][c + dir[1]] == 0) { r += dir[0]; c += dir[1]; } if (!visited[r][c]) { visited[r][c] = true; q.offer(new int[]{r, c}); } } } return false; }` |
| 253 | Robot Bounded In Circle | 1041 | https://leetcode.com/problems/robot-bounded-in-circle/ | Simulate one cycle of instructions. Track position (x, y) and direction (0: North, 1: East, 2: South, 3: West). Return true if back at origin or direction changed (implying a cycle). | Check position and direction after one cycle. Direction change ensures eventual return. | Simulation, Math | O(n) | O(1) | `int x = 0, y = 0, dir = 0; int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}}; for (char instr : instructions.toCharArray()) { if (instr == 'G') { x += directions[dir][0]; y += directions[dir][1]; } else if (instr == 'L') dir = (dir + 3) % 4; else dir = (dir + 1) % 4; } return (x == 0 && y == 0) || dir != 0;` |
| 254 | Sliding Puzzle | 773 | https://leetcode.com/problems/sliding-puzzle/ | Use BFS to find minimum moves. Represent board as a string. For each state, find the '0' position, swap with adjacent positions, and add new states to queue if unvisited. Track moves via BFS levels. Target is "123450". | BFS ensures shortest path. String representation simplifies state tracking. | BFS, State Space Search | O(6!) | O(6!) | `int slidingPuzzle(int[][] board) { String target = "123450"; StringBuilder sb = new StringBuilder(); for (int[] row : board) for (int num : row) sb.append(num); String start = sb.toString(); Queue<String> q = new LinkedList<>(); Set<String> visited = new HashSet<>(); q.offer(start); visited.add(start); int moves = 0; int[][] swaps = {{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}}; while (!q.isEmpty()) { int size = q.size(); while (size-- > 0) { String curr = q.poll(); if (curr.equals(target)) return moves; int zeroIdx = curr.indexOf('0'); for (int next : swaps[zeroIdx]) { String nextState = swap(curr, zeroIdx, next); if (!visited.contains(nextState)) { visited.add(nextState); q.offer(nextState); } } } moves++; } return -1; } String swap(String s, int i, int j) { char[] arr = s.toCharArray(); char temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return new String(arr); }` |
| 255 | 24 Game | 679 | https://leetcode.com/problems/24-game/ | Use backtracking to try all pairs of numbers and operations (+, -, *, /). Replace pair with result, recurse on remaining numbers. Base case: one number ≈ 24 (within 1e-6). Handle division by zero and floating-point precision. | Explore all combinations and operations. Use double for precision. | Backtracking, Arithmetic | O(4!) | O(4) | `boolean judgePoint24(int[] cards) { List<Double> nums = new ArrayList<>(); for (int card : cards) nums.add((double) card); return solve(nums); } boolean solve(List<Double> nums) { if (nums.size() == 1) return Math.abs(nums.get(0) - 24.0) < 1e-6; for (int i = 0; i < nums.size(); i++) { for (int j = 0; j < nums.size(); j++) { if (i == j) continue; List<Double> next = new ArrayList<>(); for (int k = 0; k < nums.size(); k++) if (k != i && k != j) next.add(nums.get(k)); double a = nums.get(i), b = nums.get(j); for (double res : new double[]{a + b, a - b, a * b, b != 0 ? a / b : Double.MAX_VALUE}) if (res != Double.MAX_VALUE) { next.add(res); if (solve(next)) return true; next.remove(next.size() - 1); } } } return false; }` |
| 256 | Nim Game | 292 | https://leetcode.com/problems/nim-game/ | First player wins if `n` is not divisible by 4, as they can force a losing state (multiple of 4) for the opponent. Check `n % 4 != 0`. | Pattern recognition: multiples of 4 are losing states for the first player. | Game Theory, Math | O(1) | O(1) | `return n % 4 != 0;` |
| 257 | Flip Game II | 294 | https://leetcode.com/problems/flip-game-ii/ | Use backtracking with memoization. For each state, try flipping "++" to "--". If any resulting state leads to a loss for the opponent, the current player wins. Memoize states to avoid recomputation. | Memoize string states to optimize recursive exploration of game tree. | Backtracking, Game Theory | O(n * 2^n) | O(2^n) | `Map<String, Boolean> memo = new HashMap<>(); boolean canWin(String s) { if (memo.containsKey(s)) return memo.get(s); for (int i = 0; i < s.length() - 1; i++) if (s.startsWith("++", i)) { String next = s.substring(0, i) + "--" + s.substring(i + 2); if (!canWin(next)) { memo.put(s, true); return true; } } memo.put(s, false); return false; }` |
| 258 | Insert Delete GetRandom O(1) | 380 | https://leetcode.com/problems/insert-delete-getrandom-o1/ | Use a HashMap (`val -> index`) and ArrayList for O(1) operations. Insert: add to list and map. Remove: swap with last element, update map, remove last. GetRandom: pick random index from list. | Swap with last element for O(1) removal. Map ensures O(1) lookup. | Hash Map, Array List | O(1) | O(n) | `Map<Integer, Integer> valToIndex = new HashMap<>(); List<Integer> list = new ArrayList<>(); Random rand = new Random(); boolean insert(int val) { if (valToIndex.containsKey(val)) return false; valToIndex.put(val, list.size()); list.add(val); return true; } boolean remove(int val) { if (!valToIndex.containsKey(val)) return false; int idx = valToIndex.get(val); int lastVal = list.get(list.size() - 1); list.set(idx, lastVal); valToIndex.put(lastVal, idx); list.remove(list.size() - 1); valToIndex.remove(val); return true; } int getRandom() { return list.get(rand.nextInt(list.size())); }` |
| 259 | Insert Delete GetRandom O(1) - Duplicates Allowed | 381 | https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/ | Use a HashMap (`val -> Set<index>`) and ArrayList. Insert: add to list and set in map. Remove: pick an index from set, swap with last element, update set, remove last. GetRandom: random index from list. | Handle duplicates with sets of indices. Swap with last for O(1) removal. | Hash Map, Array List, Set | O(1) | O(n) | `Map<Integer, Set<Integer>> valToIndices = new HashMap<>(); List<Integer> list = new ArrayList<>(); Random rand = new Random(); boolean insert(int val) { valToIndices.computeIfAbsent(val, k -> new HashSet<>()).add(list.size()); list.add(val); return true; } boolean remove(int val) { if (!valToIndices.containsKey(val) || valToIndices.get(val).isEmpty()) return false; int idx = valToIndices.get(val).iterator().next(); valToIndices.get(val).remove(idx); int lastVal = list.get(list.size() - 1); list.set(idx, lastVal); valToIndices.computeIfAbsent(lastVal, k -> new HashSet<>()).add(idx); valToIndices.get(lastVal).remove(list.size() - 1); list.remove(list.size() - 1); return true; } int getRandom() { return list.get(rand.nextInt(list.size())); }` |
| 260 | Linked List Random Node | 382 | https://leetcode.com/problems/linked-list-random-node/ | Use reservoir sampling. Iterate through the list, keeping a reservoir (initially first node). For the i-th node, replace reservoir with probability 1/i. Ensures uniform random selection. | Reservoir sampling handles unknown list size with O(1) space. | Reservoir Sampling | O(n) | O(1) | `ListNode head; Random rand; public Solution(ListNode head) { this.head = head; rand = new Random(); } public int getRandom() { ListNode curr = head; int result = curr.val; int i = 1; while (curr.next != null) { curr = curr.next; if (rand.nextInt(++i) == 0) result = curr.val; } return result; }` |
| 261 | Shuffle an Array | 384 | https://leetcode.com/problems/shuffle-an-array/ | Use Fisher-Yates shuffle. Clone original array. For each index i from n-1 to 1, swap with a random index from 0 to i. Reset returns original array clone. | Fisher-Yates ensures unbiased permutations. Clone array for reset. | Fisher-Yates Shuffle | O(n) | O(n) | `int[] original, array; Random rand; public Solution(int[] nums) { original = nums.clone(); array = nums.clone(); rand = new Random(); } public int[] reset() { array = original.clone(); return array; } public int[] shuffle() { for (int i = array.length - 1; i > 0; i--) { int j = rand.nextInt(i + 1); int temp = array[i]; array[i] = array[j]; array[j] = temp; } return array; }` |
| 262 | Random Pick with Weight | 528 | https://leetcode.com/problems/random-pick-with-weight/ | Compute prefix sums of weights. Generate random number from 1 to total sum. Use binary search to find the index where the random number falls in prefix sums. | Prefix sums map weights to ranges. Binary search ensures O(log n) pick. | Prefix Sum, Binary Search | O(n) init, O(log n) pick | O(n) | `int[] prefixSums; Random rand; public Solution(int[] w) { prefixSums = new int[w.length]; prefixSums[0] = w[0]; for (int i = 1; i < w.length; i++) prefixSums[i] = prefixSums[i - 1] + w[i]; rand = new Random(); } public int pickIndex() { int total = prefixSums[prefixSums.length - 1]; int target = rand.nextInt(total) + 1; int low = 0, high = prefixSums.length - 1; while (low < high) { int mid = low + (high - low) / 2; if (prefixSums[mid] < target) low = mid + 1; else high = mid; } return low; }` |
| 263 | Rectangle Area | 223 | https://leetcode.com/problems/rectangle-area/ | Compute area of each rectangle. Find intersection by taking max of left/bottom and min of right/top. If intersection is valid (positive width/height), subtract its area from sum of individual areas. | Intersection requires valid width and height checks. Simple coordinate math. | Geometry, Arithmetic | O(1) | O(1) | `int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int area1 = (ax2 - ax1) * (ay2 - ay1); int area2 = (bx2 - bx1) * (by2 - by1); int xLeft = Math.max(ax1, bx1), xRight = Math.min(ax2, bx2); int yBottom = Math.max(ay1, by1), yTop = Math.min(ay2, by2); int intersectArea = (xRight > xLeft && yTop > yBottom) ? (xRight - xLeft) * (yTop - yBottom) : 0; return area1 + area2 - intersectArea; }` |
| 264 | Minimum Area Rectangle | 939 | https://leetcode.com/problems/minimum-area-rectangle/ | Store points in a HashSet. Iterate over all pairs as potential diagonals. If x and y differ, check if other two corners exist. Compute area and track minimum. Return 0 if no rectangle found. | Diagonal points simplify corner checks. Set ensures O(1) lookup. | Hash Set, Geometry | O(n^2) | O(n) | `Set<String> pointSet = new HashSet<>(); for (int[] point : points) pointSet.add(point[0] + "," + point[1]); long minArea = Long.MAX_VALUE; for (int i = 0; i < points.length; i++) for (int j = i + 1; j < points.length; j++) { int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1]; if (x1 != x2 && y1 != y2 && pointSet.contains(x1 + "," + y2) && pointSet.contains(x2 + "," + y1)) minArea = Math.min(minArea, (long) Math.abs(x1 - x2) * Math.abs(y1 - y2)); } return minArea == Long.MAX_VALUE ? 0 : minArea;` |
| 265 | Rectangle Overlap | 836 | https://leetcode.com/problems/rectangle-overlap/ | Check if rectangles overlap by verifying that neither is completely left, right, above, or below the other. Equivalently, check `x1 < x2' && x1' > x2 && y1 < y2' && y1' > y2`. | Overlap requires intersection in both x and y axes. Simple boundary checks. | Geometry, Conditional Logic | O(1) | O(1) | `boolean isRectangleOverlap(int[] rec1, int[] rec2) { return rec1[0] < rec2[2] && rec1[2] > rec2[0] && rec1[1] < rec2[3] && rec1[3] > rec2[1]; }` |
| 266 | Minimum Height Trees | 310 | https://leetcode.com/problems/minimum-height-trees/ | Use a leaf-trimming approach (BFS). Build adjacency list and degree array. Start with leaves (degree 1). Remove leaves, update degrees, and add new leaves until 1 or 2 nodes remain. | Trim leaves layer by layer to find centroid(s). BFS ensures correctness. | Graph, BFS | O(n) | O(n) | `List<Integer> findMinHeightTrees(int n, int[][] edges) { if (n == 1) return List.of(0); List<Set<Integer>> adj = new ArrayList<>(n); for (int i = 0; i < n; i++) adj.add(new HashSet<>()); int[] degree = new int[n]; for (int[] edge : edges) { adj.get(edge[0]).add(edge[1]); adj.get(edge[1]).add(edge[0]); degree[edge[0]]++; degree[edge[1]]++; } Queue<Integer> leaves = new LinkedList<>(); for (int i = 0; i < n; i++) if (degree[i] == 1) leaves.offer(i); int remaining = n; while (remaining > 2) { int size = leaves.size(); remaining -= size; for (int i = 0; i < size; i++) { int leaf = leaves.poll(); for (int neighbor : adj.get(leaf)) if (--degree[neighbor] == 1) leaves.offer(neighbor); } } return new ArrayList<>(leaves); }` |
| 267 | Parallel Courses III | 2050 | https://leetcode.com/problems/parallel-courses-iii/ | Use topological sort (BFS) on a DAG. Build adjacency list and in-degree array. For each course, track max time to complete (own time + max prerequisite time). Process nodes with in-degree 0, updating neighbors’ times. | Topological sort ensures prerequisite order. Track max finish times dynamically. | Graph, Topological Sort | O(n + E) | O(n + E) | `int minimumTime(int n, int[][] relations, int[] time) { List<List<Integer>> adj = new ArrayList<>(n); for (int i = 0; i < n; i++) adj.add(new ArrayList<>()); int[] inDegree = new int[n]; for (int[] rel : relations) { adj.get(rel[0] - 1).add(rel[1] - 1); inDegree[rel[1] - 1]++; } Queue<Integer> q = new LinkedList<>(); long[] finishTime = new long[n]; for (int i = 0; i < n; i++) if (inDegree[i] == 0) { q.offer(i); finishTime[i] = time[i]; } while (!q.isEmpty()) { int u = q.poll(); for (int v : adj.get(u)) { finishTime[v] = Math.max(finishTime[v], finishTime[u] + time[v]); if (--inDegree[v] == 0) q.offer(v); } } long maxTime = 0; for (long ft : finishTime) maxTime = Math.max(maxTime, ft); return (int) maxTime; }` |
| 268 | Insert Interval | 57 | https://leetcode.com/problems/insert-interval/ | Iterate through intervals. Add non-overlapping intervals before newInterval. Merge overlapping intervals by updating newInterval’s start/end. Add merged interval, then remaining intervals. | Merge by taking min start and max end of overlapping intervals. | Array, Intervals | O(n) | O(n) | `List<int[]> merged = new ArrayList<>(); int i = 0; while (i < intervals.length && intervals[i][1] < newInterval[0]) merged.add(intervals[i++]); while (i < intervals.length && intervals[i][0] <= newInterval[1]) { newInterval[0] = Math.min(newInterval[0], intervals[i][0]); newInterval[1] = Math.max(newInterval[1], intervals[i][1]); i++; } merged.add(newInterval); while (i < intervals.length) merged.add(intervals[i++]); return merged.toArray(new int[merged.size()][]);` |
| 269 | Meeting Rooms | 252 | https://leetcode.com/problems/meeting-rooms/ | Sort intervals by start time. Check for overlaps by ensuring each interval’s start time is >= previous interval’s end time. | Sorting ensures consecutive interval checks catch all overlaps. | Sorting, Intervals | O(n log n) | O(1) | `Arrays.sort(intervals, (a, b) -> a[0] - b[0]); for (int i = 1; i < intervals.length; i++) if (intervals[i][0] < intervals[i - 1][1]) return false; return true;` |
| 270 | Meeting Rooms II | 253 | https://leetcode.com/problems/meeting-rooms-ii/ | Sort intervals by start time. Use a min-heap to track end times of ongoing meetings. For each meeting, if it starts after the earliest end time, reuse a room (remove earliest). Add current end time. Heap size is room count. | Min-heap tracks active meetings. Reuse rooms when possible. | Sorting, Priority Queue | O(n log n) | O(n) | `Arrays.sort(intervals, (a, b) -> a[0] - b[0]); PriorityQueue<Integer> endTimes = new PriorityQueue<>(); endTimes.offer(intervals[0][1]); for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] >= endTimes.peek()) endTimes.poll(); endTimes.offer(intervals[i][1]); } return endTimes.size();` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 271 | Employee Free Time | 759 | https://leetcode.com/problems/employee-free-time/ | Flatten all intervals from employee schedules into one list. Sort by start time. Merge overlapping intervals by tracking the latest end time. Gaps between merged intervals are free times. Handle edge cases: empty schedules or no gaps. | Merge overlapping intervals after sorting. Gaps between merged intervals are the answer. | Intervals, Sorting, Merging Intervals | O(N log N) | O(N) | `List<Interval> allIntervals = new ArrayList<>(); for (List<Interval> schedule : schedule) allIntervals.addAll(schedule); Collections.sort(allIntervals, (a, b) -> a.start - b.start); List<Interval> freeTime = new ArrayList<>(); if (allIntervals.isEmpty()) return freeTime; int prevEnd = allIntervals.get(0).end; for (int i = 1; i < allIntervals.size(); i++) { if (allIntervals.get(i).start > prevEnd) freeTime.add(new Interval(prevEnd, allIntervals.get(i).start)); prevEnd = Math.max(prevEnd, allIntervals.get(i).end); } return freeTime;` |
| 272 | Interval List Intersections | 986 | https://leetcode.com/problems/interval-list-intersections/ | Use two pointers to iterate through both sorted interval lists. For each pair, compute intersection by taking max of starts and min of ends. If intersection is valid (start ≤ end), add to result. Advance pointer of interval with earlier end. Handle empty lists. | Two pointers exploit sorted intervals. Intersection is max(starts) to min(ends). | Two Pointers, Intervals | O(m + n) | O(1) (excluding result) | `List<int[]> result = new ArrayList<>(); int i = 0, j = 0; while (i < firstList.length && j < secondList.length) { int start = Math.max(firstList[i][0], secondList[j][0]); int end = Math.min(firstList[i][1], secondList[j][1]); if (start <= end) result.add(new int[]{start, end}); if (firstList[i][1] < secondList[j][1]) i++; else j++; } return result.toArray(new int[result.size()][]);` |
| 273 | Meeting Scheduler | 1229 | https://leetcode.com/problems/meeting-scheduler/ | Use two pointers on sorted slot lists. For each pair, compute intersection (max of starts, min of ends). If intersection duration ≥ required duration, return first valid slot. Advance pointer of earlier-ending slot. Handle no valid slot. | Intersection of slots must cover duration. Two pointers minimize checks. | Two Pointers, Intervals | O(m log m + n log n) | O(1) | `int i = 0, j = 0; while (i < slots1.length && j < slots2.length) { int start = Math.max(slots1[i][0], slots2[j][0]); int end = Math.min(slots1[i][1], slots2[j][1]); if (start + duration <= end) return new int[]{start, start + duration}; if (slots1[i][1] < slots2[j][1]) i++; else j++; } return new int[]{};` |
| 274 | Count Days Without Meetings | 3169 | https://leetcode.com/problems/count-days-without-meetings/ | Sort meetings by start time. Merge overlapping intervals by tracking latest end time. Sum lengths of merged intervals (days covered). Subtract from total days. Handle edge cases: empty meetings or meetings exceeding days. | Merge overlapping intervals to find covered days. Subtract from total days. | Intervals, Sorting, Merging Intervals | O(n log n) | O(1) | `Arrays.sort(meetings, (a, b) -> a[0] - b[0]); int coveredDays = 0, prevEnd = -1; for (int[] meeting : meetings) { int start = Math.max(prevEnd + 1, meeting[0]), end = meeting[1]; if (start <= end) coveredDays += end - start + 1; prevEnd = Math.max(prevEnd, end); } return days - coveredDays;` |
| 275 | Meeting Rooms III | 2402 | https://leetcode.com/problems/meeting-rooms-iii/ | Sort meetings by start time. Use two min-heaps: one for available rooms (by index), one for busy rooms (by end time, then index). For each meeting, free rooms whose end times ≤ start time. If available rooms exist, use smallest index; else, use earliest-ending room, updating its end time. Track room usage. Return room with max usage. | Two heaps manage room allocation. Greedy choice of earliest available or ending room. | Sorting, Priority Queue, Greedy | O(n log n + m log m) | O(m) | `PriorityQueue<Integer> available = new PriorityQueue<>(); PriorityQueue<long[]> busy = new PriorityQueue<>((a, b) -> a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1])); int[] usage = new int[n]; for (int i = 0; i < n; i++) available.offer(i); Arrays.sort(meetings, (a, b) -> a[0] - b[0]); for (int[] meeting : meetings) { long start = meeting[0], end = meeting[1]; while (!busy.isEmpty() && busy.peek()[0] <= start) available.offer((int) busy.poll()[1]); int room; if (!available.isEmpty()) room = available.poll(); else { long[] earliest = busy.poll(); room = (int) earliest[1]; end = earliest[0] + (end - start); } busy.offer(new long[]{end, room}); usage[room]++; } int maxRoom = 0; for (int i = 1; i < n; i++) if (usage[i] > usage[maxRoom]) maxRoom = i; return maxRoom;` |
| 276 | Binary Search Tree Iterator | 173 | https://leetcode.com/problems/binary-search-tree-iterator/ | Use a stack for inorder traversal. Initialize by pushing root and all left children. `next()` pops top node, returns value, pushes right child and its left children. `hasNext()` checks stack emptiness. | Stack simulates inorder traversal, pushing left children for next smallest. | Tree Traversal, Stack, Design | O(1) amortized | O(h) | `Stack<TreeNode> stack = new Stack<>(); public BSTIterator(TreeNode root) { pushLeft(root); } private void pushLeft(TreeNode node) { while (node != null) { stack.push(node); node = node.left; } } public int next() { TreeNode node = stack.pop(); pushLeft(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); }` |
| 277 | Convert Binary Search Tree to Sorted Doubly Linked List | 426 | https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/ | Use inorder traversal to visit nodes in sorted order. Track `first` (head) and `prev` (last processed node). Link `prev.right` to current, `current.left` to `prev`. After traversal, connect `first` and last node for circular list. | Inorder traversal ensures sorted order. Track prev to link nodes dynamically. | Tree Traversal, Doubly Linked List | O(n) | O(h) | `Node first = null, prev = null; public Node treeToDoublyList(Node root) { if (root == null) return null; inorder(root); prev.right = first; first.left = prev; return first; } private void inorder(Node node) { if (node == null) return; inorder(node.left); if (prev == null) first = node; else { prev.right = node; node.left = prev; } prev = node; inorder(node.right); }` |
| 278 | Inorder Successor in BST II | 510 | https://leetcode.com/problems/inorder-successor-in-bst-ii/ | If node has right child, successor is leftmost node in right subtree. Else, traverse up until moving from left child to parent (or null). Handle edge cases: no successor or single node. | Right subtree’s leftmost node or first left-to-parent ancestor. | Tree Traversal, Parent Pointers | O(h) | O(1) | `Node inorderSuccessor(Node node) { if (node.right != null) { Node curr = node.right; while (curr.left != null) curr = curr.left; return curr; } Node curr = node; while (curr.parent != null && curr == curr.parent.right) curr = curr.parent; return curr.parent; }` |
| 279 | Closest Binary Search Tree Value | 270 | https://leetcode.com/problems/closest-binary-search-tree-value/ | Traverse BST iteratively. At each node, update closest if current value is closer to target. Move left if target < value, else right. Handle edge cases: empty tree or exact match. | BST properties guide traversal toward target. Update closest on smaller differences. | Tree Traversal, Binary Search | O(h) | O(1) | `int closest = root.val; TreeNode curr = root; while (curr != null) { closest = Math.abs(target - curr.val) < Math.abs(target - closest) ? curr.val : closest; curr = target < curr.val ? curr.left : curr.right; } return closest;` |
| 280 | Closest Binary Search Tree Value II | 272 | https://leetcode.com/problems/closest-binary-search-tree-value-ii/ | Use two stacks: one for inorder traversal (≤ target), one for reverse inorder (> target). Initialize by pushing nodes along paths. Pop from stack with value closer to target, add to result, push next nodes. Repeat k times. | Two stacks simulate inorder and reverse inorder, picking closest values. | Tree Traversal, Two Stacks | O(h + k) | O(h) | `Stack<TreeNode> s1 = new Stack<>(), s2 = new Stack<>(); List<Integer> result = new ArrayList<>(); pushLess(root, target, s1); pushGreater(root, target, s2); while (k-- > 0 && (!s1.isEmpty() || !s2.isEmpty())) { double diff1 = s1.isEmpty() ? Double.MAX_VALUE : target - s1.peek().val; double diff2 = s2.isEmpty() ? Double.MAX_VALUE : s2.peek().val - target; if (diff1 <= diff2) { TreeNode node = s1.pop(); result.add(node.val); pushLess(node.right, target, s1); } else { TreeNode node = s2.pop(); result.add(node.val); pushGreater(node.left, target, s2); } } return result; void pushLess(TreeNode node, double target, Stack<TreeNode> stack) { while (node != null) { if (node.val <= target) stack.push(node); node = node.val <= target ? node.left : node.right; } } void pushGreater(TreeNode node, double target, Stack<TreeNode> stack) { while (node != null) { if (node.val > target) stack.push(node); node = node.val > target ? node.right : node.left; } }` |
| 281 | Verify Preorder Sequence in Binary Search Tree | 255 | https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/ | Use stack to track nodes in right subtrees. Maintain lower bound. For each value, ensure it’s > lower bound. If > stack top, pop and update lower bound to last popped (parent of right subtree). Push current value. | Stack tracks right subtree parents. Lower bound ensures BST property. | Stack, BST Properties | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int lowerBound = Integer.MIN_VALUE; for (int val : preorder) { if (val < lowerBound) return false; while (!stack.isEmpty() && val > stack.peek()) lowerBound = stack.pop(); stack.push(val); } return true;` |
| 282 | Verify Preorder Serialization of a Binary Tree | 331 | https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/ | Track available slots (initially 1 for root). For each node, consume 1 slot. Non-null nodes add 2 slots; null nodes (#) add 0. Slots must not go negative and must be 0 at end. | Slots represent available child positions. Non-null adds 2, null consumes 1. | String Parsing, Tree Properties | O(n) | O(1) | `int slots = 1; String[] nodes = preorder.split(","); for (String node : nodes) { slots--; if (slots < 0) return false; if (!node.equals("#")) slots += 2; } return slots == 0;` |
| 283 | Implementing Forward Iterator in BST | N/A | https://www.geeksforgeeks.org/implementing-forward-iterator-in-bst/ | Same as BST Iterator (276). Use stack for inorder traversal. Initialize by pushing root and left children. `next()` pops node, returns value, pushes right child and its left children. `hasNext()` checks stack. | Stack maintains inorder sequence. Push left children for next smallest. | Tree Traversal, Stack, Design | O(1) amortized | O(h) | `Stack<TreeNode> stack = new Stack<>(); public BSTIterator(TreeNode root) { pushLeft(root); } private void pushLeft(TreeNode node) { while (node != null) { stack.push(node); node = node.left; } } public int next() { TreeNode node = stack.pop(); pushLeft(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); }` |
| 284 | Kth Smallest Element in BST Using O(1) Extra Space | N/A | https://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/ | Use Morris inorder traversal. Temporarily thread predecessors to current node. Count nodes visited. When k-th node is reached, return its value. Restore tree by breaking threads. | Morris traversal avoids stack/recursion by threading. Count nodes in inorder. | Tree Traversal, Morris Inorder | O(n) | O(1) | `TreeNode curr = root; int count = 0; while (curr != null) { if (curr.left == null) { if (++count == k) return curr.val; curr = curr.right; } else { TreeNode pred = curr.left; while (pred.right != null && pred.right != curr) pred = pred.right; if (pred.right == null) { pred.right = curr; curr = curr.left; } else { pred.right = null; if (++count == k) return curr.val; curr = curr.right; } } } return -1;` |
| 285 | Construct BST from Given Preorder Traversal | N/A | https://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-1/ | Iterative approach with stack. Push root. For each value, if < stack top, it’s left child; push it. If > stack top, pop until stack empty or top < value; last popped is parent, current is its right child. Push current. | Stack tracks rightmost path. Compare with top to decide left/right child. | Stack, Tree Construction | O(n) | O(n) | `Stack<TreeNode> stack = new Stack<>(); TreeNode root = new TreeNode(preorder[0]); stack.push(root); for (int i = 1; i < preorder.length; i++) { TreeNode node = new TreeNode(preorder[i]); TreeNode parent = null; while (!stack.isEmpty() && node.val > stack.peek().val) parent = stack.pop(); if (parent != null) parent.right = node; else stack.peek().left = node; stack.push(node); } return root;` |
| 286 | Count BST Subtrees that Lie in Given Range | N/A | https://www.geeksforgeeks.org/count-bst-subtrees-that-lie-in-given-range/ | Post-order traversal. For each node, check if entire subtree is within [low, high] by ensuring node value and all descendants are in range. If valid, increment count. Use helper to verify subtree validity. | Validate entire subtree recursively. Count valid subtrees in post-order. | Tree Traversal, Recursion | O(n) | O(h) | `int count = 0; public int countValidSubtrees(TreeNode root, int low, int high) { countValidSubtrees(root, low, high); return count; } private void countValidSubtrees(TreeNode node, int low, int high) { if (node == null) return; if (isValid(node, low, high)) count++; countValidSubtrees(node.left, low, high); countValidSubtrees(node.right, low, high); } private boolean isValid(TreeNode node, int low, int high) { if (node == null) return true; if (node.val < low || node.val > high) return false; return isValid(node.left, low, high) && isValid(node.right, low, high); }` |
| 287 | Largest BST in a Binary Tree | N/A | https://www.geeksforgeeks.org/find-the-largest-bst-subtree-in-a-binary-tree/ | Post-order traversal. For each node, get from children: isBST, size, min, max. If current node forms BST (left.isBST, right.isBST, node.val > left.max, node.val < right.min), compute size and update max BST size. Else, propagate max child size. | Post-order combines child info to validate BST and track largest size. | Tree Traversal, Postorder | O(n) | O(h) | `class Result { boolean isBST; int size, min, max; Result(boolean isBST, int size, int min, int max) { this.isBST = isBST; this.size = size; this.min = min; this.max = max; } } int maxSize = 0; public int largestBST(TreeNode root) { largestBSTUtil(root); return maxSize; } private Result largestBSTUtil(TreeNode node) { if (node == null) return new Result(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE); Result left = largestBSTUtil(node.left); Result right = largestBSTUtil(node.right); if (left.isBST && right.isBST && node.val > left.max && node.val < right.min) { int size = left.size + right.size + 1; maxSize = Math.max(maxSize, size); return new Result(true, size, Math.min(node.val, left.min), Math.max(node.val, right.max)); } return new Result(false, Math.max(left.size, right.size), 0, 0); }` |
| 288 | Check if Given Array Can Represent Level Order Traversal of Binary Search Tree | N/A | https://www.geeksforgeeks.org/check-if-given-array-can-represent-level-order-traversal-of-binary-search-tree/ | Use queue to simulate level-order construction. For each node, track valid range [min, max]. Dequeue node; next array elements are left/right children. Ensure they fit BST ranges (left: [min, parent), right: (parent, max]). Enqueue valid children. Check all elements used. | Queue tracks nodes and ranges. Validate children against BST constraints. | Queue, Level Order Traversal | O(n) | O(n) | `class NodeInfo { int val, min, max; NodeInfo(int val, int min, int max) { this.val = val; this.min = min; this.max = max; } } Queue<NodeInfo> q = new LinkedList<>(); q.offer(new NodeInfo(arr[0], Integer.MIN_VALUE, Integer.MAX_VALUE)); int i = 1; while (!q.isEmpty() && i < arr.length) { NodeInfo curr = q.poll(); if (i < arr.length && arr[i] > curr.min && arr[i] < curr.val) { q.offer(new NodeInfo(arr[i], curr.min, curr.val)); i++; } else if (i < arr.length && (arr[i] <= curr.min || arr[i] >= curr.val)) return false; if (i < arr.length && arr[i] > curr.val && arr[i] < curr.max) { q.offer(new NodeInfo(arr[i], curr.val, curr.max)); i++; } else if (i < arr.length && (arr[i] <= curr.val || arr[i] >= curr.max)) return false; } return i == arr.length;` |
| 289 | Next Permutation | 31 | https://leetcode.com/problems/next-permutation/ | Find largest k where nums[k] < nums[k+1]. If none, reverse array. Find largest l > k where nums[k] < nums[l]. Swap nums[k] and nums[l]. Reverse from k+1 to end. | Find pivot, swap with next greater element, reverse suffix for next permutation. | Array Manipulation, In-place Algorithm | O(n) | O(1) | `int k = nums.length - 2; while (k >= 0 && nums[k] >= nums[k + 1]) k--; if (k < 0) { reverse(nums, 0, nums.length - 1); return; } int l = nums.length - 1; while (l > k && nums[l] <= nums[k]) l--; swap(nums, k, l); reverse(nums, k + 1, nums.length - 1); void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } void reverse(int[] nums, int start, int end) { while (start < end) swap(nums, start++, end--); }` |
| 290 | Remove Duplicates from Sorted Array | 26 | https://leetcode.com/problems/remove-duplicates-from-sorted-array/ | Use two pointers: i for next unique element position, j to scan array. If nums[j] != nums[i-1], copy to nums[i] and increment i. Return i. Handle empty/single-element arrays. | Two pointers: write unique elements while scanning sorted array. | Two Pointers, Array Manipulation | O(n) | O(1) | `if (nums.length == 0) return 0; int i = 1; for (int j = 1; j < nums.length; j++) { if (nums[j] != nums[i - 1]) nums[i++] = nums[j]; } return i;` |
| 291 | Remove Element | 27 | https://leetcode.com/problems/remove-element/ | Use two pointers: i for next non-val position, j to scan array. If nums[j] != val, copy to nums[i] and increment i. Return i. Handle empty array. | Two pointers: write non-val elements while scanning. | Two Pointers, Array Manipulation | O(n) | O(1) | `int i = 0; for (int j = 0; j < nums.length; j++) { if (nums[j] != val) nums[i++] = nums[j]; } return i;` |
| 292 | First Missing Positive | 41 | https://leetcode.com/problems/first-missing-positive/ | Use array as hash table. For each nums[i], if 1 ≤ nums[i] ≤ n, place at index nums[i]-1 via swaps. First index i where nums[i] != i+1 gives missing i+1. Else, n+1. | Array as hash: place x at index x-1. First mismatch reveals missing positive. | Array Manipulation, In-place Hash | O(n) | O(1) | `int n = nums.length; for (int i = 0; i < n; i++) { while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { int temp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = temp; } } for (int i = 0; i < n; i++) { if (nums[i] != i + 1) return i + 1; } return n + 1;` |
| 293 | Missing Number | 268 | https://leetcode.com/problems/missing-number/ | Use XOR: XOR all numbers 0 to n with array elements. Paired numbers cancel, leaving missing number. Alternatively, use sum: n*(n+1)/2 minus array sum. | XOR cancels paired numbers, revealing missing one. | Bit Manipulation, Arithmetic | O(n) | O(1) | `int result = nums.length; for (int i = 0; i < nums.length; i++) result ^= i ^ nums[i]; return result;` |
| 294 | Maximum Product Subarray | 152 | https://leetcode.com/problems/maximum-product-subarray/ | Track max and min products ending at each index, as negative numbers can swap their roles. Update maxProd, minProd with current number and products. Track global max. | Maintain max/min products to handle negative numbers. Update global max. | Dynamic Programming | O(n) | O(1) | `int maxProd = nums[0], minProd = nums[0], result = nums[0]; for (int i = 1; i < nums.length; i++) { int num = nums[i]; if (num < 0) { int temp = maxProd; maxProd = minProd; minProd = temp; } maxProd = Math.max(num, maxProd * num); minProd = Math.min(num, minProd * num); result = Math.max(result, maxProd); } return result;` |
| 295 | Find the Smallest Positive Number Missing from an Unsorted Array | N/A | https://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/ | Identical to First Missing Positive (292). Use array as hash table. Place nums[i] at index nums[i]-1 if 1 ≤ nums[i] ≤ n. First nums[i] != i+1 gives i+1, else n+1. | Array as hash: place x at x-1. Mismatch reveals smallest missing positive. | Array Manipulation, In-place Hash | O(n) | O(1) | `int n = arr.length; for (int i = 0; i < n; i++) { while (arr[i] > 0 && arr[i] <= n && arr[arr[i] - 1] != arr[i]) { int temp = arr[arr[i] - 1]; arr[arr[i] - 1] = arr[i]; arr[i] = temp; } } for (int i = 0; i < n; i++) { if (arr[i] != i + 1) return i + 1; } return n + 1;` |
| 296 | Find a Repeating and a Missing Number | N/A | https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/ | Use array as markers. For each abs(arr[i]), mark index abs(arr[i])-1 by negating. If already negative, abs(arr[i]) is repeating. After, positive index i means i+1 is missing. | Negate indices to mark visits. Repeated visits reveal repeating; positive indices reveal missing. | Array Manipulation, In-place Markers | O(n) | O(1) | `int repeating = -1, missing = -1; for (int i = 0; i < arr.length; i++) { int index = Math.abs(arr[i]) - 1; if (arr[index] > 0) arr[index] = -arr[index]; else repeating = Math.abs(arr[i]); } for (int i = 0; i < arr.length; i++) { if (arr[i] > 0) { missing = i + 1; break; } } return new int[]{repeating, missing};` |
| 297 | Make Array Non-decreasing | 3165 | https://leetcode.com/problems/make-array-non-decreasing/ | Check if array can be non-decreasing with ≤ 1 modification. Count violations (nums[i] > nums[i+1]). If > 1, return false. For one violation, try decreasing nums[i] if nums[i-1] ≤ nums[i+1]; else, increase nums[i+1]. | Greedy fix at first violation: decrease i or increase i+1 based on neighbors. | Array Iteration, Greedy | O(n) | O(1) | `int violations = 0; for (int i = 0; i < nums.length - 1; i++) { if (nums[i] > nums[i + 1]) { if (violations++ > 0) return false; if (i > 0 && nums[i - 1] > nums[i + 1]) nums[i + 1] = nums[i]; else nums[i] = nums[i + 1]; } } return true;` |
| 298 | Minimum Operations to Make Numbers Non-positive | 2606 | https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal-to-0/ | For each operation, select a subarray and subtract 1 from its elements. Greedy approach: for each positive element, apply operation to minimal subarray starting at its index. Track operations needed per prefix. | Each positive element requires an operation starting at its index or earlier. | Array Iteration, Greedy | O(n) | O(1) | `int count = 0; for (int i = 0; i < nums.length; i++) { if (nums[i] > 0) { count++; nums[i]--; } } return count;` |
| 299 | Minimum Operations to Reduce an Integer to 0 | 2571 | https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/ | Use binary representation. For each set bit, decide to subtract 2^i or add 2^i to clear it. Greedy: for consecutive 1s, adding higher power (carry) is often optimal. Count operations while shifting bits. | Greedy bit manipulation: clear lowest 1 by subtracting or adding based on bit pattern. | Bit Manipulation, Greedy | O(log n) | O(1) | `int ops = 0; while (n > 0) { if ((n & 1) == 0) n >>= 1; else if ((n & 2) == 0) { n >>= 1; ops++; } else { n++; ops++; } } return ops;` |
| 300 | Minimum Number of Operations to Make Elements in Array Distinct | 3168 | https://leetcode.com/problems/minimum-number-of-operations-to-make-array-elements-distinct/ | Sort array. Iterate: if nums[i] ≤ nums[i-1], increment nums[i] to nums[i-1]+1. Sum increments. Track operations without modifying array by using expected value. | After sorting, ensure each element is > previous by incrementing. Sum increments. | Sorting, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); long moves = 0, prev = nums[0]; for (int i = 1; i < nums.length; i++) { if (nums[i] <= prev) { moves += prev + 1 - nums[i]; prev++; } else prev = nums[i]; } return (int) moves;` |
| 301 | Minimum Pair Removal to Sort Array I | 3172 | https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/ | Minimum removals = n - length of longest non-decreasing subsequence (LNDS). Use patience sorting: maintain tails of non-decreasing subsequences via binary search. | LNDS length via patience sorting. Removals = n - LNDS length. | Dynamic Programming, Binary Search | O(n log n) | O(n) | `List<Integer> tails = new ArrayList<>(); for (int num : nums) { int low = 0, high = tails.size(); while (low < high) { int mid = low + (high - low) / 2; if (tails.get(mid) <= num) low = mid + 1; else high = mid; } if (low == tails.size()) tails.add(num); else tails.set(low, num); } return nums.length - tails.size();` |
| 302 | Minimum Array Length After Pair Removals | 2856 | https://leetcode.com/problems/minimum-array-length-after-pair-removals/ | Sort array. Use two pointers: i from start, j from middle. Pair nums[i] with nums[j] if nums[i] < nums[j]. Count pairs. Remaining length = n - 2 * pairs. | Pair smallest with larger elements from second half. Count pairs to find remaining length. | Sorting, Two Pointers, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); int n = nums.length, count = 0, i = 0, j = (n + 1) / 2; while (i < (n + 1) / 2 && j < n) { if (nums[i] < nums[j]) { count++; i++; j++; } else j++; } return n - 2 * count;` |
| 303 | Zero Array Transformation I | N/A | https://www.geeksforgeeks.org/zero-array-transformation-i/ | Assuming operation: subtract 1 from elements ≥ index i to make all zeros. For each positive element, an operation starting at its index is needed. Count operations by iterating and decrementing positive elements. | Each positive element requires an operation starting at its index or earlier. | Array Iteration, Greedy | O(n) | O(1) | `int count = 0; for (int i = 0; i < arr.length; i++) { if (arr[i] > 0) { count++; arr[i]--; } } return count;` |
| 304 | Remove Stones to Minimize the Total | 1962 | https://leetcode.com/problems/remove-stones-to-minimize-the-total/ | Use max-heap to track pile sizes. For k operations, remove max pile, reduce by floor(size/2), reinsert. Sum remaining piles. | Max-heap ensures largest pile is reduced, maximizing stone removal. | Priority Queue, Greedy | O(k log n) | O(n) | `PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a); for (int pile : piles) pq.offer(pile); for (int i = 0; i < k; i++) { int max = pq.poll(); pq.offer(max - max / 2); } int total = 0; while (!pq.isEmpty()) total += pq.poll(); return total;` |
| 305 | Sort an Array | 912 | https://leetcode.com/problems/sort-an-array/ | Use Merge Sort for guaranteed O(n log n). Divide array, recursively sort halves, merge by comparing elements. Handle base case (size ≤ 1). | Merge Sort divides, sorts, and merges for stable O(n log n) sorting. | Sorting, Merge Sort | O(n log n) | O(n) | `public int[] sortArray(int[] nums) { mergeSort(nums, 0, nums.length - 1); return nums; } private void mergeSort(int[] nums, int left, int right) { if (left >= right) return; int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); merge(nums, left, mid, right); } private void merge(int[] nums, int left, int mid, int right) { int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; while (i <= mid && j <= right) temp[k++] = nums[i] <= nums[j] ? nums[i++] : nums[j++]; while (i <= mid) temp[k++] = nums[i++]; while (j <= right) temp[k++] = nums[j++]; for (k = 0; k < temp.length; k++) nums[left + k] = temp[k]; }` |
| 306 | Sort Transformed Array | 360 | https://leetcode.com/problems/sort-transformed-array/ | Apply f(x) = ax² + bx + c to sorted array. If a ≥ 0, parabola opens up, max values at ends; if a < 0, min values at ends. Use two pointers (start, end) to fill result array from end (a ≥ 0) or start (a < 0). | Two pointers leverage parabola shape. Fill result from extremes based on a. | Two Pointers, Math | O(n) | O(n) | `int[] result = new int[nums.length]; int i = 0, j = nums.length - 1, k = a >= 0 ? nums.length - 1 : 0; while (i <= j) { int leftVal = a * nums[i] * nums[i] + b * nums[i] + c; int rightVal = a * nums[j] * nums[j] + b * nums[j] + c; if (a >= 0) { result[k--] = leftVal >= rightVal ? leftVal : rightVal; if (leftVal >= rightVal) i++; else j--; } else { result[k++] = leftVal <= rightVal ? leftVal : rightVal; if (leftVal <= rightVal) i++; else j--; } } return result;` |
| 307 | Nearly Sorted Algorithm (Sort a K-Sorted Array) | N/A | https://www.geeksforgeeks.org/nearly-sorted-algorithm/ | Use min-heap of size k+1. Add first k+1 elements. For each remaining element, extract min, add to result, insert next element. Extract remaining heap elements. | Min-heap maintains k+1 elements, ensuring smallest is next in sorted order. | Priority Queue, Sorting | O(n log k) | O(k) | `PriorityQueue<Integer> pq = new PriorityQueue<>(); for (int i = 0; i < Math.min(k + 1, arr.length); i++) pq.offer(arr[i]); int index = 0; for (int i = k + 1; i < arr.length; i++) { arr[index++] = pq.poll(); pq.offer(arr[i]); } while (!pq.isEmpty()) arr[index++] = pq.poll();` |
| 308 | Shuffle a Given Array Using Fisher-Yates Shuffle Algorithm | N/A | https://www.geeksforgeeks.org/shuffle-a-given-array-using-fisher-yates-shuffle-algorithm/ | Fisher-Yates shuffle: iterate from end to start. For each index i, swap with random index from 0 to i. Ensures uniform randomization. | Swap with random index in remaining unshuffled portion for unbiased shuffle. | Fisher-Yates Shuffle | O(n) | O(1) | `Random rand = new Random(); for (int i = arr.length - 1; i > 0; i--) { int j = rand.nextInt(i + 1); int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }` |
| 309 | Find Index of 0 to be Replaced with 1 to Get Longest Continuous Sequence of 1s in a Binary Array | N/A | https://www.geeksforgeeks.org/find-index-of-0-to-be-replaced-with-1-to-get-longest-continuous-sequence-of-1s-in-a-binary-array/ | Track current and previous sequences of 1s separated by a 0. When a 0 is encountered, compute length if flipped (prevOnes + currOnes + 1). Update max length and index. | Track 1s segments around a 0. Flipping 0 combines segments for max length. | Sliding Window, Array Iteration | O(n) | O(1) | `int maxLen = 0, index = -1, currOnes = 0, prevOnes = 0; for (int i = 0; i < arr.length; i++) { if (arr[i] == 1) currOnes++; else { if (currOnes + prevOnes + 1 > maxLen) { maxLen = currOnes + prevOnes + 1; index = i; } prevOnes = currOnes; currOnes = 0; } } if (currOnes + prevOnes + 1 > maxLen) { maxLen = currOnes + prevOnes + 1; index = arr.length - 1; } return index;` |
| 310 | Rearrange Array Maximum Minimum Form | N/A | https://www.geeksforgeeks.org/rearrange-array-maximum-minimum-form/ | Sort array. Use two pointers: one at start (min), one at end (max). Fill result array alternating max, min. For O(1) space, encode max/min in array using modular arithmetic (maxVal + 1). | Alternate max/min from sorted array. Encode for O(1) space using modular trick. | Two Pointers, Array Manipulation | O(n log n) or O(n) with encoding | O(n) or O(1) | `Arrays.sort(arr); int[] result = new int[arr.length]; int i = 0, j = arr.length - 1, k = 0; while (i <= j) { if (k % 2 == 0) result[k++] = arr[j--]; else result[k++] = arr[i++]; } return result;` |



| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 311 | Max Sum of a Pair With Equal Sum of Digits | 2342 | https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/ | Use a hash map to group numbers by digit sum. For each number, compute its digit sum, add to map’s list. Track two largest numbers per digit sum to avoid sorting. If a digit sum has ≥2 numbers, compute their sum and update max. Handle no valid pairs (-1). | Track top two numbers per digit sum to avoid sorting. Update max sum when ≥2 numbers exist. | Hash Map, Array Iteration, Digit Sum | O(n * log M) | O(n) | `Map<Integer, int[]> map = new HashMap<>(); int maxSum = -1; for (int num : nums) { int sum = 0, temp = num; while (temp > 0) { sum += temp % 10; temp /= 10; } int[] top = map.computeIfAbsent(sum, k -> new int[]{0, 0}); if (num > top[0]) { top[1] = top[0]; top[0] = num; } else if (num > top[1]) top[1] = num; if (top[1] > 0) maxSum = Math.max(maxSum, top[0] + top[1]); } return maxSum;` |
| 312 | Number of Divisible Triplet Sums | 2177 | https://leetcode.com/problems/number-of-triples-with-sum-divisible-by-k/ | For each index j, compute remainders needed for nums[l] (l > j) so (nums[i] + nums[j] + nums[l]) % k == 0. Use a map to count remainders of nums[l] after j. For each i < j, compute (nums[i] + nums[j]) % k, find needed remainder for l, and add map’s count. Precompute remainders for efficiency. | Precompute remainders for l > j. Use map to count valid nums[l] per remainder. | Modular Arithmetic, Hash Map, Counting | O(n²) | O(k + n) | `long count = 0; for (int j = 1; j < nums.length - 1; j++) { Map<Integer, Integer> remainders = new HashMap<>(); for (int l = j + 1; l < nums.length; l++) remainders.merge(nums[l] % k, 1, Integer::sum); for (int i = 0; i < j; i++) { int sum = (nums[i] + nums[j]) % k; int needed = (k - sum) % k; count += remainders.getOrDefault(needed, 0); } } return count;` |
| 313 | Count Good Triplets | 1530 | https://leetcode.com/problems/count-good-triplets/ | Iterate all triplets (i, j, k) with i < j < k. Check if |arr[i] - arr[j]| ≤ a, |arr[j] - arr[k]| ≤ b, and |arr[i] - arr[k]| ≤ c. Increment count if all conditions hold. Optimize by breaking inner loops early if conditions fail. Handle small arrays (n < 3). | Brute force with early termination on failed conditions to reduce checks. | Array Iteration, Brute Force | O(n³) | O(1) | `int count = 0; for (int i = 0; i < arr.length - 2; i++) { for (int j = i + 1; j < arr.length - 1; j++) { if (Math.abs(arr[i] - arr[j]) <= a) { for (int k = j + 1; k < arr.length; k++) { if (Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c) count++; } } } } return count;` |
| 314 | Count Good Triplets in an Array | 2178 | https://leetcode.com/problems/count-good-triplets-in-an-array/ | For each middle element nums[j], count smaller elements to left (i < j) and larger to right (k > j). Use Fenwick Tree for O(log n) updates/queries. Iterate j, query left smaller count, right larger count, multiply for triplets with j as middle. Update Fenwick Trees after processing j. | Fenwick Tree tracks smaller/larger counts efficiently. Product of counts gives triplets per j. | Fenwick Tree, Array Iteration, Counting | O(n log n) | O(n) | `int n = nums.length; int[] left = new int[n + 1], right = new int[n + 1]; long count = 0; for (int j = 0; j < n; j++) { int smallerLeft = query(left, nums[j] - 1); int largerRight = query(right, n) - query(right, nums[j]); count += (long) smallerLeft * largerRight; update(right, nums[j], 1); } for (int j = 0; j < n; j++) update(left, nums[j], 1); return (int) count; void update(int[] fenwick, int idx, int val) { for (idx++; idx < fenwick.length; idx += idx & -idx) fenwick[idx] += val; } int query(int[] fenwick, int idx) { int sum = 0; for (idx = Math.min(idx + 1, fenwick.length - 1); idx > 0; idx -= idx & -idx) sum += fenwick[idx]; return sum; }` |
| 315 | Count Nice Pairs in an Array | 1814 | https://leetcode.com/problems/count-nice-pairs-in-an-array/ | Compute diff = num - rev(num) for each num. Use a map to count frequencies of diff. For each num, add (freq of its diff - 1) to count (pairs with previous nums). Update map. Apply modulo 10^9 + 7. Handle negative diffs and large numbers. | Group by num - rev(num). Count pairs as n * (n-1) / 2 per frequency. | Hash Map, Number Reversal, Counting | O(n * log M) | O(n) | `long count = 0, MOD = 1_000_000_007; Map<Integer, Integer> map = new HashMap<>(); for (int num : nums) { int rev = 0, temp = num; while (temp > 0) { rev = rev * 10 + temp % 10; temp /= 10; } int diff = num - rev; count = (count + map.getOrDefault(diff, 0)) % MOD; map.merge(diff, 1, Integer::sum); } return (int) count;` |
| 316 | Count Equal and Divisible Pairs in an Array | 2176 | https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/ | Iterate all pairs (i, j) with i < j. Check if nums[i] == nums[j] and (i * j) % k == 0. Increment count if both hold. Optimize by grouping equal values to reduce iterations. | Brute force with condition checks. Grouping by value can optimize for sparse values. | Array Iteration, Brute Force | O(n²) | O(1) | `int count = 0; for (int i = 0; i < nums.length; i++) { for (int j = i + 1; j < nums.length; j++) { if (nums[i] == nums[j] && (i * j) % k == 0) count++; } } return count;` |
| 317 | Count the Number of Fair Pairs | 2563 | https://leetcode.com/problems/count-the-number-of-fair-pairs/ | Sort array. For each nums[i], find j > i where lower ≤ nums[i] + nums[j] ≤ upper using binary search for bounds (lower - nums[i], upper - nums[i]). Count valid j’s. Alternatively, use two pointers after sorting for O(n) counting post-sort. | Binary search or two pointers on sorted array to count valid pair sums. | Sorting, Binary Search, Two Pointers | O(n log n) | O(1) | `Arrays.sort(nums); long count = 0; for (int i = 0; i < nums.length; i++) { int left = Arrays.binarySearch(nums, i + 1, nums.length, lower - nums[i]); int right = Arrays.binarySearch(nums, i + 1, nums.length, upper - nums[i] + 1); if (left < 0) left = -(left + 1); if (right < 0) right = -(right + 1); count += right - left; } return count / 2;` |
| 318 | Count Subarrays With Score Less Than K | 2302 | https://leetcode.com/problems/count-subarrays-with-score-less-than-k/ | Use sliding window. Expand right, update sum. Compute score = sum * (right - left + 1). If score ≥ k, shrink left, subtract nums[left] from sum. When score < k, add (right - left + 1) to count (subarrays ending at right). Handle empty arrays or k ≤ 0. | Sliding window tracks sum and length. Count valid subarrays when score < k. | Sliding Window, Array Iteration | O(n) | O(1) | `long count = 0, sum = 0; int left = 0; for (int right = 0; right < nums.length; right++) { sum += nums[right]; while (sum * (right - left + 1) >= k && left <= right) sum -= nums[left++]; count += right - left + 1; } return count;` |
| 319 | Count Subarrays With Fixed Bounds | 2444 | https://leetcode.com/problems/count-subarrays-with-fixed-bounds/ | Iterate right endpoint j. Track latest indices of minK, maxK, and bad element (outside [minK, maxK]). For each j, valid left endpoints are after bad_idx and up to min(minK_idx, maxK_idx). Count = max(0, min(minK_idx, maxK_idx) - bad_idx). Sum counts. | Track latest minK, maxK, bad indices. Count valid left endpoints per right endpoint. | Sliding Window, Index Tracking | O(n) | O(1) | `long count = 0; int minIdx = -1, maxIdx = -1, badIdx = -1; for (int j = 0; j < nums.length; j++) { if (nums[j] == minK) minIdx = j; if (nums[j] == maxK) maxIdx = j; if (nums[j] < minK || nums[j] > maxK) badIdx = j; if (minIdx != -1 && maxIdx != -1) count += Math.max(0, Math.min(minIdx, maxIdx) - badIdx); } return count;` |
| 320 | Count Subarrays Where Max Element Appears at Least K Times | 2962 | https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/ | Find max element. Use sliding window. Expand right, count max occurrences. When count ≥ k, all subarrays from left to right are valid. Shrink left while count ≥ k, updating count. Add (left + 1) to result per valid window (number of valid start points). | Sliding window tracks max count. Count start points when max appears ≥ k times. | Sliding Window, Array Iteration | O(n) | O(1) | `int max = Arrays.stream(nums).max().getAsInt(); long count = 0; int left = 0, maxCount = 0; for (int right = 0; right < nums.length; right++) { if (nums[right] == max) maxCount++; while (maxCount >= k && left <= right) { count += left + 1; if (nums[left] == max) maxCount--; left++; } } return count;` |
| 321 | Count the Number of Good Subarrays | 2537 | https://leetcode.com/problems/count-the-number-of-good-subarrays/ | Use sliding window. Expand right, update frequency map and pair count (freq * (freq - 1) / 2). When pairs ≥ k, add (right - left + 1) to count. Shrink left, update pairs by reducing freq. Handle empty arrays or k = 0. | Sliding window with frequency map tracks pairs. Count subarrays when pairs ≥ k. | Sliding Window, Frequency Map | O(n) | O(n) | `long count = 0; Map<Integer, Integer> freq = new HashMap<>(); long pairs = 0; int left = 0; for (int right = 0; right < nums.length; right++) { int f = freq.merge(nums[right], 1, Integer::sum); pairs += f - 1; while (pairs >= k && left <= right) { count += right - left + 1; f = freq.merge(nums[left], -1, Integer::sum); pairs -= f; if (f == 0) freq.remove(nums[left]); left++; } } return count;` |
| 322 | Count the Number of Good Subsequences | 2543 | https://leetcode.com/problems/count-the-number-of-good-subsequences/ | Count subsequences with GCD = 1, length ≥ 2. Use frequency map of numbers. For each number x with freq f, count subsequences using (f choose k) for k ≥ 1. Compute GCD across subsets. Use DP: dp[g] = count of subsequences with GCD g. Update dp[g] for each x by computing gcd(g’, x). Subtract single-element subsequences. Apply modulo. | DP on GCD. Use combinatorics for subsequence counts per number. Update GCD counts. | Dynamic Programming, GCD, Combinatorics | O(n * maxVal * log maxVal) | O(maxVal) | `Map<Integer, Integer> freq = new HashMap<>(); for (int num : nums) freq.merge(num, 1, Integer::sum); long[] dp = new long[100001]; long MOD = 1_000_000_007; dp[0] = 1; for (int x : freq.keySet()) { long[] newDp = dp.clone(); int f = freq.get(x); for (int g = 0; g <= 100000; g++) { if (dp[g] == 0) continue; for (int k = 1; k <= f; k++) { newDp[gcd(g, x * k)] = (newDp[gcd(g, x * k)] + dp[g] * comb(f, k)) % MOD; } } dp = newDp; } long result = (dp[1] - freq.getOrDefault(1, 0) + MOD) % MOD; return (int) result; int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } long comb(int n, int k) { long res = 1, MOD = 1_000_000_007; for (int i = 1; i <= k; i++) res = res * (n - i + 1) / i % MOD; return res; }` |
| 323 | Number of Subarrays That Match a Pattern I | 3034 | https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/ | Iterate all subarrays of length m (pattern length). For each subarray starting at i, check if adjacent elements match pattern’s relations (>, <, =). Increment count if all match. Handle small arrays or invalid patterns. | Brute force check of each subarray against pattern relations. | Array Iteration, Pattern Matching | O(n * m) | O(1) | `int count = 0; for (int i = 0; i <= nums.length - pattern.length; i++) { boolean valid = true; for (int j = 0; j < pattern.length; j++) { int diff = nums[i + j + 1] - nums[i + j]; if (pattern[j] == 1 && diff <= 0 || pattern[j] == -1 && diff >= 0 || pattern[j] == 0 && diff != 0) { valid = false; break; } } if (valid) count++; } return count;` |
| 324 | Maximum Sum Circular Subarray | 918 | https://leetcode.com/problems/maximum-sum-circular-subarray/ | Compute max subarray sum using Kadane’s. For circular case, compute total sum and min subarray sum (Kadane’s on negated array). Max circular sum = total - min subarray sum. Return max of non-circular and circular sums. Handle all-negative case (min sum = total sum). | Kadane’s for max/min sums. Circular sum = total - min sum. Handle edge case. | Kadane’s Algorithm, Array Iteration | O(n) | O(1) | `int maxSum = nums[0], currMax = 0, currMin = 0, minSum = 0, total = 0; for (int num : nums) { currMax = Math.max(currMax + num, num); maxSum = Math.max(maxSum, currMax); currMin = Math.min(currMin + num, num); minSum = Math.min(minSum, currMin); total += num; } return total == minSum ? maxSum : Math.max(maxSum, total - minSum);` |
| 325 | Sum of Subarray Minimums | 907 | https://leetcode.com/problems/sum-of-subarray-minimums/ | For each nums[i], count subarrays where it’s minimum using monotonic stack. Find left boundary (last index < nums[i]) and right boundary (first index ≤ nums[i]). Contribution = nums[i] * (i - left) * (right - i). Sum contributions modulo 10^9 + 7. | Monotonic stack finds range where nums[i] is minimum. Compute subarray count. | Monotonic Stack, Array Iteration | O(n) | O(n) | `long MOD = 1_000_000_007; Stack<Integer> stack = new Stack<>(); long sum = 0; int[] left = new int[nums.length], right = new int[nums.length]; for (int i = 0; i < nums.length; i++) { while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) stack.pop(); left[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } stack.clear(); for (int i = nums.length - 1; i >= 0; i--) { while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) stack.pop(); right[i] = stack.isEmpty() ? nums.length : stack.peek(); stack.push(i); } for (int i = 0; i < nums.length; i++) sum = (sum + (long) nums[i] * (i - left[i]) * (right[i] - i)) % MOD; return (int) sum;` |
| 326 | Subarray Product Less Than K | 713 | https://leetcode.com/problems/subarray-product-less-than-k/ | Use sliding window. Expand right, update product. If product ≥ k, shrink left by dividing nums[left]. When product < k, add (right - left + 1) to count (subarrays ending at right). Handle k ≤ 1 (no valid subarrays). | Sliding window tracks product. Count subarrays when product < k. | Sliding Window, Array Iteration | O(n) | O(1) | `if (k <= 1) return 0; int count = 0, left = 0; long prod = 1; for (int right = 0; right < nums.length; right++) { prod *= nums[right]; while (prod >= k && left <= right) prod /= nums[left++]; count += right - left + 1; } return count;` |
| 327 | Maximum Sum of Distinct Subarrays With Length K | 2461 | https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/ | Use fixed-size sliding window of length k. Track frequency map and sum. Slide window: add right element, remove left element. When window size = k, check if all elements distinct (map size = k). Update max sum if distinct. | Fixed sliding window with frequency map checks distinctness. Track sum. | Sliding Window, Frequency Map | O(n) | O(k) | `long maxSum = 0; Map<Integer, Integer> freq = new HashMap<>(); long sum = 0; for (int i = 0; i < nums.length; i++) { freq.merge(nums[i], 1, Integer::sum); sum += nums[i]; if (i >= k) { sum -= nums[i - k]; freq.merge(nums[i - k], -1, Integer::sum); if (freq.get(nums[i - k]) == 0) freq.remove(nums[i - k]); } if (i >= k - 1 && freq.size() == k) maxSum = Math.max(maxSum, sum); } return maxSum;` |
| 328 | Shortest Bridge | 934 | https://leetcode.com/problems/shortest-bridge/ | Use DFS to find first island, mark cells, add to queue. Run BFS from queue. For each cell, explore 4-directional neighbors. If neighbor is 0, mark as visited, add to queue with +1 distance. If neighbor is 1 (second island), return current distance. Handle single-cell islands. | DFS to identify one island, BFS to find shortest path to second island. | DFS, BFS, Matrix Traversal | O(m*n) | O(m*n) | `Queue<int[]> queue = new LinkedList<>(); boolean[][] visited = new boolean[grid.length][grid[0].length]; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (grid[i][j] == 1) { dfs(grid, i, j, queue, visited); i = grid.length; break; } int dist = 0; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { int[] cell = queue.poll(); for (int[] dir : dirs) { int r = cell[0] + dir[0], c = cell[1] + dir[1]; if (r >= лейбел:0 && r < grid.length && c >= 0 && c < grid[0].length && !visited[r][c]) { if (grid[r][c] == 1) return dist; visited[r][c] = true; queue.offer(new int[]{r, c}); } } } dist++; } return dist; void dfs(int[][] grid, int r, int c, Queue<int[]> queue, boolean[][] visited) { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || visited[r][c] || grid[r][c] == 0) return; visited[r][c] = true; queue.offer(new int[]{r, c}); dfs(grid, r - 1, c, queue, visited); dfs(grid, r + 1, c, queue, visited); dfs(grid, r, c - 1, queue, visited); dfs(grid, r, c + 1, queue, visited); }` |
| 329 | Path With Minimum Effort | 1631 | https://leetcode.com/problems/path-with-minimum-effort/ | Use Dijkstra’s with priority queue. State: (row, col, max_effort). Start at (0,0,0). For each cell, explore 4-directional neighbors. Compute effort as max(current effort, |height_diff|). Update min effort to reach neighbor. Continue until (m-1, n-1) reached. | Dijkstra’s minimizes max effort along path. PQ prioritizes lower efforts. | Dijkstra’s, Matrix Traversal | O(m*n*log(m*n)) | O(m*n) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); int[][] dist = new int[heights.length][heights[0].length]; for (int[] row : dist) Arrays.fill(row, Integer.MAX_VALUE); pq.offer(new int[]{0, 0, 0}); dist[0][0] = 0; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (!pq.isEmpty()) { int[] curr = pq.poll(); int r = curr[0], c = curr[1], effort = curr[2]; if (r == heights.length - 1 && c == heights[0].length - 1) return effort; for (int[] dir : dirs) { int nr = r + dir[0], nc = c + dir[1]; if (nr >= 0 && nr < heights.length && nc >= 0 && nc < heights[0].length) { int newEffort = Math.max(effort, Math.abs(heights[nr][nc] - heights[r][c])); if (newEffort < dist[nr][nc]) { dist[nr][nc] = newEffort; pq.offer(new int[]{nr, nc, newEffort}); } } } } return 0;` |
| 330 | Step-By-Step Directions From a Binary Tree Node to Another | 2096 | https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-to-another/ | Find LCA using DFS. From LCA, compute path to start (L/R, reverse to U’s) and path to dest (L/R). Concatenate: U’s for start path length + dest path. Handle same node case. | LCA splits paths. Reverse start path to U’s, append dest path. | Tree Traversal, LCA | O(n) | O(h) | `StringBuilder result = new StringBuilder(); public String getDirections(TreeNode root, int start, int dest) { TreeNode lca = findLCA(root, start, dest); StringBuilder startPath = new StringBuilder(), destPath = new StringBuilder(); findPath(lca, start, startPath); findPath(lca, dest, destPath); for (int i = 0; i < startPath.length(); i++) result.append('U'); result.append(destPath); return result.toString(); } TreeNode findLCA(TreeNode node, int p, int q) { if (node == null || node.val == p || node.val == q) return node; TreeNode left = findLCA(node.left, p, q), right = findLCA(node.right, p, q); if (left != null && right != null) return node; return left != null ? left : right; } boolean findPath(TreeNode node, int val, StringBuilder path) { if (node == null) return false; if (node.val == val) return true; path.append('L'); if (findPath(node.left, val, path)) return true; path.setLength(path.length() - 1); path.append('R'); if (findPath(node.right, val, path)) return true; path.setLength(path.length() - 1); return false; }` |
| 331 | Check if a Root to Leaf Path Exists with Given Sequence | N/A | https://www.geeksforgeeks.org/check-root-leaf-path-given-sequence/ | Use DFS. Recurse with node and sequence index. If node is null or value mismatches seq[index], return false. If node is leaf and index = seq.length - 1, return true. Recurse on children with index + 1. | DFS matches node values to sequence, checks leaf at sequence end. | Tree Traversal, DFS | O(n) | O(h) | `boolean checkPath(TreeNode root, int[] seq, int index) { if (root == null || index >= seq.length || root.val != seq[index]) return false; if (root.left == null && root.right == null && index == seq.length - 1) return true; return checkPath(root.left, seq, index + 1) || checkPath(root.right, seq, index + 1); }` |
| 332 | Longest Path With Different Adjacent Characters | 2246 | https://leetcode.com/problems/longest-path-with-different-adjacent-characters/ | Build adjacency list from edges. Use DFS: for each node, compute longest downward paths from children where child’s char ≠ node’s char. Update global max with 1 + top two downward paths. Return longest downward path + 1. | DFS computes longest valid downward paths, combines top two for max path. | Tree Traversal, DFS | O(n) | O(n) | `int maxPath = 1; public int longestPath(int[] parent, String s) { List<Integer>[] adj = new List[parent.length]; for (int i = 0; i < parent.length; i++) adj[i] = new ArrayList<>(); for (int i = 1; i < parent.length; i++) adj[parent[i]].add(i); dfs(0, s, adj); return maxPath; } int dfs(int node, String s, List<Integer>[] adj) { int first = 0, second = 0; for (int child : adj[node]) { int len = dfs(child, s, adj); if (s.charAt(child) != s.charAt(node)) { if (len > first) { second = first; first = len; } else if (len > second) second = len; } } maxPath = Math.max(maxPath, 1 + first + second); return 1 + first; }` |
| 333 | Most Profitable Path in a Tree | 2467 | https://leetcode.com/problems/most-profitable-path-in-a-tree/ | Use BFS to compute Bob’s path and arrival times to root. Use DFS for Alice: track time, sum amount if arriving before or same time as Bob (split if same). If after Bob, amount = 0. Track max profit. | BFS for Bob’s times, DFS for Alice’s profit with time-based amount logic. | BFS, DFS, Tree Traversal | O(n) | O(n) | `int maxProfit = Integer.MIN_VALUE; public int mostProfitablePath(int[][] edges, int bob, int[] amount) { List<Integer>[] adj = new List[amount.length]; for (int i = 0; i < amount.length; i++) adj[i] = new ArrayList<>(); for (int[] edge : edges) { adj[edge[0]].add(edge[1]); adj[edge[1]].add(edge[0]); } int[] bobTime = new int[amount.length]; Arrays.fill(bobTime, Integer.MAX_VALUE); Queue<int[]> queue = new LinkedList<>(); queue.offer(new int[]{bob, 0}); bobTime[bob] = 0; while (!queue.isEmpty()) { int[] curr = queue.poll(); int node = curr[0], time = curr[1]; for (int next : adj[node]) if (bobTime[next] == Integer.MAX_VALUE) { bobTime[next] = time + 1; queue.offer(new int[]{next, time + 1}); } } dfs(0, -1, 0, 0, adj, bobTime, amount); return maxProfit; } void dfs(int node, int parent, int time, int profit, List<Integer>[] adj, int[] bobTime, int[] amount) { int currProfit = time < bobTime[node] ? amount[node] : time == bobTime[node] ? amount[node] / 2 : 0; profit += currProfit; if (adj[node].size() == 1 && node != 0) maxProfit = Math.max(maxProfit, profit); for (int next : adj[node]) if (next != parent) dfs(next, node, time + 1, profit, adj, bobTime, amount); }` |
| 334 | Find Maximum Path Sum Between Two Leaves of a Binary Tree | N/A | https://www.geeksforgeeks.org/find-maximum-path-sum-two-leaves-binary-tree/ | Use post-order DFS. For each node, compute max path to leaf in left/right subtrees. If both exist, update global max with node.val + left + right. Return max of left/right + node.val (or Integer.MIN_VALUE if no leaf). | Post-order computes leaf paths. Combine left+right+node for max path. | Tree Traversal, DFS | O(n) | O(h) | `int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { maxPathSumUtil(root); return maxSum; } int maxPathSumUtil(TreeNode node) { if (node == null) return Integer.MIN_VALUE; if (node.left == null && node.right == null) return node.val; int left = maxPathSumUtil(node.left), right = maxPathSumUtil(node.right); if (left != Integer.MIN_VALUE && right != Integer.MIN_VALUE) maxSum = Math.max(maxSum, left + right + node.val); int maxChild = Math.max(left, right); return maxChild == Integer.MIN_VALUE ? Integer.MIN_VALUE : maxChild + node.val; }` |
| 335 | Majority Element | 169 | https://leetcode.com/problems/majority-element/ | Use Boyer-Moore Voting. Track candidate and count. Increment count if num matches candidate, else decrement. If count = 0, set new candidate. Final candidate is majority (given it exists). | Boyer-Moore cancels non-majority pairs, leaving majority candidate. | Boyer-Moore Voting, Array Iteration | O(n) | O(1) | `int candidate = nums[0], count = 1; for (int i = 1; i < nums.length; i++) { if (count == 0) candidate = nums[i]; count += nums[i] == candidate ? 1 : -1; } return candidate;` |
| 336 | Majority Element II | 229 | https://leetcode.com/problems/majority-element-ii/ | Use Boyer-Moore for two candidates (> n/3). Track two candidates and counts. Match or replace candidates, decrement both if no match. Verify candidates’ counts in second pass. | Boyer-Moore with two candidates. Verify counts for > n/3 elements. | Boyer-Moore Voting, Array Iteration | O(n) | O(1) | `List<Integer> result = new ArrayList<>(); int c1 = 0, c2 = 0, count1 = 0, count2 = 0; for (int num : nums) { if (num == c1) count1++; else if (num == c2) count2++; else if (count1 == 0) { c1 = num; count1 = 1; } else if (count2 == 0) { c2 = num; count2 = 1; } else { count1--; count2--; } } count1 = count2 = 0; for (int num : nums) { if (num == c1) count1++; else if (num == c2) count2++; } if (count1 > nums.length / 3) result.add(c1); if (count2 > nums.length / 3) result.add(c2); return result;` |
| 337 | Find Element in Sorted Array Whose Frequency is Greater Than or Equal to n/2 | N/A | https://www.geeksforgeeks.org/majority-element/ | In sorted array, majority element (> n/2) must be at index n/2. Return arr[n/2]. | Majority element in sorted array is at middle index. | Array Indexing, Sorted Array | O(1) | O(1) | `return arr[arr.length / 2];` |
| 338 | Best Time to Buy and Sell Stock | 121 | https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ | Track min price seen. For each price, update max profit as price - min_price. Return max profit. Handle single price case. | Greedy: track min price, compute max profit per day. | Array Iteration, Greedy | O(n) | O(1) | `int minPrice = Integer.MAX_VALUE, maxProfit = 0; for (int price : prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit;` |
| 339 | Best Time to Buy and Sell Stock II | 122 | https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ | Sum all positive price differences between consecutive days. Each increase contributes to profit. Handle single price case. | Greedy: capture profit from every price increase. | Array Iteration, Greedy | O(n) | O(1) | `int profit = 0; for (int i = 1; i < prices.length; i++) if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit;` |
| 340 | Best Time to Buy and Sell Stock with Cooldown | 309 | https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ | Use DP with three states: hold, sold, rest. hold[i] = max(hold[i-1], rest[i-1] - price), sold[i] = hold[i-1] + price, rest[i] = max(rest[i-1], sold[i-1]). Optimize to O(1) space using variables. | DP tracks hold/sold/rest states. Optimize space with prev values. | Dynamic Programming | O(n) | O(1) | `int hold = Integer.MIN_VALUE, sold = 0, rest = 0; for (int price : prices) { int prevHold = hold, prevSold = sold, prevRest = rest; hold = Math.max(prevHold, prevRest - price); sold = prevHold + price; rest = Math.max(prevRest, prevSold); } return Math.max(sold, rest);` |
| 341 | Best Time to Buy and Sell Stock IV | 188 | https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ | If k ≥ n/2, use Stock II approach. Else, use DP: dp[i][k][0/1] = max profit at day i, k transactions, holding/not holding. Optimize to O(k) space. Handle k = 0 or empty prices. | DP with transaction limit. Optimize for large k or space. | Dynamic Programming | O(min(n, k)*n) | O(min(n, k)) | `if (k >= prices.length / 2) { int profit = 0; for (int i = 1; i < prices.length; i++) if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit; } int[][] dp = new int[k + 1][2]; for (int[] row : dp) Arrays.fill(row, Integer.MIN_VALUE / 2); dp[0][0] = 0; for (int i = 1; i <= prices.length; i++) { int[][] newDp = new int[k + 1][2]; for (int[] row : newDp) Arrays.fill(row, Integer.MIN_VALUE / 2); newDp[0][0] = dp[0][0]; for (int j = 0; j <= k; j++) { newDp[j][0] = Math.max(dp[j][0], dp[j][1] + prices[i - 1]); if (j > 0) newDp[j][1] = Math.max(dp[j][1], dp[j - 1][0] - prices[i - 1]); } dp = newDp; } return dp[k][0];` |
| 342 | Best Time to Buy and Sell Stock with Transaction Fee | 714 | https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ | Use DP: hold[i] = max(hold[i-1], free[i-1] - price), free[i] = max(free[i-1], hold[i-1] + price - fee). Optimize to O(1) space. Handle empty prices. | DP tracks hold/free states. Apply fee on sell. Optimize space. | Dynamic Programming | O(n) | O(1) | `int hold = Integer.MIN_VALUE, free = 0; for (int price : prices) { int prevHold = hold; hold = Math.max(hold, free - price); free = Math.max(free, prevHold + price - fee); } return free;` |
| 343 | Stock Buy Sell | N/A | https://www.geeksforgeeks.org/stock-buy-sell/ | Iterate prices. Track buy point (local min). When price decreases, sell at previous day (local max) if buy exists. Reset buy. Handle last increase. Return buy/sell intervals. | Greedy: buy at local min, sell at next local max. | Array Iteration, Greedy | O(n) | O(1) | `List<int[]> result = new ArrayList<>(); int buy = -1; for (int i = 1; i < prices.length; i++) { if (prices[i] > prices[i - 1] && buy == -1) buy = i - 1; else if (prices[i] < prices[i - 1] && buy != -1) { result.add(new int[]{buy, i - 1}); buy = -1; } } if (buy != -1 && prices[prices.length - 1] > prices[prices.length - 2]) result.add(new int[]{buy, prices.length - 1}); return result;` |
| 344 | Find The Original Array of Prefix Xor | 2433 | https://leetcode.com/problems/find-the-original-array-of-prefix-xor/ | Use XOR property: pref[i] = pref[i-1] ^ arr[i], so arr[i] = pref[i] ^ pref[i-1]. Set arr[0] = pref[0]. Compute arr[i] iteratively. | XOR property reverses prefix XOR to original array. | Bit Manipulation, Array Iteration | O(n) | O(n) | `int[] arr = new int[pref.length]; arr[0] = pref[0]; for (int i = 1; i < pref.length; i++) arr[i] = pref[i] ^ pref[i - 1]; return arr;` |
| 345 | Flood Fill | 733 | https://leetcode.com/problems/flood-fill/ | Use DFS from (sr, sc). If cell is in bounds, has old color, and not new color, change to new color and recurse on 4-directional neighbors. Handle same color case. | DFS changes connected cells with old color to new color. | DFS, Matrix Traversal | O(m*n) | O(m*n) | `public int[][] floodFill(int[][] image, int sr, int sc, int newColor) { if (image[sr][sc] != newColor) dfs(image, sr, sc, image[sr][sc], newColor); return image; } void dfs(int[][] image, int r, int c, int oldColor, int newColor) { if (r < 0 || r >= image.length || c < 0 || c >= image[0].length || image[r][c] != oldColor) return; image[r][c] = newColor; dfs(image, r - 1, c, oldColor, newColor); dfs(image, r + 1, c, oldColor, newColor); dfs(image, r, c - 1, oldColor, newColor); dfs(image, r, c + 1, oldColor, newColor); }` |
| 346 | Walls and Gates | 286 | https://leetcode.com/problems/walls-and-gates/ | Use multi-source BFS. Add all gates (0) to queue with distance 0. For each cell, update unvisited rooms (INF) to current distance + 1, add to queue. Skip walls (-1). | Multi-source BFS from gates sets min distances to rooms. | BFS, Matrix Traversal | O(m*n) | O(m*n) | `Queue<int[]> queue = new LinkedList<>(); for (int i = 0; i < rooms.length; i++) for (int j = 0; j < rooms[0].length; j++) if (rooms[i][j] == 0) queue.offer(new int[]{i, j}); int dist = 0; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (!queue.isEmpty()) { int size = queue.size(); dist++; for (int i = 0; i < size; i++) { int[] cell = queue.poll(); for (int[] dir : dirs) { int r = cell[0] + dir[0], c = cell[1] + dir[1]; if (r >= 0 && r < rooms.length && c >= 0 && c < rooms[0].length && rooms[r][c] == Integer.MAX_VALUE) { rooms[r][c] = dist; queue.offer(new int[]{r, c}); } } } }` |
| 347 | Max Area of Island | 695 | https://leetcode.com/problems/max-area-of-island/ | Iterate grid. For each unvisited land (1), use DFS to compute island size, mark cells as 0. Track max size. Handle empty grid or no land. | DFS computes size of each island. Track max size. | DFS, Matrix Traversal | O(m*n) | O(m*n) | `int maxArea = 0; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (grid[i][j] == 1) maxArea = Math.max(maxArea, dfs(grid, i, j)); return maxArea; int dfs(int[][] grid, int r, int c) { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) return 0; grid[r][c] = 0; return 1 + dfs(grid, r - 1, c) + dfs(grid, r + 1, c) + dfs(grid, r, c - 1) + dfs(grid, r, c + 1); }` |
| 348 | Making A Large Island | 827 | https://leetcode.com/problems/making-a-large-island/ | Use DFS to label islands with unique IDs, compute sizes, store in map. For each water (0), sum sizes of adjacent distinct islands + 1. Track max size. Handle all-1s case (return n*m). | DFS labels islands. Check water cells for max island size after flip. | DFS, Matrix Traversal, Hash Map | O(m*n) | O(m*n) | `Map<Integer, Integer> sizeMap = new HashMap<>(); int id = 2, maxSize = 0; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (grid[i][j] == 1) sizeMap.put(id, dfs(grid, i, j, id++)); for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (grid[i][j] == 0) { Set<Integer> seen = new HashSet<>(); int size = 1; for (int[] dir : new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) { int r = i + dir[0], c = j + dir[1]; if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && grid[r][c] >= 2 && seen.add(grid[r][c])) size += sizeMap.get(grid[r][c]); } maxSize = Math.max(maxSize, size); } return maxSize == 0 ? grid.length * grid[0].length : maxSize; int dfs(int[][] grid, int r, int c, int id) { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] != 1) return 0; grid[r][c] = id; return 1 + dfs(grid, r - 1, c, id) + dfs(grid, r + 1, c, id) + dfs(grid, r, c - 1, id) + dfs(grid, r, c + 1, id); }` |
| 349 | Find the Number of Islands | N/A | https://www.geeksforgeeks.org/find-the-number-of-islands/ | Iterate grid. For each unvisited land (1), increment island count and use DFS to mark connected 1s as 0. Handle empty grid. | DFS marks each island to count distinct islands. | DFS, Matrix Traversal | O(m*n) | O(m*n) | `int count = 0; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (grid[i][j] == 1) { count++; dfs(grid, i, j); } return count; void dfs(int[][] grid, int r, int c) { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) return; grid[r][c] = 0; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); }` |
| 350 | Minimum Time Required to Rot All Oranges | N/A | https://www.geeksforgeeks.org/minimum-time-required-to-rot-all-oranges/ | Use multi-source BFS. Add all rotten oranges (2) to queue with time 0. Count fresh oranges (1). For each cell, rot fresh neighbors (1 to 2), add to queue with time + 1, decrement fresh count. Return max time if no fresh remain, else -1. | Multi-source BFS from rotten oranges. Track fresh count and max time. | BFS, Matrix Traversal | O(m*n) | O(m*n) | `Queue<int[]> queue = new LinkedList<>(); int fresh = 0; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) { if (grid[i][j] == 2) queue.offer(new int[]{i, j, 0}); if (grid[i][j] == 1) fresh++; } int time = 0; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; while (!queue.isEmpty()) { int[] cell = queue.poll(); int r = cell[0], c = cell[1], t = cell[2]; time = Math.max(time, t); for (int[] dir : dirs) { int nr = r + dir[0], nc = c + dir[1]; if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] == 1) { grid[nr][nc] = 2; fresh--; queue.offer(new int[]{nr, nc, t + 1}); } } } return fresh == 0 ? time : -1;` |



| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 351 | Valid Parenthesis String | 678 | https://leetcode.com/problems/valid-parenthesis-string/ | Track range of open parentheses using `min_open` (assume '*' as ')') and `max_open` (assume '*' as '('). For '(': increment both. For ')': decrement both. For '*': decrement `min_open`, increment `max_open`. Reset `min_open` to 0 if negative. If `max_open` < 0, invalid. At end, `min_open` must be 0. | Greedy bounds tracking. `min_open` and `max_open` define possible open counts. | String Iteration, Greedy | O(n) | O(1) | `int minOpen = 0, maxOpen = 0; for (char c : s.toCharArray()) { if (c == '(') { minOpen++; maxOpen++; } else if (c == ')') { minOpen--; maxOpen--; } else { minOpen--; maxOpen++; } if (maxOpen < 0) return false; minOpen = Math.max(0, minOpen); } return minOpen == 0;` |
| 352 | Longest Palindrome | 409 | https://leetcode.com/problems/longest-palindrome/ | Count character frequencies. Sum even frequencies fully. For odd frequencies, add `freq - 1`. If any odd frequency exists, add 1 for center. Handle empty strings. | Use even counts fully, odd counts minus 1, plus 1 if odd exists. | Frequency Map, Counting | O(n) | O(1) | `int[] freq = new int[128]; for (char c : s.toCharArray()) freq[c]++; int len = 0; boolean hasOdd = false; for (int f : freq) { len += (f / 2) * 2; if (f % 2 == 1) hasOdd = true; } return len + (hasOdd ? 1 : 0);` |
| 353 | Find the Closest Palindrome | 564 | https://leetcode.com/problems/find-the-closest-palindrome/ | Generate palindromes: mirror left half, mirror (left half + 1), mirror (left half - 1). Handle edge cases: numbers near 10^k (e.g., 999 -> 1001) or 10^k-1 (e.g., 1000 -> 999). Convert to long to avoid overflow. Compute absolute differences, pick smallest palindrome (tie-break with smaller value). | Generate candidates from left half and boundary cases. Compare differences. | String Manipulation, Number Theory | O(L) | O(L) | `long num = Long.parseLong(n); int len = n.length(); String leftHalf = n.substring(0, (len + 1) / 2); long left = Long.parseLong(leftHalf); String[] candidates = { createPalindrome(left, len, len % 2 == 1), createPalindrome(left + 1, len, len % 2 == 1), createPalindrome(left - 1, len, len % 2 == 1), String.valueOf((long) Math.pow(10, len - 1) - 1), String.valueOf((long) Math.pow(10, len) + 1) }; long minDiff = Long.MAX_VALUE, result = 0; for (String cand : candidates) { long candNum = Long.parseLong(cand); if (candNum != num) { long diff = Math.abs(candNum - num); if (diff < minDiff || (diff == minDiff && candNum < result)) { minDiff = diff; result = candNum; } } } return String.valueOf(result); String createPalindrome(long left, int len, boolean odd) { StringBuilder sb = new StringBuilder(String.valueOf(left)); String right = new StringBuilder(String.valueOf(left)).reverse().substring(odd ? 1 : 0); return sb.append(right).toString(); }` |
| 354 | Valid Palindrome III | 1216 | https://leetcode.com/problems/valid-palindrome-iii/ | Compute Longest Palindromic Subsequence (LPS) length using DP. `dp[i][j]` = LPS length of s[i...j]. If s[i] == s[j], `dp[i][j] = 2 + dp[i+1][j-1]`. Else, `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`. Return true if LPS length ≥ n - k. | LPS length ≥ n - k means ≤ k deletions make palindrome. | Dynamic Programming, LPS | O(n²) | O(n²) | `int[][] dp = new int[s.length()][s.length()]; for (int len = 1; len <= s.length(); len++) { for (int i = 0; i + len - 1 < s.length(); i++) { int j = i + len - 1; if (i == j) dp[i][j] = 1; else if (s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i + 1][j - 1]; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } return dp[0][s.length() - 1] >= s.length() - k;` |
| 355 | Break a Palindrome | 1328 | https://leetcode.com/problems/break-a-palindrome/ | If length = 1, return empty string. Iterate first half. Replace first non-'a' with 'a'. If all 'a's, change last char to 'b'. Return modified string. | Greedy: minimize lexicographically by changing earliest non-'a' to 'a' or last to 'b'. | String Manipulation, Greedy | O(n) | O(n) | `if (palindrome.length() == 1) return ""; char[] chars = palindrome.toCharArray(); for (int i = 0; i < chars.length / 2; i++) { if (chars[i] != 'a') { chars[i] = 'a'; return new String(chars); } } chars[chars.length - 1] = 'b'; return new String(chars);` |
| 356 | Minimum Remove to Make Valid Parentheses | 1249 | https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ | Use stack to track '(' indices. For '(', push index. For ')', pop if stack non-empty; else mark for removal. Mark remaining stack indices (unmatched '(') for removal. Build result skipping marked indices. | Stack tracks unmatched '('. Mark invalid indices, then filter them out. | Stack, String Manipulation | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); boolean[] remove = new boolean[s.length()]; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == '(') stack.push(i); else if (s.charAt(i) == ')') { if (!stack.isEmpty()) stack.pop(); else remove[i] = true; } } while (!stack.isEmpty()) remove[stack.pop()] = true; StringBuilder sb = new StringBuilder(); for (int i = 0; i < s.length(); i++) if (!remove[i]) sb.append(s.charAt(i)); return sb.toString();` |
| 357 | Count Different Palindromic Subsequences | 730 | https://leetcode.com/problems/count-different-palindromic-subsequences/ | Use DP: `dp[i][j]` = distinct palindromic subsequences in s[i...j]. If s[i] != s[j], `dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]`. If s[i] == s[j], find next/prev occurrences. Cases: no match (`2 * dp[i+1][j-1] + 2`), one char (`2 * dp[i+1][j-1] + 1`), multiple chars (`2 * dp[i+1][j-1] - dp[next+1][prev-1]`). Precompute next/prev. Apply modulo. | Precompute next/prev indices. Handle matching ends with inclusion-exclusion. | Dynamic Programming, String Manipulation | O(n²) | O(n²) | `long MOD = 1_000_000_007; int[][] dp = new int[s.length()][s.length()]; int[][] next = new int[s.length()][26], prev = new int[s.length()][26]; Arrays.fill(next[s.length() - 1], s.length()); for (int i = s.length() - 2; i >= 0; i--) { System.arraycopy(next[i + 1], 0, next[i], 0, 26); next[i][s.charAt(i) - 'a'] = i; } Arrays.fill(prev[0], -1); for (int i = 1; i < s.length(); i++) { System.arraycopy(prev[i - 1], 0, prev[i], 0, 26); prev[i][s.charAt(i) - 'a'] = i; } for (int len = 1; len <= s.length(); len++) { for (int i = 0; i + len - 1 < s.length(); i++) { int j = i + len - 1; if (len == 1) dp[i][j] = 1; else if (s.charAt(i) != s.charAt(j)) dp[i][j] = (int) ((dp[i + 1][j] + dp[i][j - 1] - (i + 1 <= j ? dp[i + 1][j - 1] : 0) + MOD) % MOD); else { int n = next[i][s.charAt(i) - 'a'], p = prev[j][s.charAt(j) - 'a']; if (n > p) dp[i][j] = (int) ((2 * (i + 1 <= j ? dp[i + 1][j - 1] : 0) + 2) % MOD); else if (n == p) dp[i][j] = (int) ((2 * (i + 1 <= j ? dp[i + 1][j - 1] : 0) + 1) % MOD); else dp[i][j] = (int) ((2 * (i + 1 <= j ? dp[i + 1][j - 1] : 0) - (n + 1 <= p - 1 ? dp[n + 1][p - 1] : 0) + MOD) % MOD); } } } return dp[0][s.length() - 1];` |
| 358 | Print All Palindrome Permutations of a String | N/A | https://www.geeksforgeeks.org/print-all-palindrome-permutations-of-a-string/ | Check if palindrome possible (≤1 char with odd freq). Collect half of each char’s freq (odd freq: (freq-1)/2). Use backtracking to generate permutations of this half. For each, build palindrome: half + (odd char if exists) + reverse half. | Validate palindrome, generate half permutations, construct full palindromes. | Backtracking, Frequency Counting | O((n/2)! * n) | O(n) | `List<String> result = new ArrayList<>(); int[] freq = new int[26]; for (char c : s.toCharArray()) freq[c - 'a']++; int oddCount = 0, oddChar = -1; for (int i = 0; i < 26; i++) if (freq[i] % 2 == 1) { oddCount++; oddChar = i; } if (oddCount > 1) return result; List<Character> half = new ArrayList<>(); for (int i = 0; i < 26; i++) for (int j = 0; j < freq[i] / 2; j++) half.add((char) (i + 'a')); backtrack(half, new ArrayList<>(), new boolean[half.size()], oddChar == -1 ? "" : String.valueOf((char) (oddChar + 'a'))); return result; void backtrack(List<Character> half, List<Character> curr, boolean[] used, String mid) { if (curr.size() == half.size()) { StringBuilder sb = new StringBuilder(); for (char c : curr) sb.append(c); String rev = new StringBuilder(sb).reverse().toString(); result.add(sb.toString() + mid + rev); return; } for (int i = 0; i < half.size(); i++) { if (!used[i]) { used[i] = true; curr.add(half.get(i)); backtrack(half, curr, used, mid); curr.remove(curr.size() - 1); used[i] = false; } } }` |
| 359 | Minimum Insertions to Form a Palindrome | N/A | https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindromic-string-dp-28/ | Compute LPS length using DP. `dp[i][j]` = LPS length of s[i...j]. If s[i] == s[j], `dp[i][j] = 2 + dp[i+1][j-1]`. Else, `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`. Return n - LPS length. | Insertions = n - LPS length. Use DP to compute LPS. | Dynamic Programming, LPS | O(n²) | O(n²) | `int[][] dp = new int[s.length()][s.length()]; for (int len = 1; len <= s.length(); len++) { for (int i = 0; i + len - 1 < s.length(); i++) { int j = i + len - 1; if (i == j) dp[i][j] = 1; else if (s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i + 1][j - 1]; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } return s.length() - dp[0][s.length() - 1];` |
| 360 | Subsets | 78 | https://leetcode.com/problems/subsets/ | Use backtracking. Recurse with index and current subset. At each index, include nums[index] and recurse, then exclude and recurse. Add copy of current subset to result at each step. | Backtrack with include/exclude choices per element. | Backtracking, Recursion | O(n * 2^n) | O(n * 2^n) | `List<List<Integer>> result = new ArrayList<>(); backtrack(nums, 0, new ArrayList<>(), result); return result; void backtrack(int[] nums, int index, List<Integer> curr, List<List<Integer>> result) { result.add(new ArrayList<>(curr)); if (index == nums.length) return; curr.add(nums[index]); backtrack(nums, index + 1, curr, result); curr.remove(curr.size() - 1); backtrack(nums, index + 1, curr, result); }` |
| 361 | Subsets II | 90 | https://leetcode.com/problems/subsets-ii/ | Sort array. Use backtracking. Recurse with index and current subset. Include nums[index], recurse. Skip duplicates at same level to avoid duplicate subsets, then recurse without including. Add copy of subset to result. | Sort to group duplicates. Skip duplicates at same recursion level. | Backtracking, Sorting | O(n * 2^n) | O(n * 2^n) | `Arrays.sort(nums); List<List<Integer>> result = new ArrayList<>(); backtrack(nums, 0, new ArrayList<>(), result); return result; void backtrack(int[] nums, int index, List<Integer> curr, List<List<Integer>> result) { result.add(new ArrayList<>(curr)); for (int i = index; i < nums.length; i++) { if (i > index && nums[i] == nums[i - 1]) continue; curr.add(nums[i]); backtrack(nums, i + 1, curr, result); curr.remove(curr.size() - 1); } }` |
| 362 | Partition to K Equal Sum Subsets | 698 | https://leetcode.com/problems/partition-to-k-equal-sum-subsets/ | If sum % k != 0, return false. Target = sum / k. Sort array descending. Use backtracking: try placing each number in one of k subsets. Track subset sums. Prune if subset sum > target. Return true if all numbers used. | Sort descending for pruning. Backtrack with subset sum tracking. | Backtracking, Subset Sum | O(k * 2^n) | O(n) | `int sum = Arrays.stream(nums).sum(); if (sum % k != 0) return false; int target = sum / k; Arrays.sort(nums); for (int i = 0, j = nums.length - 1; i < j; i++, j--) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } return backtrack(nums, 0, new int[k], target); boolean backtrack(int[] nums, int index, int[] subsets, int target) { if (index == nums.length) return true; for (int i = 0; i < subsets.length; i++) { if (subsets[i] + nums[index] <= target) { subsets[i] += nums[index]; if (backtrack(nums, index + 1, subsets, target)) return true; subsets[i] -= nums[index]; } if (subsets[i] == 0) break; } return false; }` |
| 363 | Largest Divisible Subset | 368 | https://leetcode.com/problems/largest-divisible-subset/ | Sort array. `dp[i]` = size of largest divisible subset ending at nums[i]. `prev[i]` tracks predecessor. For each i, check j < i where nums[i] % nums[j] == 0, update dp[i]. Reconstruct subset from max dp index. | Sort, DP to find largest subset. Track prev for reconstruction. | Dynamic Programming, Sorting | O(n²) | O(n) | `Arrays.sort(nums); int[] dp = new int[nums.length], prev = new int[nums.length]; Arrays.fill(prev, -1); int maxLen = 0, maxIndex = -1; for (int i = 0; i < nums.length; i++) { dp[i] = 1; for (int j = 0; j < i; j++) if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1; prev[i] = j; } if (dp[i] > maxLen) { maxLen = dp[i]; maxIndex = i; } } List<Integer> result = new ArrayList<>(); while (maxIndex != -1) { result.add(nums[maxIndex]); maxIndex = prev[maxIndex]; } return result;` |
| 364 | Count Number of Binary Strings Without Consecutive 1s | N/A | https://www.geeksforgeeks.org/count-number-of-binary-strings-without-consecutive-1s/ | DP: `dp[i][0]` = strings of length i ending in 0, `dp[i][1]` = ending in 1. `dp[i][0] = dp[i-1][0] + dp[i-1][1]`, `dp[i][1] = dp[i-1][0]`. Total = `dp[n][0] + dp[n][1]`. Optimize to O(1) space. | DP tracks ending digits. Sum for total. Fibonacci-like sequence. | Dynamic Programming, Fibonacci | O(n) | O(1) | `int zero = 1, one = 1; for (int i = 2; i <= n; i++) { int newZero = zero + one; int newOne = zero; zero = newZero; one = newOne; } return zero + one;` |
| 365 | Vertical Order Traversal of a Binary Tree | 987 | https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/ | Use BFS with node, col, row. Store in `Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>>` (col -> row -> values). For each node, add to map, process children with updated col/row. Collect result by iterating map. | BFS with col/row tracking. Use nested sorted structures for ordering. | Tree Traversal, Hash Map, Sorting | O(n log n) | O(n) | `Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new HashMap<>(); Queue<Object[]> queue = new LinkedList<>(); queue.offer(new Object[]{root, 0, 0}); while (!queue.isEmpty()) { Object[] curr = queue.poll(); TreeNode node = (TreeNode) curr[0]; int col = (int) curr[1], row = (int) curr[2]; map.computeIfAbsent(col, k -> new TreeMap<>()).computeIfAbsent(row, k -> new PriorityQueue<>()).offer(node.val); if (node.left != null) queue.offer(new Object[]{node.left, col - 1, row + 1}); if (node.right != null) queue.offer(new Object[]{node.right, col + 1, row + 1}); } List<List<Integer>> result = new ArrayList<>(); for (TreeMap<Integer, PriorityQueue<Integer>> rows : map.values()) { List<Integer> col = new ArrayList<>(); for (PriorityQueue<Integer> vals : rows.values()) while (!vals.isEmpty()) col.add(vals.poll()); result.add(col); } return result;` |
| 366 | Boundary of Binary Tree | 545 | https://leetcode.com/problems/boundary-of-binary-tree/ | Add root if not leaf. Traverse left boundary (exclude leaves), collect leaves via DFS, traverse right boundary (reverse order, exclude leaves). Handle single-node case. | Split into left boundary, leaves, right boundary. Use DFS and stack for reverse. | Tree Traversal, DFS | O(n) | O(h) | `List<Integer> result = new ArrayList<>(); if (root == null) return result; if (!isLeaf(root)) result.add(root.val); addLeftBoundary(root.left, result); addLeaves(root, result); addRightBoundary(root.right, result); return result; boolean isLeaf(TreeNode node) { return node != null && node.left == null && node.right == null; } void addLeftBoundary(TreeNode node, List<Integer> result) { while (node != null && !isLeaf(node)) { result.add(node.val); node = node.left != null ? node.left : node.right; } } void addLeaves(TreeNode node, List<Integer> result) { if (node == null) return; if (isLeaf(node)) result.add(node.val); addLeaves(node.left, result); addLeaves(node.right, result); } void addRightBoundary(TreeNode node, List<Integer> result) { Stack<Integer> stack = new Stack<>(); while (node != null && !isLeaf(node)) { stack.push(node.val); node = node.right != null ? node.right : node.left; } while (!stack.isEmpty()) result.add(stack.pop()); }` |
| 367 | Inorder Tree Traversal Without Recursion | N/A | https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/ | Use stack. Start at root. While node != null or stack non-empty: push node, go left. If node null, pop, visit, go right. | Stack simulates recursion. Push left path, pop to visit, then right. | Tree Traversal, Stack | O(n) | O(h) | `List<Integer> result = new ArrayList<>(); Stack<TreeNode> stack = new Stack<>(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { while (curr != null) { stack.push(curr); curr = curr.left; } curr = stack.pop(); result.add(curr.val); curr = curr.right; } return result;` |
| 368 | Find Leaves of Binary Tree | 366 | https://leetcode.com/problems/find-leaves-of-binary-tree/ | Use DFS to compute height (distance from leaf) for each node. Add node.val to result list at index = height. Return height for parent. | DFS groups nodes by height from leaves. Leaves at height 0. | Tree Traversal, DFS | O(n) | O(n) | `List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> findLeaves(TreeNode root) { dfs(root); return result; } int dfs(TreeNode node) { if (node == null) return -1; int height = 1 + Math.max(dfs(node.left), dfs(node.right)); if (height >= result.size()) result.add(new ArrayList<>()); result.get(height).add(node.val); return height; }` |
| 369 | Longest Univalue Path | 687 | https://leetcode.com/problems/longest-univalue-path/ | DFS: return longest downward univalue path from node. If child value = node value, include its path. Update global max with left + right paths if values match. | DFS tracks downward paths. Combine left+right for max path through node. | Tree Traversal, DFS | O(n) | O(h) | `int maxPath = 0; public int longestUnivaluePath(TreeNode root) { dfs(root); return maxPath; } int dfs(TreeNode node) { if (node == null) return 0; int left = 0, right = 0; if (node.left != null && node.left.val == node.val) left = dfs(node.left) + 1; else dfs(node.left); if (node.right != null && node.right.val == node.val) right = dfs(node.right) + 1; else dfs(node.right); maxPath = Math.max(maxPath, left + right); return Math.max(left, right); }` |
| 370 | Maximum Width of Binary Tree | 662 | https://leetcode.com/problems/maximum-width-of-binary-tree/ | Use BFS with node and index (root = 1, left = 2*i, right = 2*i+1). At each level, compute width = last index - first index + 1. Track max width. Use long for indices. | BFS with index tracking. Width = difference of level’s extreme indices. | BFS, Tree Traversal | O(n) | O(n) | `long maxWidth = 0; Queue<Object[]> queue = new LinkedList<>(); queue.offer(new Object[]{root, 1L}); while (!queue.isEmpty()) { int size = queue.size(); long left = (long) ((Object[]) queue.peek())[1]; for (int i = 0; i < size; i++) { Object[] curr = queue.poll(); TreeNode node = (TreeNode) curr[0]; long index = (long) curr[1]; maxWidth = Math.max(maxWidth, index - left + 1); if (node.left != null) queue.offer(new Object[]{node.left, index * 2}); if (node.right != null) queue.offer(new Object[]{node.right, index * 2 + 1}); } } return (int) maxWidth;` |
| 371 | Count Nodes Equal to Average of Subtree | 2265 | https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/ | Post-order DFS: return {sum, count} for subtree. Compute total sum and count. If node.val == average, increment counter. Return updated sum and count. | Post-order computes subtree stats. Check average at each node. | Tree Traversal, DFS | O(n) | O(h) | `int count = 0; public int averageOfSubtree(TreeNode root) { dfs(root); return count; } int[] dfs(TreeNode node) { if (node == null) return new int[]{0, 0}; int[] left = dfs(node.left), right = dfs(node.right); int sum = left[0] + right[0] + node.val; int nodes = left[1] + right[1] + 1; if (node.val == sum / nodes) count++; return new int[]{sum, nodes}; }` |
| 372 | Construct Quad Tree | 427 | https://leetcode.com/problems/construct-quad-tree/ | Recurse on grid region (r, c, size). If uniform, create leaf node. Else, create non-leaf node and recurse on four quadrants. Check uniformity by comparing values. | Divide and conquer. Check uniformity to decide leaf/non-leaf. | Recursion, Divide and Conquer | O(n²) | O(log n) | `public Node construct(int[][] grid) { return dfs(grid, 0, 0, grid.length); } Node dfs(int[][] grid, int r, int c, int size) { if (isUniform(grid, r, c, size)) return new Node(grid[r][c] == 1, true); Node node = new Node(true, false); int half = size / 2; node.topLeft = dfs(grid, r, c, half); node.topRight = dfs(grid, r, c + half, half); node.bottomLeft = dfs(grid, r + half, c, half); node.bottomRight = dfs(grid, r + half, c + half, half); return node; } boolean isUniform(int[][] grid, int r, int c, int size) { int val = grid[r][c]; for (int i = r; i < r + size; i++) for (int j = c; j < c + size; j++) if (grid[i][j] != val) return false; return true; }` |
| 373 | Construct a Binary Tree from Parent Array Representation | N/A | https://www.geeksforgeeks.org/construct-a-binary-tree-from-parent-array/ | Create nodes for 0 to n-1. Find root (parent[i] = -1). For each i, attach node i to parent[i] as left (if null) or right child. Use array for node references. | Create nodes, attach based on parent array. Track root and children. | Array Manipulation, Tree Construction | O(n) | O(n) | `TreeNode[] nodes = new TreeNode[parent.length]; for (int i = 0; i < parent.length; i++) nodes[i] = new TreeNode(i); TreeNode root = null; for (int i = 0; i < parent.length; i++) { if (parent[i] == -1) root = nodes[i]; else { if (nodes[parent[i]].left == null) nodes[parent[i]].left = nodes[i]; else nodes[parent[i]].right = nodes[i]; } } return root;` |
| 374 | Check if a Given Array Can Represent Preorder Traversal of Binary Search Tree | N/A | https://www.geeksforgeeks.org/check-if-given-preorder-inorder-and-postorder-traversals-are-of-same-tree/ | Use stack and lower bound. Push elements, update bound when entering right subtree (pop smaller elements). Current element must be > bound. | Stack tracks parents. Update bound when switching to right subtree. | Stack, BST Properties | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int lowerBound = Integer.MIN_VALUE; for (int val : preorder) { if (val < lowerBound) return false; while (!stack.isEmpty() && stack.peek() < val) lowerBound = stack.pop(); stack.push(val); } return true;` |
| 375 | In-Place Conversion of Sorted DLL to Balanced BST | N/A | https://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/ | Recurse: find middle node (slow/fast pointers), make it root. Split DLL at middle. Recurse on left and right halves. Update prev/next as left/right pointers. | Slow/fast pointers find middle. Split and recurse in-place. | Linked List, Recursion, BST | O(n) | O(log n) | `ListNode headRef; public TreeNode sortedListToBST(ListNode head) { headRef = head; return dfs(countNodes(head)); } TreeNode dfs(int n) { if (n <= 0) return null; TreeNode left = dfs(n / 2); TreeNode root = new TreeNode(headRef.val); headRef = headRef.next; root.left = left; root.right = dfs(n - n / 2 - 1); return root; } int countNodes(ListNode head) { int count = 0; while (head != null) { count++; head = head.next; } return count; }` |
| 376 | Same Tree | 100 | https://leetcode.com/problems/same-tree/ | Recurse: if both nodes null, true. If one null or values differ, false. Recurse on left and right children. | Compare structure and values recursively. | Tree Traversal, DFS | O(min(n1, n2)) | O(min(h1, h2)) | `if (p == null && q == null) return true; if (p == null || q == null || p.val != q.val) return false; return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);` |
| 377 | Leaf-Similar Trees | 872 | https://leetcode.com/problems/leaf-similar-trees/ | DFS to collect leaves of both trees in lists. Compare lists for equality. | Collect leaf sequences via DFS, then compare. | Tree Traversal, DFS | O(n1 + n2) | O(n1 + n2) | `List<Integer> leaves1 = new ArrayList<>(), leaves2 = new ArrayList<>(); dfs(root1, leaves1); dfs(root2, leaves2); return leaves1.equals(leaves2); void dfs(TreeNode node, List<Integer> leaves) { if (node == null) return; if (node.left == null && node.right == null) leaves.add(node.val); dfs(node.left, leaves); dfs(node.right, leaves); }` |
| 378 | Check Completeness of a Binary Tree | 958 | https://leetcode.com/problems/check-completeness-of-a-binary-tree/ | BFS: add nodes to queue. After first null, all subsequent nodes must be null. | BFS tracks nulls. Non-null after null means incomplete. | BFS, Tree Traversal | O(n) | O(n) | `Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); boolean seenNull = false; while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node == null) seenNull = true; else { if (seenNull) return false; queue.offer(node.left); queue.offer(node.right); } } return true;` |
| 379 | Count Good Nodes in Binary Tree | 1448 | https://leetcode.com/problems/count-good-nodes-in-binary-tree/ | DFS: pass max value on path. If node.val ≥ max, increment count. Update max for children. | Track path max. Count nodes ≥ max. | Tree Traversal, DFS | O(n) | O(h) | `int count = 0; public int goodNodes(TreeNode root) { dfs(root, Integer.MIN_VALUE); return count; } void dfs(TreeNode node, int max) { if (node == null) return; if (node.val >= max) count++; dfs(node.left, Math.max(max, node.val)); dfs(node.right, Math.max(max, node.val)); }` |
| 380 | Next Greater Element II | 556 | https://leetcode.com/problems/next-greater-element-ii/ | Use monotonic stack. Iterate array twice (modulo for circularity). Pop indices where nums[i % n] > nums[j], set result[j]. Push i % n in second pass. | Monotonic stack. Double iteration simulates circular array. | Stack, Circular Array | O(n) | O(n) | `int[] result = new int[nums.length]; Arrays.fill(result, -1); Stack<Integer> stack = new Stack<>(); for (int i = 0; i < 2 * nums.length; i++) { while (!stack.isEmpty() && nums[i % nums.length] > nums[stack.peek()]) result[stack.pop()] = nums[i % nums.length]; if (i < nums.length) stack.push(i); } return result;` |
| 381 | Write a C Program to Print All Permutations of a Given String | N/A | https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/ | Backtrack: swap chars at start index with later indices, recurse. Print when start = length. Backtrack by swapping back. | Swap-based backtracking generates all permutations. | Backtracking, String Manipulation | O(n * n!) | O(n) | `void permute(char[] str, int start, List<String> result) { if (start == str.length) { result.add(new String(str)); return; } for (int i = start; i < str.length; i++) { swap(str, start, i); permute(str, start + 1, result); swap(str, start, i); } } void swap(char[] str, int i, int j) { char temp = str[i]; str[i] = str[j]; str[j] = temp; } List<String> result = new ArrayList<>(); permute(s.toCharArray(), 0, result); return result;` |
| 382 | Happy Number | 202 | https://leetcode.com/problems/happy-number/ | Compute sum of squared digits repeatedly. Use set to detect cycle. If sum = 1, happy. If cycle detected, not happy. | Cycle detection via set. 1 means happy, other cycles mean not. | Hash Set, Cycle Detection | O(log n) | O(log n) | `Set<Integer> seen = new HashSet<>(); while (n != 1 && !seen.contains(n)) { seen.add(n); int sum = 0; while (n > 0) { int digit = n % 10; sum += digit * digit; n /= 10; } n = sum; } return n == 1;` |
| 383 | Isomorphic Strings | 205 | https://leetcode.com/problems/isomorphic-strings/ | Use two maps: s -> t and t -> s. Check consistent mappings for each char pair. If mapping exists and differs, return false. | Dual maps ensure one-to-one character mapping. | Hash Map, String Iteration | O(n) | O(1) | `Map<Character, Character> sToT = new HashMap<>(), tToS = new HashMap<>(); for (int i = 0; i < s.length(); i++) { char c1 = s.charAt(i), c2 = t.charAt(i); if (sToT.containsKey(c1) && sToT.get(c1) != c2 || tToS.containsKey(c2) && tToS.get(c2) != c1) return false; sToT.put(c1, c2); tToS.put(c2, c1); } return true;` |
| 384 | Ugly Number II | 264 | https://leetcode.com/problems/ugly-number-ii/ | DP: `dp[i]` = i-th ugly number. Track pointers p2, p3, p5 for next multiples. Next ugly = min(dp[p2]*2, dp[p3]*3, dp[p5]*5). Increment pointers for min. | Merge-like DP. Pointers track next multiples of 2, 3, 5. | Dynamic Programming | O(n) | O(n) | `long[] dp = new long[n]; dp[0] = 1; int p2 = 0, p3 = 0, p5 = 0; for (int i = 1; i < n; i++) { dp[i] = Math.min(dp[p2] * 2, Math.min(dp[p3] * 3, dp[p5] * 5)); if (dp[i] == dp[p2] * 2) p2++; if (dp[i] == dp[p3] * 3) p3++; if (dp[i] == dp[p5] * 5) p5++; } return (int) dp[n - 1];` |
| 385 | Super Ugly Number | 313 | https://leetcode.com/problems/super-ugly-number/ | DP: `dp[i]` = i-th super ugly number. Track pointers for each prime. Next = min(dp[pointers[j]] * primes[j]). Increment pointers for min. | Generalize Ugly Number II. Track pointers for all primes. | Dynamic Programming | O(n * k) | O(n + k) | `long[] dp = new long[n]; dp[0] = 1; int[] pointers = new int[primes.length]; for (int i = 1; i < n; i++) { long min = Long.MAX_VALUE; for (int j = 0; j < primes.length; j++) min = Math.min(min, dp[pointers[j]] * primes[j]); dp[i] = min; for (int j = 0; j < primes.length; j++) if (dp[i] == dp[pointers[j]] * primes[j]) pointers[j]++; } return (int) dp[n - 1];` |
| 386 | Strobogrammatic Number | 246 | https://leetcode.com/problems/strobogrammatic-number/ | Two pointers: check if chars at left/right form strobogrammatic pair (0->0, 1->1, 6->9, 8->8, 9->6). Middle char for odd length must be 0, 1, 8. | Two pointers verify strobogrammatic mappings. Check middle for odd length. | Two Pointers, String Iteration | O(n) | O(1) | `Map<Character, Character> map = new HashMap<>(); map.put('0', '0'); map.put('1', '1'); map.put('6', '9'); map.put('8', '8'); map.put('9', '6'); int left = 0, right = num.length() - 1; while (left <= right) { if (!map.containsKey(num.charAt(left)) || map.get(num.charAt(left)) != num.charAt(right)) return false; left++; right--; } return true;` |
| 387 | A Number After a Double Reversal | 2119 | https://leetcode.com/problems/a-number-after-a-double-reversal/ | Number equals double reversal if no trailing zeros (except n = 0). Check if n == 0 or n % 10 != 0. | Trailing zeros removed in first reversal can’t be restored. | Arithmetic, Conditional Logic | O(1) | O(1) | `return num == 0 || num % 10 != 0;` |
| 388 | Find Whether a Given Integer is Power of 3 or Not | N/A | https://www.geeksforgeeks.org/find-whether-a-given-integer-is-a-power-of-3-or-not/ | If n ≤ 0, false. Repeatedly divide by 3 while divisible and > 1. Return true if final n = 1. | Repeated division checks if n is 3^k. | Arithmetic, Loop | O(log_3 n) | O(1) | `if (n <= 0) return false; while (n > 1) { if (n % 3 != 0) return false; n /= 3; } return n == 1;` |
| 389 | Find the Count of Good Integers | 2551 | https://leetcode.com/problems/put-marbles-in-bags/ | (Corrected to LC 2551: Put Marbles in Bags) Compute min/max cost of splitting marbles into k bags. Cost = sum of (max - min) per bag = sum of k-1 adjacent differences. Sort differences, sum smallest k-1 for min, largest k-1 for max. | Cost = sum of k-1 splits. Sort differences, pick extremes. | Array Manipulation, Sorting | O(n log n) | O(n) | `Arrays.sort(weights); long minCost = 0, maxCost = 0; for (int i = 0; i < k - 1; i++) { minCost += weights[i + 1] - weights[i]; maxCost += weights[weights.length - 1 - i] - weights[weights.length - 2 - i]; } return maxCost - minCost;` |
| 390 | Count Symmetric Integers | 2843 | https://leetcode.com/problems/count-symmetric-integers/ | Iterate [low, high]. For each num, convert to string. If length even, sum first half and second half digits. Increment count if sums equal. | Check even length, compare half-digit sums. | Iteration, String Manipulation | O((high - low) * log high) | O(log high) | `int count = 0; for (int i = low; i <= high; i++) { String s = String.valueOf(i); if (s.length() % 2 == 0) { int sum1 = 0, sum2 = 0; for (int j = 0; j < s.length() / 2; j++) sum1 += s.charAt(j) - '0'; for (int j = s.length() / 2; j < s.length(); j++) sum2 += s.charAt(j) - '0'; if (sum1 == sum2) count++; } } return count;` |



| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 391 | Bulb Switcher | 319 | https://leetcode.com/problems/bulb-switcher/ | Bulb `i` is on if toggled odd times, i.e., has odd number of factors. Only perfect squares have odd factors. Count perfect squares ≤ n by computing `floor(sqrt(n))`. | Perfect squares have odd factors, so count squares up to n. | Math, Square Root | O(1) | O(1) | `return (int) Math.sqrt(n);` |
| 392 | Count the Number of Powerful Integers | 2438 | https://leetcode.com/problems/count-the-number-of-powerful-integers/ | Count integers x^y (x ≥ 1, y ≥ 2) in [start, finish]. Iterate bases x from 1 to sqrt(finish). For each x, compute powers x^y until > finish. Check if power is in [start, finish]. Use set for unique counts. Handle overflow with long. | Iterate bases up to sqrt(finish), generate powers, filter by range. | Generation, Set, Math | O(sqrt(finish) * log(finish)) | O(sqrt(finish)) | `Set<Long> set = new HashSet<>(); for (long x = 1; x * x <= finish; x++) { long power = x * x; while (power <= finish) { if (power >= start) set.add(power); power *= x; } } return set.size();` |
| 393 | Count the Number of Ideal Arrays | 2338 | https://leetcode.com/problems/count-the-number-of-ideal-arrays/ | Count ideal arrays of length n with elements ≤ maxValue, where arr[i] divides arr[i+1]. Use DP: `dp[i][v]` = ways to form array of length i ending at v. For each i, v, sum `dp[i-1][u]` where u divides v. Precompute divisors. Apply modulo. | Model as choosing divisors. DP on length and end value, using divisor relations. | Dynamic Programming, Number Theory | O(n * maxValue * log(maxValue)) | O(n * maxValue) | `long MOD = 1_000_000_007; long[][] dp = new long[n + 1][maxValue + 1]; for (int v = 1; v <= maxValue; v++) dp[1][v] = 1; for (int i = 2; i <= n; i++) { for (int v = 1; v <= maxValue; v++) { for (int u = 1; u * u <= v; u++) { if (v % u == 0) { dp[i][v] = (dp[i][v] + dp[i - 1][u]) % MOD; if (v / u != u) dp[i][v] = (dp[i][v] + dp[i - 1][v / u]) % MOD; } } } } long result = 0; for (int v = 1; v <= maxValue; v++) result = (result + dp[n][v]) % MOD; return (int) result;` |
| 394 | Find the kth Factor of n | 1472 | https://leetcode.com/problems/the-kth-factor-of-n/ | Collect factors up to sqrt(n). For each i where n % i == 0, add i and (if i*i != n) n/i. Store factors in list. If k ≤ list size, return kth factor; else return -1. | Factors up to sqrt(n), then n/i in reverse order. Check k validity. | Arithmetic, Factorization | O(sqrt(n)) | O(sqrt(n)) | `List<Integer> factors = new ArrayList<>(); for (int i = 1; i * i <= n; i++) { if (n % i == 0) { factors.add(i); if (i * i != n) factors.add(n / i); } } Collections.sort(factors); return k <= factors.size() ? factors.get(k - 1) : -1;` |
| 395 | Count Largest Group | 1399 | https://leetcode.com/problems/count-largest-group/ | Compute digit sum for each number 1 to n. Use map to count numbers per digit sum. Find max group size and count groups with that size. | Group by digit sum, find max size, count max-sized groups. | Hash Map, Digit Sum | O(n * log n) | O(log n) | `Map<Integer, Integer> map = new HashMap<>(); for (int i = 1; i <= n; i++) { int sum = 0, num = i; while (num > 0) { sum += num % 10; num /= 10; } map.put(sum, map.getOrDefault(sum, 0) + 1); } int maxSize = Collections.max(map.values()); int count = 0; for (int size : map.values()) if (size == maxSize) count++; return count;` |
| 396 | Check If Array Pairs Are Divisible by k | 1497 | https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/ | Count remainders modulo k. For r, count[r] must equal count[k-r] (or even if r == 0 or r == k/2 for even k). Handle negative numbers with (x % k + k) % k. | Pair remainders r and k-r. Ensure even counts for r == 0, k/2. | Hash Map, Modular Arithmetic | O(n + k) | O(k) | `int[] count = new int[k]; for (int x : arr) count[(x % k + k) % k]++; for (int r = 0; r <= k / 2; r++) { if (r == 0 || (k % 2 == 0 && r == k / 2)) { if (count[r] % 2 != 0) return false; } else if (count[r] != count[k - r]) return false; } return true;` |
| 397 | Greatest Common Divisor of Strings | 1071 | https://leetcode.com/problems/greatest-common-divisor-of-strings/ | Check if str1 + str2 == str2 + str1. If true, GCD string length is gcd(len(str1), len(str2)). Return prefix of str1 of that length. Else, return "". | Commutative concatenation implies GCD string. Use Euclidean GCD. | String Manipulation, GCD | O(n1 + n2 + log(min(n1, n2))) | O(n1 + n2) | `if (!(str1 + str2).equals(str2 + str1)) return ""; int gcd = gcd(str1.length(), str2.length()); return str1.substring(0, gcd); int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }` |
| 398 | Maximize Product of Lengths of Strings Having No Common Characters | N/A | https://www.geeksforgeeks.org/maximize-product-of-lengths-of-pair-of-strings-with-no-common-characters/ | Convert each string to bitmask (bit i = 1 if char 'a'+i present). For each pair (i, j), if masks[i] & masks[j] == 0, compute length product. Track max product. | Bitmask for char presence. No common chars if AND = 0. | Bit Manipulation, Array Iteration | O(n^2 + n*L) | O(n) | `int[] masks = new int[arr.length]; for (int i = 0; i < arr.length; i++) for (char c : arr[i].toCharArray()) masks[i] |= 1 << (c - 'a'); int maxProd = 0; for (int i = 0; i < arr.length; i++) for (int j = i + 1; j < arr.length; j++) if ((masks[i] & masks[j]) == 0) maxProd = Math.max(maxProd, arr[i].length() * arr[j].length()); return maxProd;` |
| 399 | Painting Fence Algorithm | N/A | https://www.geeksforgeeks.org/painting-fence-algorithm/ | DP: `diff[i]` = ways to paint i posts with last two different colors, `same[i]` = last two same. `diff[i] = (diff[i-1] + same[i-1]) * (k-1)`, `same[i] = diff[i-1]`. Optimize to O(1) space. | Track last two colors’ parity. Optimize space with variables. | Dynamic Programming | O(n) | O(1) | `long diff = k, same = 0, MOD = 1_000_000_007; for (int i = 2; i <= n; i++) { long newDiff = (diff + same) * (k - 1) % MOD; same = diff; diff = newDiff; } return (int) ((diff + same) % MOD);` |
| 400 | Roman to Integer | 13 | https://leetcode.com/problems/roman-to-integer/ | Iterate right to left. If current value < right value, subtract it; else add it. Use map for Roman numeral values. | Right-to-left handles subtractive cases (e.g., IV = 5 - 1). | Hash Map, String Iteration | O(n) | O(1) | `Map<Character, Integer> map = Map.of('I', 1, 'V', 5, 'X', 10, 'L', 50, 'C', 100, 'D', 500, 'M', 1000); int result = 0, prev = 0; for (int i = s.length() - 1; i >= 0; i--) { int curr = map.get(s.charAt(i)); result += curr < prev ? -curr : curr; prev = curr; } return result;` |
| 401 | Excel Sheet Column Title | 168 | https://leetcode.com/problems/excel-sheet-column-title/ | Base-26 conversion, 1-indexed. Subtract 1 from n, take modulo 26 for char, divide by 26. Build string right to left, reverse. | Subtract 1 for 1-indexing (A=1). Reverse final string. | Math, Base Conversion | O(log_26 n) | O(log_26 n) | `StringBuilder sb = new StringBuilder(); while (n > 0) { n--; sb.append((char) ('A' + n % 26)); n /= 26; } return sb.reverse().toString();` |
| 402 | Integer to English Words | 273 | https://leetcode.com/problems/integer-to-english-words/ | Process groups of 1000 (billion, million, thousand). Convert <1000 using helpers for <20, <100, <1000. Concatenate with scale words. Handle zero. | Break into thousands, use helpers for smaller numbers. | String Manipulation, Math | O(log n) | O(log n) | `String[] below20 = {"", "One", "Two", ..., "Nineteen"}; String[] tens = {"", "", "Twenty", ..., "Ninety"}; String[] thousands = {"", "Thousand", "Million", "Billion"}; if (num == 0) return "Zero"; StringBuilder sb = new StringBuilder(); for (int i = 3; i >= 0; i--) { if (num >= Math.pow(1000, i)) { int group = num / (int) Math.pow(1000, i); sb.append(convertLessThan1000(group)).append(" ").append(thousands[i]).append(" "); num %= (int) Math.pow(1000, i); } } return sb.toString().trim(); String convertLessThan1000(int num) { if (num == 0) return ""; if (num < 20) return below20[num]; if (num < 100) return tens[num / 10] + (num % 10 > 0 ? " " + below20[num % 10] : ""); return below20[num / 100] + " Hundred" + (num % 100 > 0 ? " " + convertLessThan1000(num % 100) : ""); }` |
| 403 | Converting Roman Numerals to Decimal Lying Between 1 to 3999 | N/A | https://www.geeksforgeeks.org/converting-roman-numerals-decimal-lying-1-3999/ | Same as Roman to Integer (400). Iterate right to left. Subtract if current < right, else add. Use map for values. | Right-to-left simplifies subtractive cases. | Hash Map, String Iteration | O(n) | O(1) | `Map<Character, Integer> map = Map.of('I', 1, 'V', 5, 'X', 10, 'L', 50, 'C', 100, 'D', 500, 'M', 1000); int result = 0, prev = 0; for (int i = s.length() - 1; i >= 0; i--) { int curr = map.get(s.charAt(i)); result += curr < prev ? -curr : curr; prev = curr; } return result;` |
| 404 | Find Excel Column Number from Column Title | N/A | https://www.geeksforgeeks.org/find-excel-column-number-column-title/ | Base-26 conversion. Iterate left to right, result = result * 26 + (char - 'A' + 1). | Accumulate like base-10, but base-26 with 1-indexed chars. | Math, Base Conversion | O(L) | O(1) | `int result = 0; for (char c : s.toCharArray()) result = result * 26 + (c - 'A' + 1); return result;` |
| 405 | Find Excel Column Name Given a Column Number | N/A | https://www.geeksforgeeks.org/find-excel-column-name-given-number/ | Same as Excel Sheet Column Title (401). Base-26, 1-indexed. Subtract 1, modulo 26, divide by 26. Build right to left, reverse. | Handle 1-indexing by subtracting 1 before modulo. | Math, Base Conversion | O(log_26 n) | O(log_26 n) | `StringBuilder sb = new StringBuilder(); while (n > 0) { n--; sb.append((char) ('A' + n % 26)); n /= 26; } return sb.reverse().toString();` |
| 406 | Represent the Fraction of Two Numbers in the String Format | N/A | https://www.geeksforgeeks.org/represent-the-fraction-of-two-numbers-in-the-string-format/ | Compute integer part. For decimal, simulate long division. Use map to track remainders and their indices. If remainder repeats, add parentheses. Handle signs, zero denominator. | Long division with remainder tracking for repeating decimals. | Math, String Manipulation | O(D) | O(D) | `if (denominator == 0) return "Invalid"; StringBuilder sb = new StringBuilder(); if (numerator * denominator < 0) sb.append("-"); long num = Math.abs((long) numerator), den = Math.abs((long) denominator); sb.append(num / den); num %= den; if (num == 0) return sb.toString(); sb.append("."); Map<Long, Integer> map = new HashMap<>(); while (num != 0) { num *= 10; if (map.containsKey(num)) { sb.insert(map.get(num), "("); sb.append(")"); break; } map.put(num, sb.length()); sb.append(num / den); num %= den; } return sb.toString();` |
| 407 | KMP Algorithm for Pattern Searching | N/A | https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/ | Compute LPS array: `lps[i]` = length of longest prefix-suffix for pattern[0..i]. Search text using LPS to skip matched prefixes on mismatch. Return indices of matches. | LPS enables efficient mismatch handling by skipping redundant comparisons. | String Matching, KMP | O(N + M) | O(M) | `List<Integer> result = new ArrayList<>(); int[] lps = new int[pattern.length()]; int len = 0, i = 1; while (i < pattern.length()) { if (pattern.charAt(i) == pattern.charAt(len)) lps[i++] = ++len; else if (len > 0) len = lps[len - 1]; else lps[i++] = 0; } i = 0; int j = 0; while (i < text.length()) { if (text.charAt(i) == pattern.charAt(j)) { i++; j++; } if (j == pattern.length()) { result.add(i - j); j = lps[j - 1]; } else if (i < text.length() && text.charAt(i) != pattern.charAt(j)) { if (j > 0) j = lps[j - 1]; else i++; } } return result;` |
| 408 | Find the Index of the First Occurrence in a String | 28 | https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/ | Use KMP for efficiency. Compute LPS for needle. Search haystack, using LPS to skip on mismatch. Return first match index or -1. | KMP’s LPS array optimizes mismatch handling. | String Matching, KMP | O(N + M) | O(M) | `if (needle.isEmpty()) return 0; int[] lps = new int[needle.length()]; int len = 0, i = 1; while (i < needle.length()) { if (needle.charAt(i) == needle.charAt(len)) lps[i++] = ++len; else if (len > 0) len = lps[len - 1]; else lps[i++] = 0; } i = 0; int j = 0; while (i < haystack.length()) { if (haystack.charAt(i) == needle.charAt(j)) { i++; j++; } if (j == needle.length()) return i - j; else if (i < haystack.length() && haystack.charAt(i) != needle.charAt(j)) { if (j > 0) j = lps[j - 1]; else i++; } } return -1;` |
| 409 | Find a Tour that Visits All Stations | N/A | https://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/ | If total gas ≥ total cost, solution exists. Track cumulative gas. If gas < 0, reset start to next station, reset gas. Return start after one pass. | Greedy: reset start when gas deficit occurs. | Array Iteration, Greedy | O(n) | O(1) | `int totalGas = 0, currGas = 0, start = 0; for (int i = 0; i < gas.length; i++) { totalGas += gas[i] - cost[i]; currGas += gas[i] - cost[i]; if (currGas < 0) { start = i + 1; currGas = 0; } } return totalGas >= 0 ? start : -1;` |
| 410 | Russian Doll Envelopes | 354 | https://leetcode.com/problems/russian-doll-envelopes/ | Sort by width ascending, height descending for ties. Find LIS on heights using binary search. For each height, find smallest tail ≥ it, replace or append. | Sort to reduce to LIS. Height descending avoids same-width nesting. | Sorting, LIS, Binary Search | O(n log n) | O(n) | `Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]); List<Integer> tails = new ArrayList<>(); for (int[] env : envelopes) { int h = env[1]; int i = Collections.binarySearch(tails, h); if (i < 0) i = -(i + 1); if (i == tails.size()) tails.add(h); else tails.set(i, h); } return tails.size();` |
| 411 | Optimal Account Balancing | 465 | https://leetcode.com/problems/optimal-account-balancing/ | Compute net balances. Backtrack on non-zero balances. For each debtor, try settling with each creditor, recurse. Track min transactions. Memoize on balance state. | Backtrack on non-zero balances, memoize to prune redundant states. | Backtracking, Graph | O(n!) | O(n) | `int[] debts = new int[transactions.length]; for (int[] t : transactions) { debts[t[0]] -= t[2]; debts[t[1]] += t[2]; } List<Integer> nonZero = new ArrayList<>(); for (int d : debts) if (d != 0) nonZero.add(d); return backtrack(nonZero, 0, new HashMap<>()); int backtrack(List<Integer> debts, int start, Map<String, Integer> memo) { while (start < debts.size() && debts.get(start) == 0) start++; if (start == debts.size()) return 0; String key = debts.toString() + "," + start; if (memo.containsKey(key)) return memo.get(key); int min = Integer.MAX_VALUE; for (int i = start + 1; i < debts.size(); i++) { if (debts.get(start) * debts.get(i) < 0) { debts.set(i, debts.get(i) + debts.get(start)); min = Math.min(min, 1 + backtrack(debts, start + 1, memo)); debts.set(i, debts.get(i) - debts.get(start)); } } memo.put(key, min); return min; }` |
| 412 | Car Pooling | 1094 | https://leetcode.com/problems/car-pooling/ | Use difference array. For each trip, add passengers at start, subtract at end. Compute cumulative sum. If any sum > capacity, return false. | Difference array tracks passenger changes efficiently. | Sweep Line, Difference Array | O(n + max_location) | O(max_location) | `int[] diff = new int[1001]; for (int[] trip : trips) { diff[trip[1]] += trip[0]; diff[trip[2]] -= trip[0]; } int curr = 0; for (int d : diff) { curr += d; if (curr > capacity) return false; } return true;` |
| 413 | The Earliest Moment When Everyone Become Friends | 1101 | https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/ | Sort logs by timestamp. Use Union-Find. Union friends in each log. Track components. Return timestamp when components = 1, else -1. | Union-Find tracks connectivity. Sort ensures earliest time. | Union-Find, Sorting | O(E log E + N alpha(N)) | O(N) | `Arrays.sort(logs, (a, b) -> a[0] - b[0]); int[] parent = new int[n], rank = new int[n]; for (int i = 0; i < n; i++) parent[i] = i; int components = n; for (int[] log : logs) { if (union(log[1], log[2], parent, rank)) components--; if (components == 1) return log[0]; } return -1; int find(int x, int[] parent) { if (parent[x] != x) parent[x] = find(parent[x], parent); return parent[x]; } boolean union(int x, int y, int[] parent, int[] rank) { int px = find(x, parent), py = find(y, parent); if (px == py) return false; if (rank[px] < rank[py]) parent[px] = py; else if (rank[px] > rank[py]) parent[py] = px; else { parent[py] = px; rank[px]++; } return true; }` |
| 414 | Number of Operations to Make Network Connected | 1319 | https://leetcode.com/problems/number-of-operations-to-make-network-connected/ | If connections < n-1, return -1. Use Union-Find to count components. Operations = components - 1. | Components - 1 cables needed to connect all. | Union-Find, Graph | O(E alpha(N)) | O(N) | `if (connections.length < n - 1) return -1; int[] parent = new int[n]; for (int i = 0; i < n; i++) parent[i] = i; int components = n; for (int[] conn : connections) if (union(conn[0], conn[1], parent)) components--; return components - 1; int find(int x, int[] parent) { if (parent[x] != x) parent[x] = find(parent[x], parent); return parent[x]; } boolean union(int x, int y, int[] parent) { int px = find(x, parent), py = find(y, parent); if (px == py) return false; parent[px] = py; return true; }` |
| 415 | Minimum Knight Moves | 1197 | https://leetcode.com/problems/minimum-knight-moves/ | BFS from (0,0) to (x,y). Use absolute values for symmetry. Queue stores (row, col, dist). Explore 8 knight moves. Use visited set to avoid cycles. Return dist of first (x,y). | Symmetry reduces to first quadrant. BFS finds shortest path. | BFS, Graph | O(max(|x|, |y|)^2) | O(max(|x|, |y|)^2) | `x = Math.abs(x); y = Math.abs(y); Queue<int[]> queue = new LinkedList<>(); Set<String> visited = new HashSet<>(); queue.offer(new int[]{0, 0, 0}); visited.add("0,0"); int[][] dirs = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}}; while (!queue.isEmpty()) { int[] curr = queue.poll(); if (curr[0] == x && curr[1] == y) return curr[2]; for (int[] dir : dirs) { int r = curr[0] + dir[0], c = curr[1] + dir[1]; if (r >= -2 && c >= -2 && !visited.contains(r + "," + c)) { queue.offer(new int[]{r, c, curr[2] + 1}); visited.add(r + "," + c); } } } return -1;` |
| 416 | Bus Routes | 815 | https://leetcode.com/problems/bus-routes/ | BFS on routes. Build map: stop -> list of route indices. Start from routes containing source. Queue stores (route, buses). Track visited routes/stops. Return min buses to reach target. | Graph of routes, edges via shared stops. BFS for min buses. | BFS, Graph | O(Sum(routes_length)) | O(Total stops + routes) | `Map<Integer, List<Integer>> stopToRoutes = new HashMap<>(); for (int i = 0; i < routes.length; i++) for (int stop : routes[i]) stopToRoutes.computeIfAbsent(stop, k -> new ArrayList<>()).add(i); Queue<int[]> queue = new LinkedList<>(); Set<Integer> visitedRoutes = new HashSet<>(), visitedStops = new HashSet<>(); for (int route : stopToRoutes.getOrDefault(source, new ArrayList<>())) { queue.offer(new int[]{route, 1}); visitedRoutes.add(route); } while (!queue.isEmpty()) { int[] curr = queue.poll(); for (int stop : routes[curr[0]]) { if (stop == target) return curr[1]; if (!visitedStops.contains(stop)) { visitedStops.add(stop); for (int nextRoute : stopToRoutes.getOrDefault(stop, new ArrayList<>())) if (!visitedRoutes.contains(nextRoute)) { queue.offer(new int[]{nextRoute, curr[1] + 1}); visitedRoutes.add(nextRoute); } } } } return -1;` |
| 417 | Binary Tree Cameras | 968 | https://leetcode.com/problems/binary-tree-cameras/ | Greedy post-order DFS. Node status: 0 (needs camera), 1 (has camera), 2 (covered). If child is 0, parent needs camera (1). If child is 1, parent is 2. If both 2 or null, parent is 0 (needs camera). Count cameras. | Bottom-up greedy: place cameras to cover children needing them. | Tree Traversal, Greedy | O(n) | O(h) | `int cameras = 0; public int minCameraCover(TreeNode root) { if (dfs(root) == 0) cameras++; return cameras; } int dfs(TreeNode node) { if (node == null) return 2; int left = dfs(node.left), right = dfs(node.right); if (left == 0 || right == 0) { cameras++; return 1; } return left == 1 || right == 1 ? 2 : 0; }` |
| 418 | Second Minimum Node In a Binary Tree | 671 | https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/ | DFS. Root is min. Track min1 (root.val) and min2 (infinity). If node.val > min1 and < min2, update min2. If node.val == min1, recurse children. | Leverage tree property: parent = min(children). Track second min. | Tree Traversal, DFS | O(n) | O(h) | `long min2 = Long.MAX_VALUE; public int findSecondMinimumValue(TreeNode root) { dfs(root, root.val); return min2 == Long.MAX_VALUE ? -1 : (int) min2; } void dfs(TreeNode node, long min1) { if (node == null) return; if (node.val > min1 && node.val < min2) min2 = node.val; if (node.val == min1) { dfs(node.left, min1); dfs(node.right, min1); } }` |
| 419 | Roots of a Tree that Give Minimum Height | N/A | https://www.geeksforgeeks.org/roots-tree-give-minimum-height/ | Iteratively remove leaves (degree 1) via BFS until 1 or 2 nodes remain. Build adjacency list, compute degrees. Queue degree 1 nodes. Process queue, update degrees, add new degree 1 nodes. | Leaf trimming reduces to centroid (1 or 2 nodes). | Graph, BFS | O(n) | O(n) | `List<Integer> result = new ArrayList<>(); List<Integer>[] adj = new List[n]; for (int i = 0; i < n; i++) adj[i] = new ArrayList<>(); for (int[] edge : edges) { adj[edge[0]].add(edge[1]); adj[edge[1]].add(edge[0]); } int[] degree = new int[n]; for (int i = 0; i < n; i++) degree[i] = adj[i].size(); Queue<Integer> queue = new LinkedList<>(); for (int i = 0; i < n; i++) if (degree[i] == 1) queue.offer(i); int remaining = n; while (remaining > 2) { int size = queue.size(); remaining -= size; for (int i = 0; i < size; i++) { int leaf = queue.poll(); degree[leaf]--; for (int neighbor : adj[leaf]) if (--degree[neighbor] == 1) queue.offer(neighbor); } } while (!queue.isEmpty()) result.add(queue.poll()); return result;` |
| 420 | Closest Leaf in a Binary Tree | 742 | https://leetcode.com/problems/closest-leaf-in-a-binary-tree/ | Convert tree to undirected graph (adj list with parent links). BFS from node k. State: (node, dist). First leaf (no children) is closest. Use visited set. | Tree as graph, BFS finds shortest path to leaf. | Graph, BFS | O(n) | O(n) | `Map<Integer, List<Integer>> adj = new HashMap<>(); Map<Integer, TreeNode> nodes = new HashMap<>(); buildGraph(root, null, nodes, adj); Queue<int[]> queue = new LinkedList<>(); Set<Integer> visited = new HashSet<>(); queue.offer(new int[]{k, 0}); visited.add(k); while (!queue.isEmpty()) { int[] curr = queue.poll(); TreeNode node = nodes.get(curr[0]); if (node.left == null && node.right == null) return curr[0]; for (int next : adj.get(curr[0])) if (!visited.contains(next)) { queue.offer(new int[]{next, curr[1] + 1}); visited.add(next); } } return -1; void buildGraph(TreeNode node, TreeNode parent, Map<Integer, TreeNode> nodes, Map<Integer, List<Integer>> adj) { if (node == null) return; nodes.put(node.val, node); adj.computeIfAbsent(node.val, k -> new ArrayList<>()); if (parent != null) { adj.get(node.val).add(parent.val); adj.get(parent.val).add(node.val); } buildGraph(node.left, node, nodes, adj); buildGraph(node.right, node, nodes, adj); }` |
| 421 | Deletion in Binary Tree | N/A | https://www.geeksforgeeks.org/deletion-binary-tree/ | BFS to find node with key and deepest rightmost node. Replace key node’s value with deepest node’s value. Delete deepest node by nulling parent’s child pointer. | Swap with deepest node, then delete deepest. | Tree Traversal, BFS | O(n) | O(n) | `if (root == null) return root; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); TreeNode keyNode = null, last = null, lastParent = null; while (!queue.isEmpty()) { last = queue.poll(); if (last.val == key) keyNode = last; if (last.left != null) { queue.offer(last.left); lastParent = last; } if (last.right != null) { queue.offer(last.right); lastParent = last; } } if (keyNode != null) { keyNode.val = last.val; if (lastParent != null) { if (lastParent.left == last) lastParent.left = null; else lastParent.right = null; } else root = null; } return root;` |
| 422 | Interesting Method to Generate Binary Numbers from 1 to n | N/A | https://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/ | BFS with queue. Start with "1". Dequeue string, add to result, enqueue string + "0" and string + "1". Repeat n times. | Queue generates binary strings in order via BFS. | BFS, String Manipulation | O(n * log n) | O(n * log n) | `List<String> result = new ArrayList<>(); Queue<String> queue = new LinkedList<>(); queue.offer("1"); for (int i = 0; i < n; i++) { String curr = queue.poll(); result.add(curr); queue.offer(curr + "0"); queue.offer(curr + "1"); } return result;` |
| 423 | Max Points on a Line | 149 | https://leetcode.com/problems/max-points-on-a-line/ | For each point, compute slopes to others. Use map to count points per slope. Handle duplicates. Max count + duplicates is points on a line. Track global max. | Slope map per point. GCD for precise slope. Handle duplicates. | Hash Map, Geometry | O(n^2) | O(n) | `int max = Math.min(2, points.length); for (int i = 0; i < points.length; i++) { Map<String, Integer> slopes = new HashMap<>(); int duplicates = 0; for (int j = i + 1; j < points.length; j++) { if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) { duplicates++; continue; } int dy = points[j][1] - points[i][1], dx = points[j][0] - points[i][0]; int g = gcd(dy, dx); String key = (dy / g) + "/" + (dx / g); slopes.put(key, slopes.getOrDefault(key, 0) + 1); } int localMax = duplicates; for (int count : slopes.values()) localMax = Math.max(localMax, count + duplicates); max = Math.max(max, localMax + 1); } return max; int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }` |
| 424 | H-Index | 274 | https://leetcode.com/problems/h-index/ | Bucket sort: count citations in array of size n+1. Iterate from n to 0, accumulate counts. First h where count ≥ h is answer. | Bucket sort optimizes to O(n). Accumulate counts for h-index. | Bucket Sort, Array Iteration | O(n) | O(n) | `int[] buckets = new int[citations.length + 1]; for (int c : citations) buckets[Math.min(c, citations.length)]++; int count = 0; for (int h = buckets.length - 1; h >= 0; h--) { count += buckets[h]; if (count >= h) return h; } return 0;` |
| 425 | Find the Celebrity | 277 | https://leetcode.com/problems/find-the-celebrity/ | Eliminate non-celebrities: if a knows b, a is not celebrity; else b is not. Verify candidate: everyone knows them, they know no one. | Single pass to find candidate, second to verify. | Graph, Elimination | O(n) | O(1) | `int candidate = 0; for (int i = 1; i < n; i++) if (knows(candidate, i) || !knows(i, candidate)) candidate = i; for (int i = 0; i < n; i++) if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) return -1; return candidate;` |
| 426 | Find Servers That Handled Most Number of Requests | 1606 | https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/ | Use TreeSet for available servers, PriorityQueue for busy servers (by finish time). Process requests by time, free servers, assign cyclically. Track counts, find max. | TreeSet for cyclic assignment, PQ for busy servers. | Priority Queue, TreeSet | O(m log n + n log n) | O(n) | `TreeSet<Integer> available = new TreeSet<>(); PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> a[0] - b[0]); int[] counts = new int[k]; for (int i = 0; i < k; i++) available.add(i); int maxCount = 0; for (int i = 0; i < arrival.length; i++) { while (!busy.isEmpty() && busy.peek()[0] <= arrival[i]) available.add(busy.poll()[1]); Integer server = available.ceiling(i % k); if (server == null) server = available.first(); if (server != null) { available.remove(server); busy.offer(new int[]{arrival[i] + weight[i], server}); counts[server]++; maxCount = Math.max(maxCount, counts[server]); } } List<Integer> result = new ArrayList<>(); for (int i = 0; i < k; i++) if (counts[i] == maxCount) result.add(i); return result;` |
| 427 | Maximum Number of Visible Points | 1610 | https://leetcode.com/problems/maximum-number-of-visible-points/ | Convert points to angles via atan2. Add points at location. Sort angles, duplicate with +360°. Sliding window of size angle. Max window size + center points. | Angles to sliding window, duplicate for wrap-around. | Geometry, Sliding Window | O(n log n) | O(n) | `int centerPoints = 0; List<Double> angles = new ArrayList<>(); for (int[] p : points) { if (p[0] == location[0] && p[1] == location[1]) centerPoints++; else angles.add(Math.toDegrees(Math.atan2(p[1] - location[1], p[0] - location[0]))); } Collections.sort(angles); for (int i = 0; i < angles.size(); i++) angles.add(angles.get(i) + 360); int max = 0, left = 0; for (int right = 0; right < angles.size(); right++) { while (angles.get(right) - angles.get(left) > angle) left++; max = Math.max(max, right - left + 1); } return max + centerPoints;` |
| 428 | Maximize Distance to Closest Person | 849 | https://leetcode.com/problems/maximize-distance-to-closest-person/ | Single pass: track last 1’s index. For each 0, compute distance to next 1 (if exists). Max distance is max of first 0 to first 1, last 1 to end, or gaps between 1s. | Track last 1, compute distances for 0s, consider edges. | Array Iteration, Two Pointers | O(n) | O(1) | `int maxDist = 0, lastOne = -1; for (int i = 0; i < seats.length; i++) { if (seats[i] == 1) { if (lastOne == -1) maxDist = i; else maxDist = Math.max(maxDist, (i - lastOne) / 2); lastOne = i; } } if (lastOne != seats.length - 1) maxDist = Math.max(maxDist, seats.length - 1 - lastOne); return maxDist;` |
| 429 | Number of Visible People in a Queue | 1944 | https://leetcode.com/problems/number-of-visible-people-in-a-queue/ | Monotonic stack (decreasing). Iterate right to left. Pop heights ≤ current, count stack size as visible people. Push current height. | Stack keeps taller people to right. Pop blocked heights. | Stack, Monotonic Stack | O(n) | O(n) | `int[] result = new int[heights.length]; Stack<Integer> stack = new Stack<>(); for (int i = heights.length - 1; i >= 0; i--) { while (!stack.isEmpty() && stack.peek() <= heights[i]) stack.pop(); result[i] = stack.size(); stack.push(heights[i]); } return result;` |
| 430 | Car Fleet | 853 | https://leetcode.com/problems/car-fleet/ | Sort cars by position descending. Compute time to target. Stack times. If current time ≤ top, joins fleet; else new fleet. Return stack size. | Sort by position, track fleet times in stack. | Sorting, Stack | O(n log n) | O(n) | `int[][] cars = new int[position.length][2]; for (int i = 0; i < position.length; i++) cars[i] = new int[]{position[i], speed[i]}; Arrays.sort(cars, (a, b) -> b[0] - a[0]); Stack<Double> stack = new Stack<>(); for (int[] car : cars) { double time = (double) (target - car[0]) / car[1]; if (stack.isEmpty() || time > stack.peek()) stack.push(time); } return stack.size();` |
| 431 | Koko Eating Bananas | 875 | https://leetcode.com/problems/koko-eating-bananas/ | Binary search k in [1, max(piles)]. Check: sum(ceil(pile/k)) ≤ h. If possible, try smaller k; else larger k. | Binary search on rate, check total hours. | Binary Search | O(n log M) | O(1) | `int left = 1, right = Arrays.stream(piles).max().getAsInt(); while (left < right) { int mid = left + (right - left) / 2; long hours = 0; for (int p : piles) hours += (p + mid - 1) / mid; if (hours <= h) right = mid; else left = mid + 1; } return left;` |
| 432 | Last Stone Weight | 1046 | https://leetcode.com/problems/last-stone-weight/ | Max-Heap for stones. Repeatedly pop two max, smash (subtract), push result if > 0. Return last stone or 0. | Max-Heap ensures heaviest stones smashed first. | Priority Queue | O(n log n) | O(n) | `PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a); for (int s : stones) pq.offer(s); while (pq.size() > 1) { int x = pq.poll(), y = pq.poll(); if (x != y) pq.offer(x - y); } return pq.isEmpty() ? 0 : pq.poll();` |
| 433 | Capacity To Ship Packages Within D Days | 1011 | https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/ | Binary search capacity in [max(weights), sum(weights)]. Check: count days by summing weights until > capacity. If days ≤ D, try smaller; else larger. | Binary search on capacity, simulate shipping days. | Binary Search | O(n log S) | O(1) | `int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum(); while (left < right) { int mid = left + (right - left) / 2; int days = 1, curr = 0; for (int w : weights) { if (curr + w > mid) { days++; curr = w; } else curr += w; } if (days <= D) right = mid; else left = mid + 1; } return left;` |
| 434 | Min Cost Climbing Stairs | 746 | https://leetcode.com/problems/min-cost-climbing-stairs/ | DP: `dp[i]` = min cost to reach i. `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`. Optimize to O(1) space. Answer is min(dp[n-1], dp[n]). | Min cost from previous two steps. Use variables for space. | Dynamic Programming | O(n) | O(1) | `int prev2 = 0, prev1 = 0; for (int i = 2; i <= cost.length; i++) { int curr = Math.min(prev1 + cost[i - 1], prev2 + cost[i - 2]); prev2 = prev1; prev1 = curr; } return prev1;` |
| 435 | Paint House | 256 | https://leetcode.com/problems/paint-house/ | DP: `dp[i][j]` = min cost to paint house i with color j. `dp[i][j] = costs[i][j] + min(dp[i-1][other colors])`. Optimize to O(1). | Min cost from previous house’s other colors. | Dynamic Programming | O(n) | O(1) | `int[][] dp = costs; for (int i = 1; i < costs.length; i++) { dp[i][0] = costs[i][0] + Math.min(dp[i - 1][1], dp[i - 1][2]); dp[i][1] = costs[i][1] + Math.min(dp[i - 1][0], dp[i - 1][2]); dp[i][2] = costs[i][2] + Math.min(dp[i - 1][0], dp[i - 1][1]); } return Math.min(dp[costs.length - 1][0], Math.min(dp[costs.length - 1][1], dp[costs.length - 1][2]));` |
| 436 | Paint House II | 265 | https://leetcode.com/problems/paint-house-ii/ | DP: `dp[i][j] = costs[i][j] + min(dp[i-1][l], l != j)`. Optimize by tracking min and second min of previous row. | Use min/second min to avoid recomputing min for each color. | Dynamic Programming | O(n*k) | O(k) | `int[] prev = costs[0]; for (int i = 1; i < costs.length; i++) { int[] curr = new int[costs[0].length]; int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE, idx1 = -1; for (int j = 0; j < prev.length; j++) { if (prev[j] < min1) { min2 = min1; min1 = prev[j]; idx1 = j; } else if (prev[j] < min2) min2 = prev[j]; } for (int j = 0; j < curr.length; j++) curr[j] = costs[i][j] + (j == idx1 ? min2 : min1); prev = curr; } return Arrays.stream(prev).min().getAsInt();` |
| 437 | Maximum Average Subarray I | 643 | https://leetcode.com/problems/maximum-average-subarray-i/ | Sliding window of size k. Compute first window sum. Slide: subtract left, add right. Track max sum, return max/k. | Fixed-size window, update sum in O(1). | Sliding Window | O(n) | O(1) | `double sum = 0; for (int i = 0; i < k; i++) sum += nums[i]; double max = sum; for (int i = k; i < nums.length; i++) { sum += nums[i] - nums[i - k]; max = Math.max(max, sum); } return max / k;` |
| 438 | Ways to Make a Fair Array | 1664 | https://leetcode.com/problems/ways-to-make-a-fair-array/ | Precompute prefix/suffix even/odd sums. For each i, new even sum = prefix_even[i-1] + suffix_odd[i+1], new odd sum = prefix_odd[i-1] + suffix_even[i+1]. Count if equal. | Prefix/suffix sums handle removal, swap parity for sums. | Prefix Sum, Suffix Sum | O(n) | O(n) | `long[] prefixEven = new long[n + 1], prefixOdd = new long[n + 1]; for (int i = 0; i < n; i++) { prefixEven[i + 1] = prefixEven[i] + (i % 2 == 0 ? nums[i] : 0); prefixOdd[i + 1] = prefixOdd[i] + (i % 2 == 1 ? nums[i] : 0); } long[] suffixEven = new long[n + 1], suffixOdd = new long[n + 1]; for (int i = n - 1; i >= 0; i--) { suffixEven[i] = suffixEven[i + 1] + (i % 2 == 0 ? nums[i] : 0); suffixOdd[i] = suffixOdd[i + 1] + (i % 2 == 1 ? nums[i] : 0); } int count = 0; for (int i = 0; i < n; i++) if (prefixEven[i] + suffixOdd[i + 1] == prefixOdd[i] + suffixEven[i + 1]) count++; return count;` |
| 439 | Maximum Number of Removable Characters | 1898 | https://leetcode.com/problems/maximum-number-of-removable-characters/ | Binary search k in [0, removable.length]. Check: remove first k chars, verify if p is subsequence of s. Return max k where check is true. | Binary search on k, subsequence check in O(S). | Binary Search, Subsequence | O(L * S) | O(S) | `int left = 0, right = removable.length; while (left <= right) { int mid = left + (right - left) / 2; boolean[] removed = new boolean[s.length()]; for (int i = 0; i < mid; i++) removed[removable[i]] = true; int j = 0; for (int i = 0; i < s.length() && j < p.length(); i++) if (!removed[i] && s.charAt(i) == p.charAt(j)) j++; if (j == p.length()) left = mid + 1; else right = mid - 1; } return right;` |
| 440 | Frequency of the Most Frequent Element | 1838 | https://leetcode.com/problems/frequency-of-the-most-frequent-element/ | Sort array. Sliding window: right is target value. Cost = (right - left + 1) * nums[right] - window_sum. If cost > k, shrink left. Max window size is answer. | Sliding window with sorted array, track cost to equalize. | Sorting, Sliding Window | O(n log n) | O(1) | `Arrays.sort(nums); long sum = 0, maxFreq = 0; int left = 0; for (int right = 0; right < nums.length; right++) { sum += nums[right]; while ((long) (right - left + 1) * nums[right] - sum > k) sum -= nums[left++]; maxFreq = Math.max(maxFreq, right - left + 1); } return (int) maxFreq;` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 441 | Largest Rectangle in Histogram | 84 | https://leetcode.com/problems/largest-rectangle-in-histogram/ | Use monotonic stack (increasing heights). Push indices. For each height, if <= stack top, pop and compute area: `height[popped] * (current_index - stack.peek() - 1)`. Push current index. Add sentinel 0 at end to process remaining stack. | Monotonic stack tracks indices of increasing heights. Pop when smaller height found, compute area using popped height and width between indices. | Stack (Monotonic Stack) | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int maxArea = 0; for (int i = 0; i <= heights.length; i++) { int h = i == heights.length ? 0 : heights[i]; while (!stack.isEmpty() && h <= heights[stack.peek()]) { int height = heights[stack.pop()]; int width = stack.isEmpty() ? i : i - stack.peek() - 1; maxArea = Math.max(maxArea, height * width); } stack.push(i); } return maxArea;` |
| 442 | Minimize the Maximum Difference Between the Heights | N/A | https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/ | Sort array. Iterate splitting point `i`. Elements 0 to i subtract k, i+1 to n-1 add k. Min = `min(nums[0]+k, nums[i+1]-k)`, Max = `max(nums[n-1]-k, nums[i]+k)`. Update min of Max-Min. Check all add k or all subtract k cases. | Splitting| Sorting reduces problem to checking splits. Min/Max come from boundary elements after ±k. | Sorting, Array Iteration | O(n log n) | O(1) | `Arrays.sort(arr); int n = arr.length, minDiff = Integer.MAX_VALUE; for (int i = 0; i < n - 1; i++) { int minVal = Math.min(arr[0] + k, arr[i + 1] - k); int maxVal = Math.max(arr[n - 1] - k, arr[i] + k); minDiff = Math.min(minDiff, maxVal - minVal); } minDiff = Math.min(minDiff, arr[n - 1] + k - (arr[0] + k)); minDiff = Math.min(minDiff, arr[n - 1] - k - (arr[0] - k)); return minDiff;` |
| 443 | Smallest Range II | 910 | https://leetcode.com/problems/smallest-range-ii/ | Sort array. Iterate splitting point `i`. Elements 0 to i add k, i+1 to n-1 subtract k. Min = `min(nums[0]+k, nums[i+1]-k)`, Max = `max(nums[i]+k, nums[n-1]-k)`. Update min range. Check all add k or all subtract k cases. | Sorting allows splitting into two groups (±k). Compute range per split, minimize difference. | Sorting, Array Iteration | O(n log n) | O(1) | `Arrays.sort(nums); int n = nums.length, minRange = nums[n - 1] - nums[0]; for (int i = 0; i < n - 1; i++) { int minVal = Math.min(nums[0] + k, nums[i + 1] - k); int maxVal = Math.max(nums[i] + k, nums[n - 1] - k); minRange = Math.min(minRange, maxVal - minVal); } return minRange;` |
| 444 | Geek Collects the Balls | N/A | https://www.geeksforgeeks.org/geek-collects-the-balls/ | Two pointers on sorted arrays. Track sums (`sum1`, `sum2`). At common element, add `max(sum1, sum2) + value`. If `arr1[i] < arr2[j]`, add to `sum1`, else to `sum2`. After loop, add max of remaining sums. | Two pointers accumulate sums, maximize at common points by taking better path. | Two Pointers, Greedy | O(m + n) | O(1) | `int i = 0, j = 0; long sum1 = 0, sum2 = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] == arr2[j]) { sum1 += Math.max(sum1, sum2) + arr1[i]; sum2 = sum1; i++; j++; } else if (arr1[i] < arr2[j]) sum1 += arr1[i++]; else sum2 += arr2[j++]; } return Math.max(sum1, sum2);` |
| 445 | Length of the Longest Valid Substring | 1849 | https://leetcode.com/problems/length-of-the-longest-valid-substring/ | Sliding window with Set of forbidden strings. Expand right. For each `j`, check if any forbidden string ends at `j` by testing suffixes. If found, update left to `max(left, j - f.length() + 1)`. Track max length `j - left + 1`. | Check suffixes at right pointer. Update left to exclude forbidden strings. | Sliding Window, String Matching | O(n * L) | O(F) | `Set<String> set = new HashSet<>(forbidden); int maxLen = 0, left = 0; for (int j = 0; j < word.length(); j++) { for (int k = Math.max(left, j - maxForbiddenLen + 1); k <= j; k++) { String suffix = word.substring(k, j + 1); if (set.contains(suffix)) left = Math.max(left, k + 1); } maxLen = Math.max(maxLen, j - left + 1); } return maxLen;` |
| 446 | Length of the Longest Valid Substring (Parentheses) | N/A | https://www.geeksforgeeks.org/length-of-the-longest-valid-substring/ | Stack of indices. Push '(' index. For ')', pop. If stack empty, push ')' index. Else, compute length: `current_index - stack.peek()`. Track max length. Handle empty stack case after pop. | Stack tracks unmatched '('. Length from current ')' to last unmatched position. | Stack, String Iteration | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); stack.push(-1); int maxLen = 0; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == '(') stack.push(i); else { stack.pop(); if (stack.isEmpty()) stack.push(i); else maxLen = Math.max(maxLen, i - stack.peek()); } } return maxLen;` |
| 447 | Find Peak Element | 162 | https://leetcode.com/problems/find-peak-element/ | Binary search. If `nums[mid] > nums[mid+1]`, peak in [low, mid]. Else, peak in [mid+1, high]. Return mid when low == high. | Compare mid with right neighbor to halve search space. Peak guaranteed to exist. | Binary Search | O(log n) | O(1) | `int left = 0, right = nums.length - 1; while (left < right) { int mid = left + (right - left) / 2; if (nums[mid] > nums[mid + 1]) right = mid; else left = mid + 1; } return left;` |
| 448 | Find a Peak Element in a Given Array | N/A | https://www.geeksforgeeks.org/find-a-peak-in-a-given-array/ | Same as LC 162. Binary search. If `nums[mid] > nums[mid+1]`, peak in [low, mid]. Else, peak in [mid+1, high]. | Use binary search to find peak by comparing with right neighbor. | Binary Search | O(log n) | O(1) | `int left = 0, right = arr.length - 1; while (left < right) { int mid = left + (right - left) / 2; if (arr[mid] > arr[mid + 1]) right = mid; else left = mid + 1; } return left;` |
| 449 | Merge Sorted Array | 88 | https://leetcode.com/problems/merge-sorted-array/ | Three pointers: `p1` (end of nums1 valid part), `p2` (end of nums2), `p3` (end of nums1). Compare `nums1[p1]` and `nums2[p2]`, place larger at `nums1[p3]`. Handle remaining nums2. | Merge from end to avoid overwriting nums1’s valid elements. | Two Pointers, In-place | O(m + n) | O(1) | `int p1 = m - 1, p2 = n - 1, p3 = m + n - 1; while (p2 >= 0 && p1 >= 0) nums1[p3--] = nums1[p1] >= nums2[p2] ? nums1[p1--] : nums2[p2--]; while (p2 >= 0) nums1[p3--] = nums2[p2--];` |
| 450 | Remove Duplicates from Sorted List | 83 | https://leetcode.com/problems/remove-duplicates-from-sorted-list/ | Iterate with pointer `curr`. If `curr.val == curr.next.val`, skip next: `curr.next = curr.next.next`. Else, move `curr = curr.next`. | Skip duplicate nodes in-place by adjusting pointers. | Linked List Manipulation | O(n) | O(1) | `ListNode curr = head; while (curr != null && curr.next != null) { if (curr.val == curr.next.val) curr.next = curr.next.next; else curr = curr.next; } return head;` |
| 451 | Remove Duplicates from Sorted List II | 82 | https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ | Dummy node. Use `prev` and `curr`. If `curr.val` is duplicate, skip all duplicates. Link `prev.next` to node after duplicates. If no duplicates, move `prev = prev.next`. | Skip entire duplicate sequences using dummy node for edge cases. | Linked List Manipulation, Dummy Node | O(n) | O(1) | `ListNode dummy = new ListNode(0, head); ListNode prev = dummy, curr = head; while (curr != null) { if (curr.next != null && curr.val == curr.next.val) { while (curr.next != null && curr.val == curr.next.val) curr = curr.next; curr = curr.next; prev.next = curr; } else { prev = prev.next; curr = curr.next; } } return dummy.next;` |
| 452 | Partition List | 86 | https://leetcode.com/problems/partition-list/ | Two dummy nodes for `< x` and `>= x` lists. Iterate, append nodes to appropriate list. Connect `< x` list’s tail to `>= x` list’s head. | Separate into two lists, then concatenate. Dummy nodes simplify linking. | Linked List Manipulation, Dummy Nodes | O(n) | O(1) | `ListNode lessDummy = new ListNode(0), moreDummy = new ListNode(0); ListNode less = lessDummy, more = moreDummy; while (head != null) { if (head.val < x) { less.next = head; less = less.next; } else { more.next = head; more = more.next; } head = head.next; } more.next = null; less.next = moreDummy.next; return lessDummy.next;` |
| 453 | Rotate List | 61 | https://leetcode.com/problems/rotate-list/ | Find length. Compute `k = k % length`. If k=0, return head. Find (length - k - 1)-th node (new tail). Connect tail to head, set new tail’s next to null. | Adjust k modulo length, rewire pointers to form new head and tail. | Linked List Manipulation | O(n) | O(1) | `if (head == null || k == 0) return head; int len = 1; ListNode tail = head; while (tail.next != null) { len++; tail = tail.next; } k = k % len; if (k == 0) return head; ListNode newTail = head; for (int i = 0; i < len - k - 1; i++) newTail = newTail.next; ListNode newHead = newTail.next; tail.next = head; newTail.next = null; return newHead;` |
| 454 | Reverse Only Letters | 917 | https://leetcode.com/problems/reverse-only-letters/ | Two pointers, `left` and `right`. Move `left` until letter, `right` until letter. Swap if both are letters. Move inwards. | Skip non-letters, swap letters in-place using char array. | Two Pointers, String Manipulation | O(n) | O(n) | `char[] chars = s.toCharArray(); int left = 0, right = s.length() - 1; while (left < right) { while (left < right && !Character.isLetter(chars[left])) left++; while (left < right && !Character.isLetter(chars[right])) right--; if (left < right) { char temp = chars[left]; chars[left++] = chars[right]; chars[right--] = temp; } } return new String(chars);` |
| 455 | Long Pressed Name | 925 | https://leetcode.com/problems/long-pressed-name/ | Two pointers, `i` for name, `j` for typed. If `name[i] == typed[j]`, advance both. If `typed[j] == typed[j-1]`, skip (long press). Else, false. Check if `i` reaches name’s end. | Match chars, allow repeated chars in typed for long press. | Two Pointers, String Iteration | O(n + t) | O(1) | `int i = 0, j = 0; while (j < typed.length()) { if (i < name.length() && name.charAt(i) == typed.charAt(j)) { i++; j++; } else if (j > 0 && typed.charAt(j) == typed.charAt(j - 1)) j++; else return false; } return i == name.length();` |
| 456 | Missing Ranges | 163 | https://leetcode.com/problems/missing-ranges/ | Track `current = lower`. For each `nums[i]`, if `nums[i] > current`, add range `[current, nums[i]-1]`. Set `current = nums[i] + 1`. If `current <= upper`, add `[current, upper]`. Format ranges. | Track expected number, add missing ranges when gaps found. | Array Iteration, Range Management | O(n) | O(1) | `List<String> result = new ArrayList<>(); long current = lower; for (int i = 0; i <= nums.length; i++) { long next = i == nums.length ? upper + 1L : nums[i]; if (next > current) result.add(current == next - 1 ? String.valueOf(current) : current + "->" + (next - 1)); current = next + 1; } return result;` |
| 457 | Summary Ranges | 228 | https://leetcode.com/problems/summary-ranges/ | Iterate. Track range start. Advance while consecutive (`nums[i] == nums[i-1] + 1`). If range breaks, add “start” or “start->end”. Update start. | Identify consecutive ranges, format as single number or range. | Array Iteration, Range Management | O(n) | O(1) | `List<String> result = new ArrayList<>(); for (int i = 0; i < nums.length; i++) { int start = nums[i]; while (i + 1 < nums.length && nums[i + 1] == nums[i] + 1) i++; if (start == nums[i]) result.add(String.valueOf(start)); else result.add(start + "->" + nums[i]); } return result;` |
| 458 | Find Numbers with Even Number of Digits | 1295 | https://leetcode.com/problems/find-numbers-with-even-number-of-digits/ | Iterate array. Count digits for each number using `log10(n) + 1` or string length. Increment count if digit count is even. | Use math or string conversion to count digits, check parity. | Array Iteration, Digit Counting | O(n * log M) | O(1) | `int count = 0; for (int num : nums) { int digits = (int) Math.log10(num) + 1; if (digits % 2 == 0) count++; } return count;` |
| 459 | Shuffle the Array | 1470 | https://leetcode.com/problems/shuffle-the-array/ | Create result array. Fill alternately: `result[2*i] = nums[i]`, `result[2*i+1] = nums[i+n]`. | Interleave first and second halves using index mapping. | Array Manipulation | O(n) | O(n) | `int[] result = new int[2 * n]; for (int i = 0; i < n; i++) { result[2 * i] = nums[i]; result[2 * i + 1] = nums[i + n]; } return result;` |
| 460 | Unique Number of Occurrences | 1207 | https://leetcode.com/problems/unique-number-of-occurrences/ | Count frequencies with map. Add frequencies to set. Return `map.size() == set.size()`. | Frequencies unique if set of frequencies matches map size. | Hash Map, Set | O(n) | O(n) | `Map<Integer, Integer> freq = new HashMap<>(); for (int num : arr) freq.put(num, freq.getOrDefault(num, 0) + 1); Set<Integer> counts = new HashSet<>(freq.values()); return freq.size() == counts.size();` |
| 461 | Sort Characters By Frequency | 451 | https://leetcode.com/problems/sort-characters-by-frequency/ | Count frequencies with map. Use bucket sort: bucket[i] stores chars with freq i. Build string from highest to lowest freq. | Bucket sort by frequency avoids comparison sort for small alphabet. | Frequency Map, Bucket Sort | O(n + k) | O(k) | `Map<Character, Integer> freq = new HashMap<>(); for (char c : s.toCharArray()) freq.put(c, freq.getOrDefault(c, 0) + 1); List<Character>[] buckets = new List[s.length() + 1]; for (var entry : freq.entrySet()) { int f = entry.getValue(); if (buckets[f] == null) buckets[f] = new ArrayList<>(); buckets[f].add(entry.getKey()); } StringBuilder sb = new StringBuilder(); for (int i = buckets.length - 1; i >= 0; i--) if (buckets[i] != null) for (char c : buckets[i]) for (int j = 0; j < i; j++) sb.append(c); return sb.toString();` |
| 462 | Maximum Frequency Stack | 895 | https://leetcode.com/problems/maximum-frequency-stack/ | Map `val -> freq`, map `freq -> stack<val>`. Track `maxFreq`. Push: increment freq, add to `freqStack[freq]`, update `maxFreq`. Pop: remove from `freqStack[maxFreq]`, update freq and `maxFreq`. | Track frequencies and stacks per frequency for LIFO at max freq. | Hash Map, Stack | O(1) | O(n) | `Map<Integer, Integer> valToFreq = new HashMap<>(); Map<Integer, Stack<Integer>> freqToStack = new HashMap<>(); int maxFreq = 0; public void push(int val) { int freq = valToFreq.merge(val, 1, Integer::sum); freqToStack.computeIfAbsent(freq, k -> new Stack<>()).push(val); maxFreq = Math.max(maxFreq, freq); } public int pop() { int val = freqToStack.get(maxFreq).pop(); valToFreq.merge(val, -1, Integer::sum); if (freqToStack.get(maxFreq).isEmpty()) maxFreq--; return val; }` |
| 463 | Fruit Into Baskets | 904 | https://leetcode.com/problems/fruit-into-baskets/ | Sliding window with map for fruit counts. Expand right. If distinct types > 2, shrink left until <= 2. Track max length. | Maintain at most two fruit types in window using frequency map. | Sliding Window, Frequency Map | O(n) | O(1) | `Map<Integer, Integer> map = new HashMap<>(); int maxLen = 0, left = 0; for (int right = 0; right < fruits.length; right++) { map.merge(fruits[right], 1, Integer::sum); while (map.size() > 2) { map.merge(fruits[left], -1, Integer::sum); if (map.get(fruits[left]) == 0) map.remove(fruits[left]); left++; } maxLen = Math.max(maxLen, right - left + 1); } return maxLen;` |
| 464 | Kth Missing Positive Number | 1539 | https://leetcode.com/problems/kth-missing-positive-number/ | Binary search on index. Missing before `arr[i]` is `arr[i] - i - 1`. Find `i` where missing < k and missing at `i+1` >= k. Kth missing is `arr[i] + k - (arr[i] - i - 1)`. | Binary search finds index where kth missing lies based on missing count. | Binary Search | O(log n) | O(1) | `int left = 0, right = arr.length - 1; while (left <= right) { int mid = left + (right - left) / 2; int missing = arr[mid] - mid - 1; if (missing < k) left = mid + 1; else right = mid - 1; } return k + left;` |
| 465 | Toeplitz Matrix | 766 | https://leetcode.com/problems/toeplitz-matrix/ | Check diagonals. For each cell `(i,j)` (except last row/col), compare `matrix[i][j]` with `matrix[i+1][j+1]`. Return false if mismatch. | Compare each cell with its bottom-right diagonal neighbor. | Matrix Traversal | O(m * n) | O(1) | `for (int i = 0; i < matrix.length - 1; i++) for (int j = 0; j < matrix[0].length - 1; j++) if (matrix[i][j] != matrix[i + 1][j + 1]) return false; return true;` |
| 466 | Available Captures for Rook | 999 | https://leetcode.com/problems/available-captures-for-rook/ | Find rook. Check four directions. Stop at 'p' (count), 'B', or edge. Sum captures. | Traverse directions from rook, count pawns before blockers. | Matrix Traversal | O(m * n) | O(1) | `int captures = 0; for (int i = 0; i < board.length; i++) for (int j = 0; j < board[0].length; j++) if (board[i][j] == 'R') { for (int[] dir : new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) { int r = i, c = j; while (r >= 0 && r < board.length && c >= 0 && c < board[0].length) { if (board[r][c] == 'p') { captures++; break; } if (board[r][c] == 'B') break; r += dir[0]; c += dir[1]; } } return captures; } return captures;` |
| 467 | Minimum Domino Rotations For Equal Row | 1007 | https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/ | Try targets `tops[0]` and `bottoms[0]`. For each, count rotations for top/bottom to all target. If any domino lacks target, return -1. Take min of valid counts. | Only first domino’s values are possible targets. Count rotations per target. | Array Iteration, Counting | O(n) | O(1) | `int minRotations = Integer.MAX_VALUE; for (int target : new int[]{tops[0], bottoms[0]}) { int topRot = 0, botRot = 0; boolean possible = true; for (int i = 0; i < tops.length; i++) { if (tops[i] != target && bottoms[i] != target) { possible = false; break; } if (tops[i] != target) topRot++; if (bottoms[i] != target) botRot++; } if (possible) minRotations = Math.min(minRotations, Math.min(topRot, botRot)); } return minRotations == Integer.MAX_VALUE ? -1 : minRotations;` |
| 468 | Number of Equivalent Domino Pairs | 1128 | https://leetcode.com/problems/number-of-equivalent-domino-pairs/ | Normalize dominoes to `(min(a,b), max(a,b))`. Count frequencies with map. For freq `c`, add `c*(c-1)/2` pairs. Sum all combinations. | Normalize to handle rotations, sum combinations for each frequency. | Hash Map, Counting | O(n) | O(n) | `Map<String, Integer> map = new HashMap<>(); int pairs = 0; for (int[] domino : dominoes) { int a = Math.min(domino[0], domino[1]), b = Math.max(domino[0], domino[1]); String key = a + "," + b; int count = map.merge(key, 1, Integer::sum); pairs += count - 1; } return pairs;` |
| 469 | Custom Sort String | 791 | https://leetcode.com/problems/custom-sort-string/ | Count `s` frequencies. Append chars in `order`’s sequence based on freq. Append remaining chars. | Follow `order` for chars in `s`, handle extras at end. | Frequency Map, String Manipulation | O(S + Order) | O(1) | `int[] freq = new int[26]; for (char c : s.toCharArray()) freq[c - 'a']++; StringBuilder sb = new StringBuilder(); for (char c : order.toCharArray()) while (freq[c - 'a']-- > 0) sb.append(c); for (int i = 0; i < 26; i++) while (freq[i]-- > 0) sb.append((char) (i + 'a')); return sb.toString();` |
| 470 | Goat Latin | 824 | https://leetcode.com/problems/goat-latin/ | Split words. For each: if vowel start, append “ma” + i ‘a’s. If consonant, move first char to end, append “ma” + i ‘a’s. Join with spaces. | Process each word with vowel check, append suffix based on index. | String Manipulation | O(N * L) | O(N * L) | `StringBuilder sb = new StringBuilder(); String[] words = sentence.split(" "); for (int i = 0; i < words.length; i++) { String word = words[i]; if ("aeiouAEIOU".indexOf(word.charAt(0)) >= 0) sb.append(word).append("ma"); else sb.append(word.substring(1)).append(word.charAt(0)).append("ma"); for (int j = 0; j <= i; j++) sb.append('a'); if (i < words.length - 1) sb.append(' '); } return sb.toString();` |
| 471 | Hand of Straights | 846 | https://leetcode.com/problems/hand-of-straights/ | If `hand.length % groupSize != 0`, return false. Count frequencies. Use min-heap for unique values. Form straights from min value, decrement frequencies. | Min-heap ensures smallest card starts straight, verify consecutive values. | Frequency Map, Priority Queue | O(n log n) | O(n) | `if (hand.length % groupSize != 0) return false; Map<Integer, Integer> freq = new TreeMap<>(); for (int card : hand) freq.merge(card, 1, Integer::sum); PriorityQueue<Integer> pq = new PriorityQueue<>(freq.keySet()); while (!pq.isEmpty()) { int start = pq.peek(); for (int i = 0; i < groupSize; i++) { int curr = start + i; if (!freq.containsKey(curr)) return false; freq.merge(curr, -1, Integer::sum); if (freq.get(curr) == 0) freq.remove(curr); } while (!pq.isEmpty() && !freq.containsKey(pq.peek())) pq.poll(); } return true;` |
| 472 | Push Dominoes | 838 | https://leetcode.com/problems/push-dominoes/ | Simulate forces. Initialize array with dominoes state. For each ‘R’, add +1 force to right until ‘L’ or end. For ‘L’, add -1 force to left. Net force at ‘.’ determines ‘R’, ‘L’, or ‘.’. | Compute forces from ‘R’ and ‘L’, net force decides final state. | Array Manipulation, Simulation | O(n) | O(n) | `char[] result = dominoes.toCharArray(); int[] forces = new int[dominoes.length()]; int force = 0; for (int i = 0; i < dominoes.length(); i++) { if (dominoes.charAt(i) == 'R') force = dominoes.length(); else if (dominoes.charAt(i) == 'L') force = 0; else force = Math.max(0, force - 1); forces[i] += force; } force = 0; for (int i = dominoes.length() - 1; i >= 0; i--) { if (dominoes.charAt(i) == 'L') force = dominoes.length(); else if (dominoes.charAt(i) == 'R') force = 0; else force = Math.max(0, force - 1); forces[i] -= force; } for (int i = 0; i < dominoes.length(); i++) result[i] = forces[i] > 0 ? 'R' : forces[i] < 0 ? 'L' : '.'; return new String(result);` |
| 473 | Minimum Add to Make Parentheses Valid | 921 | https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ | Track balance. For ‘(’, increment. For ‘)’, decrement. If balance < 0, add 1, reset to 0. Final balance is extra ‘)’ needed. Total = balance + additions. | Balance tracks unmatched ‘(’. Negative balance requires ‘(’ additions. | String Iteration, Counter | O(n) | O(1) | `int balance = 0, additions = 0; for (char c : s.toCharArray()) { if (c == '(') balance++; else { balance--; if (balance < 0) { additions++; balance = 0; } } } return balance + additions;` |
| 474 | Remove All Adjacent Duplicates In String | 1047 | https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/ | Use StringBuilder as stack. Iterate. If current equals last char, delete last. Else append. | StringBuilder simulates stack, removing duplicates in-place. | Stack, String Manipulation | O(n) | O(n) | `StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) sb.deleteCharAt(sb.length() - 1); else sb.append(c); } return sb.toString();` |
| 475 | Remove All Adjacent Duplicates in String II | 1209 | https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/ | Stack of `(char, count)`. If current equals top char, increment count. If count == k, pop. Else push `(char, 1)`. Build string from stack. | Stack tracks char counts, pop when k duplicates found. | Stack, String Manipulation | O(n) | O(n) | `Stack<int[]> stack = new Stack<>(); for (char c : s.toCharArray()) { if (!stack.isEmpty() && stack.peek()[0] == c) { stack.peek()[1]++; if (stack.peek()[1] == k) stack.pop(); } else stack.push(new int[]{c, 1}); } StringBuilder sb = new StringBuilder(); for (int[] pair : stack) for (int i = 0; i < pair[1]; i++) sb.append((char) pair[0]); return sb.toString();` |
| 476 | Find K Closest Elements | 658 | https://leetcode.com/problems/find-k-closest-elements/ | Binary search for start of k-element window. For window [mid, mid+k-1], if `x - nums[mid] > nums[mid+k] - x`, shift right. Else shift left. Return subarray. | Binary search optimizes window selection by comparing distances at boundaries. | Binary Search, Two Pointers | O(log n + k) | O(1) | `int left = 0, right = arr.length - k; while (left < right) { int mid = left + (right - left) / 2; if (x - arr[mid] > arr[mid + k] - x) left = mid + 1; else right = mid; } List<Integer> result = new ArrayList<>(); for (int i = left; i < left + k; i++) result.add(arr[i]); return result;` |
| 477 | Buildings With an Ocean View | 1762 | https://leetcode.com/problems/buildings-with-ocean-view/ | Iterate right to left. Track max height. If current height > max, add index to result. Update max. Reverse result or add to front. | Right-to-left ensures buildings taller than all to right have view. | Array Iteration | O(n) | O(n) | `List<Integer> result = new ArrayList<>(); int maxHeight = -1; for (int i = heights.length - 1; i >= 0; i--) { if (heights[i] > maxHeight) { result.add(0, i); maxHeight = heights[i]; } } return result.stream().mapToInt(i -> i).toArray();` |
| 478 | Merge Strings Alternately | 1768 | https://leetcode.com/problems/merge-strings-alternately/ | Iterate up to min length, append chars alternately. Append remaining chars from longer string. | Alternate chars, handle unequal lengths by appending rest. | String Manipulation, Two Pointers | O(m + n) | O(m + n) | `StringBuilder sb = new StringBuilder(); int i = 0; while (i < word1.length() && i < word2.length()) { sb.append(word1.charAt(i)).append(word2.charAt(i)); i++; } sb.append(word1.substring(i)).append(word2.substring(i)); return sb.toString();` |
| 479 | Largest Number | 179 | https://leetcode.com/problems/largest-number/ | Convert to strings. Sort with comparator: `s1 + s2 > s2 + s1`. Concatenate sorted strings. Handle all zeros case. | Custom sort maximizes concatenated value, check for leading zeros. | Sorting, Custom Comparator | O(n log n * L) | O(n * L) | `String[] strs = new String[nums.length]; for (int i = 0; i < nums.length; i++) strs[i] = String.valueOf(nums[i]); Arrays.sort(strs, (a, b) -> (b + a).compareTo(a + b)); if (strs[0].equals("0")) return "0"; StringBuilder sb = new StringBuilder(); for (String s : strs) sb.append(s); return sb.toString();` |
| 480 | Repeated DNA Sequences | 187 | https://leetcode.com/problems/repeated-dna-sequences/ | Sliding window of size 10. Track seen substrings in set. If seen again, add to result set. Return result as list. | Use sets to track and collect repeated 10-char sequences. | Hash Set, Sliding Window | O(n) | O(n) | `Set<String> seen = new HashSet<>(), result = new HashSet<>(); for (int i = 0; i <= s.length() - 10; i++) { String seq = s.substring(i, i + 10); if (!seen.add(seq)) result.add(seq); } return new ArrayList<>(result);` |
| 481 | Single Element in a Sorted Array | 540 | https://leetcode.com/problems/single-element-in-a-sorted-array/ | Binary search. If `nums[mid]` pairs with `nums[mid+1]` and mid is even, single is right. If pairs with `nums[mid-1]` and mid is odd, single is right. Else single at mid. | Use pair property and index parity to find single element. | Binary Search | O(log n) | O(1) | `int left = 0, right = nums.length - 1; while (left < right) { int mid = left + (right - left) / 2; if (mid % 2 == 1) mid--; if (nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; } return nums[left];` |
| 482 | Find the Most Common Response | 3167 | https://leetcode.com/problems/find-the-most-frequent-response/ | Count frequencies with map. Track max frequency and lexicographically smallest string with that frequency. | Map counts frequencies, iterate to find smallest max-freq string. | Hash Map, String Comparison | O(n * L) | O(M * L) | `Map<String, Integer> freq = new HashMap<>(); int maxFreq = 0; String result = responses[0]; for (String s : responses) { int count = freq.merge(s, 1, Integer::sum); if (count > maxFreq || (count == maxFreq && s.compareTo(result) < 0)) { maxFreq = count; result = s; } } return result;` |
| 483 | Apply Substitutions | 3170 | https://leetcode.com/problems/apply-substitutions/ | Assume substitutions are given as (index, new_string) pairs. Sort by index descending. Iterate from right to left, replace substring at index with new string. Build result string. | Process substitutions right-to-left to avoid index shifts. | String Manipulation, Simulation | O(n + S) | O(n + S) | `StringBuilder sb = new StringBuilder(s); List<int[]> subs = new ArrayList<>(); for (int i = 0; i < indices.length; i++) subs.add(new int[]{indices[i], i}); subs.sort((a, b) -> b[0] - a[0]); for (int[] sub : subs) { int idx = sub[0], i = sub[1]; sb.replace(idx, idx + target[i].length(), replacements[i]); } return sb.toString();` |
| 484 | Calculate Score After Performing Instructions | 3166 | https://leetcode.com/problems/calculate-score-after-performing-instructions/ | Assume instructions are (index, value) pairs to update array. Score is sum of array after updates. Iterate instructions, apply updates, compute final sum. | Simulate updates, compute sum as score. | Array Manipulation, Simulation | O(n + q) | O(n) | `long[] arr = new long[n]; for (int[] inst : instructions) arr[inst[0]] = inst[1]; long score = 0; for (long val : arr) score += val; return score;` |
| 485 | Count Cells in Overlapping Horizontal and Vertical Substrings | 3164 | https://leetcode.com/problems/count-cells-in-overlapping-horizontal-and-vertical-substrings/ | Parse string for ‘H’ (horizontal) and ‘V’ (vertical) segments at indices. For each cell (i,j), count if covered by both H and V segment. Use sets for H and V indices. | Check each cell for coverage by both segment types. | Geometry, Set | O(n * m) | O(n + m) | `Set<Integer> hRows = new HashSet<>(), vCols = new HashSet<>(); for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) { if (grid[i][j] == 'H') hRows.add(i); if (grid[i][j] == 'V') vCols.add(j); } int count = 0; for (int i = 0; i < grid.length; i++) for (int j = 0; j < grid[0].length; j++) if (hRows.contains(i) && vCols.contains(j)) count++; return count;` |
| 486 | Maximize Subarrays After Removing One Conflicting Pair | 3163 | https://leetcode.com/problems/maximize-subarrays-after-removing-one-conflicting-pair/ | Assume conflicting pair is adjacent equal elements. Count valid subarrays (no adjacent equals) initially. For each adjacent equal pair, remove one, recompute valid subarrays, track max. | Simulate removal of each conflicting pair, count valid subarrays. | Array Iteration, Simulation | O(n^2) | O(n) | `int maxSubarrays = 0; for (int i = 0; i < nums.length; i++) { int[] temp = new int[nums.length - 1]; int k = 0; for (int j = 0; j < nums.length; j++) if (j != i) temp[k++] = nums[j]; int count = 1; for (int j = 1; j < temp.length; j++) if (temp[j] != temp[j - 1]) count++; maxSubarrays = Math.max(maxSubarrays, count); } return maxSubarrays;` |
| 487 | Find the Maximum Length of a Good Subsequence I | 3020 | https://leetcode.com/problems/find-the-maximum-length-of-a-good-subsequence-i/ | Assume “good” means at most k equal adjacent elements in subsequence. DP: `dp[i][k_used][prev]` = max length at index i, k_used equal pairs, prev element. Transitions: include nums[i] if k allows, or skip. | DP tracks index, used k, and previous element to enforce adjacency rule. | Dynamic Programming | O(n * k * n) | O(n * k * n) | `int[][][] dp = new int[nums.length][k + 1][nums.length + 1]; for (int[][] arr : dp) for (int[] row : arr) Arrays.fill(row, -1); return dfs(0, k, nums.length, nums, dp); int dfs(int i, int k, int prev, int[] nums, int[][][] dp) { if (i == nums.length) return 0; if (dp[i][k][prev] != -1) return dp[i][k][prev]; int maxLen = dfs(i + 1, k, prev, nums, dp); if (prev == nums.length || k > 0 || nums[i] != nums[prev]) maxLen = Math.max(maxLen, 1 + dfs(i + 1, k - (prev != nums.length && nums[i] == nums[prev] ? 1 : 0), i, nums, dp)); return dp[i][k][prev] = maxLen; }` |
| 488 | Find the Maximum Length of a Good Subsequence II | 3022 | https://leetcode.com/problems/find-the-maximum-length-of-a-good-subsequence-ii/ | Similar to 487, but likely stricter “good” condition (e.g., at most k non-increasing pairs). DP: `dp[i][k_used][prev]` = max length at i, k_used non-increasing pairs, prev element. Optimize with map for prev values. | DP with map to handle larger constraints, track non-increasing pairs. | Dynamic Programming | O(n * k * m) | O(n * k * m) | `Map<Integer, Integer>[][] dp = new Map[nums.length][k + 1]; return dfs(0, k, Integer.MAX_VALUE, nums, dp); int dfs(int i, int k, int prev, int[] nums, Map<Integer, Integer>[][] dp) { if (i == nums.length) return 0; if (dp[i][k] != null && dp[i][k].containsKey(prev)) return dp[i][k].get(prev); int maxLen = dfs(i + 1, k, prev, nums, dp); if (k > 0 || nums[i] <= prev) maxLen = Math.max(maxLen, 1 + dfs(i + 1, k - (nums[i] > prev ? 1 : 0), nums[i], nums, dp)); if (dp[i][k] == null) dp[i][k] = new HashMap<>(); dp[i][k].put(prev, maxLen); return maxLen; }` |
| 489 | Maximum Number of Tasks You Can Assign | 2071 | https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/ | Binary search on k tasks. Check: sort tasks and workers. Greedily assign k hardest tasks to k strongest workers. Use pills if worker strength < task difficulty. Return max k. | Binary search on k, greedy assignment with pill optimization. | Binary Search, Greedy | O(n log n + k log k) | O(n) | `Arrays.sort(tasks); Arrays.sort(workers); int left = 0, right = Math.min(tasks.length, workers.length); while (left <= right) { int mid = left + (right - left) / 2; PriorityQueue<Integer> pq = new PriorityQueue<>(); int pillsUsed = 0, j = workers.length - 1; boolean possible = true; for (int i = mid - 1; i >= 0 && j >= 0; i--) { if (workers[j] >= tasks[i]) j--; else if (pillsUsed < pills && workers[j] + strength >= tasks[i]) { pillsUsed++; j--; } else { possible = false; break; } } if (possible) left = mid + 1; else right = mid - 1; } return right;` |
| 490 | Number of Adjacent Elements With the Same Color | 2672 | https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/ | Track array and count of same-color adjacent pairs. For query (i, c), adjust count: check if (i-1,i) and (i,i+1) were same-color before, update array[i], then check again. | Update count by checking adjacent pairs before and after color change. | Array Manipulation, Simulation | O(n) | O(n) | `int[] arr = new int[n]; int count = 0; int[] result = new int[queries.length]; for (int q = 0; q < queries.length; q++) { int i = queries[q][0], c = queries[q][1]; if (i > 0 && arr[i] == arr[i - 1] && arr[i] != 0) count--; if (i < n - 1 && arr[i] == arr[i + 1] && arr[i] != 0) count--; arr[i] = c; if (i > 0 && arr[i] == arr[i - 1]) count++; if (i < n - 1 && arr[i] == arr[i + 1]) count++; result[q] = count; } return result;` |
| 491 | Count the Hidden Sequences | 2145 | https://leetcode.com/problems/count-the-hidden-sequences/ | Compute prefix sums assuming h[0] = 0. Find min/max of prefix sums. Valid start values: `lower <= start + min <= start + max <= upper`. Count integers in range `[lower - min, upper - max]`. | Prefix sums give relative sequence. Valid start values constrained by range. | Array Iteration, Prefix Sum | O(n) | O(1) | `long curr = 0, minVal = 0, maxVal = 0; for (int diff : differences) { curr += diff; minVal = Math.min(minVal, curr); maxVal = Math.max(maxVal, curr); } long left = lower - minVal, right = upper - maxVal; return right >= left ? (int) (right - left + 1) : 0;` |
| 492 | Amount of New Area Painted Each Day | 2158 | https://leetcode.com/problems/amount-of-new-area-painted-each-day/ | Use array to track painted status. For each job [s,e), compute painted area by counting painted points. New area = (e-s) - painted count. Mark [s,e) as painted. | Track painted points, compute new area as total minus already painted. | Array Manipulation, Simulation | O(n * C) | O(C) | `int[] painted = new int[10001]; int[] result = new int[paint.length]; for (int i = 0; i < paint.length; i++) { int s = paint[i][0], e = paint[i][1], newArea = 0; for (int j = s; j < e; j++) if (painted[j] == 0) newArea++; result[i] = newArea; for (int j = s; j < e; j++) painted[j] = 1; } return result;` |
| 493 | Maximize Amount After Two Days of Conversions | 3173 | https://leetcode.com/problems/maximize-amount-after-two-days-of-conversions/ | Assume conversions are doubling or halving each element. DP: `dp[i][state]` = max amount at index i, state (0: no op, 1: one op, 2: two ops). Try double or halve if state allows. | DP tracks conversion state, maximize sum after two operations. | Dynamic Programming | O(n) | O(n) | `double[][] dp = new double[nums.length][3]; for (double[] row : dp) Arrays.fill(row, -1); return dfs(0, 0, nums, dp); double dfs(int i, int state, int[] nums, double[][] dp) { if (i == nums.length) return 0; if (dp[i][state] != -1) return dp[i][state]; double max = dfs(i + 1, state, nums, dp) + nums[i]; if (state < 2) { max = Math.max(max, dfs(i + 1, state + 1, nums, dp) + nums[i] * 2); max = Math.max(max, dfs(i + 1, state + 1, nums, dp) + nums[i] / 2); } return dp[i][state] = max; }` |
| 494 | Find the Count of Monotonic Pairs I | 2857 | https://leetcode.com/problems/find-the-count-of-monotonic-pairs-i/ | Count pairs (i,j) where i < j and `nums[i] <= nums[j]`. Nested loops to check all pairs, increment count if condition holds. | Brute force checks all valid pairs for monotonicity. | Array Iteration, Brute Force | O(n^2) | O(1) | `int count = 0; for (int i = 0; i < nums.length; i++) for (int j = i + 1; j < nums.length; j++) if (nums[i] <= nums[j]) count++; return count;` |
| 495 | Block Placement Queries | 3171 | https://leetcode.com/problems/block-placement-queries/ | Use TreeMap to track free intervals [start, end]. For query [p, p+s), find interval containing p. If size >= s, return true. On placement, split interval, update TreeMap. | TreeMap maintains free intervals, check and update for queries. | TreeMap, Interval Management | O(q log n) | O(n) | `TreeMap<Integer, Integer> free = new TreeMap<>(); free.put(0, n); boolean[] result = new boolean[queries.length]; for (int i = 0; i < queries.length; i++) { int p = queries[i][0], s = queries[i][1]; Integer start = free.floorKey(p); if (start != null && free.get(start) >= p + s && p >= start) { result[i] = true; int end = free.get(start); free.remove(start); if (p > start) free.put(start, p); if (p + s < end) free.put(p + s, end); } } return result;` |
| 496 | Missing Element in Sorted Array | 1060 | https://leetcode.com/problems/missing-element-in-sorted-array/ | Binary search. Missing before `nums[i]` is `nums[i] - nums[0] - i`. Find `i` where missing < k. Kth missing is `nums[0] + k + i`. | Binary search locates index for kth missing using missing count. | Binary Search | O(log n) | O(1) | `int left = 0, right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; int missing = nums[mid] - nums[0] - mid; if (missing < k) left = mid + 1; else right = mid - 1; } return nums[0] + k + left;` |
| 497 | Wiggle Sort II | 324 | https://leetcode.com/problems/wiggle-sort-ii/ | Sort array. Interleave larger half (reversed) with smaller half (reversed) into result. Copy back to nums. | Interleave sorted halves to ensure wiggle property. | Sorting, Array Manipulation | O(n log n) | O(n) | `int[] temp = nums.clone(); Arrays.sort(temp); int n = nums.length, mid = (n - 1) / 2, end = n - 1; for (int i = 0; i < n; i++) nums[i] = (i % 2 == 0) ? temp[mid--] : temp[end--];` |
| 498 | Minimum Operations to Make Array Values Equal to K | 3174 | https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/ | Assume operations are increment/decrement by 1. Compute `abs(nums[i] - k)` for each element. Sum is min operations. | Sum absolute differences to target value k. | Array Iteration | O(n) | O(1) | `long operations = 0; for (int num : nums) operations += Math.abs(num - k); return operations;` |
| 499 | Exclusive Time of Functions | 636 | https://leetcode.com/problems/exclusive-time-of-functions/ | Stack of function IDs. On “start”, push ID, record start time. On “end”, pop, compute duration, adjust parent’s time if stack not empty. Track prev time. | Stack tracks active functions, adjust parent time on pop. | Stack, String Parsing | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int[] result = new int[n]; int prevTime = 0; for (String log : logs) { String[] parts = log.split(":"); int id = Integer.parseInt(parts[0]), time = Integer.parseInt(parts[2]); if (parts[1].equals("start")) { if (!stack.isEmpty()) result[stack.peek()] += time - prevTime; stack.push(id); prevTime = time; } else { result[stack.pop()] += time - prevTime + 1; prevTime = time + 1; } } return result;` |
| 500 | Validate IP Address | 468 | https://leetcode.com/problems/validate-ip-address/ | Check for ‘.’ (IPv4) or ‘:’ (IPv6). IPv4: 4 parts, each 0-255, no leading zeros. IPv6: 8 parts, each 1-4 hex digits. Validate format and ranges. | Split and validate parts based on IPv4 or IPv6 rules. | String Parsing | O(L) | O(L) | `if (IP.contains(".")) { String[] parts = IP.split("\\."); if (parts.length != 4) return "Neither"; for (String p : parts) { if (p.length() == 0 || p.length() > 3 || (p.charAt(0) == '0' && p.length() > 1)) return "Neither"; try { int val = Integer.parseInt(p); if (val < 0 || val > 255) return "Neither"; } catch (NumberFormatException e) { return "Neither"; } } return "IPv4"; } else if (IP.contains(":")) { String[] parts = IP.split(":"); if (parts.length != 8) return "Neither"; for (String p : parts) { if (p.length() == 0 || p.length() > 4) return "Neither"; for (char c : p.toCharArray()) if (!Character.isDigit(c) && (c < 'a' || c > 'f') && (c < 'A' || c > 'F')) return "Neither"; } return "IPv6"; } return "Neither";` |



| Sr No | Problem Name | Problem No | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|-------|--------------|------------|------|-----------------|-------|---------|------------------|------------------|-----------------------------|
| 501 | Diagonal Traverse II | 1424 | [https://leetcode.com/problems/diagonal-traverse-ii/](https://leetcode.com/problems/diagonal-traverse-ii/) | Traverse jagged matrix diagonally. Elements on same diagonal have same `i + j`. Use a map `sum -> list of elements`. Iterate matrix, add to list for key `i + j`. Collect elements in reverse order within each sum. | Group by row + col sum. Reverse elements per sum for diagonal order. | Hash Map, Matrix Traversal | O(N) where N is total elements | O(N) | `map.computeIfAbsent(i + j, k -> new ArrayList<>()).add(nums[i][j]);` |
| 502 | Minimum Interval to Include Each Query | 1851 | [https://leetcode.com/problems/minimum-interval-to-include-each-query/](https://leetcode.com/problems/minimum-interval-to-include-each-query/) | Sort intervals by start, queries by value. Use min-heap for intervals ending >= query (priority = size). Add intervals starting <= query to heap, remove those ending < query. Heap top is min size. | Sort and use min-heap for active intervals. | Sorting, Priority Queue, Intervals | O(N log N + Q log Q) where N is intervals, Q is queries | O(N + Q) | `pq.offer(intervals[j++]); while (!pq.isEmpty() && pq.peek()[1] < q[0]) pq.poll();` |
| 503 | Product of Two Run-Length Encoded Arrays | 1868 | [https://leetcode.com/problems/product-of-two-run-length-encoded-arrays/](https://leetcode.com/problems/product-of-two-run-length-encoded-arrays/) | Use two pointers on RLE arrays. Compute product `val1 * val2`, length `min(len1, len2)`. Add to result. Decrement lengths, advance pointer if length reaches 0. | Two pointers align RLE elements by min length. | Two Pointers, Array Iteration | O(min(M, N)) where M, N are RLE array lengths | O(min(M, N)) | `result.add(new int[]{arr1[i][0] * arr2[j][0], Math.min(arr1[i][1], arr2[j][1])});` |
| 504 | Cutting Ribbons | 1891 | [https://leetcode.com/problems/cutting-ribbons/](https://leetcode.com/problems/cutting-ribbons/) | Binary search on length [1, max_ribbon_length]. Check if sum of `floor(ribbon_length / mid)` >= k. If yes, try larger length; else, smaller. | Binary search for max length with check function. | Binary Search, Array Iteration | O(N log M) where N is ribbons, M is max length | O(1) | `for (int len : ribbons) count += len / mid; if (count >= k) left = mid + 1;` |
| 505 | Merge Triplets to Form Target Triplet | 1899 | [https://leetcode.com/problems/merge-triplets-to-form-target-triplet/](https://leetcode.com/problems/merge-triplets-to-form-target-triplet/) | Iterate triplets. If triplet `[a, b, c]` has `a <= target[0]`, `b <= target[1]`, `c <= target[2]`, track max of each component. Check if maxes equal target. | Use only valid triplets, track max components. | Array Iteration, Greedy | O(N) where N is triplets | O(1) | `if (triplet[0] <= target[0] && triplet[1] <= target[1] && triplet[2] <= target[2]) max[0] = Math.max(max[0], triplet[0]);` |
| 506 | Minimum Operations to Write the Letter Y on a Grid | 3037 | [https://leetcode.com/problems/minimum-operations-to-write-the-letter-y-on-a-grid/](https://leetcode.com/problems/minimum-operations-to-write-the-letter-y-on-a-grid/) | Identify 'Y' cells (diagonals meeting at center). Count digit frequencies in 'Y' and non-'Y'. For each distinct digit pair (i, j), compute operations: (total 'Y' - freq i) + (total non-'Y' - freq j). Minimize. | Brute force digit pairs for min operations. | Matrix Traversal, Counting, Brute Force | O(m*n + D^2) where m*n is grid size, D is digits (10) | O(D) | `if (i == j && i <= n/2 || i + j == n-1 && i <= n/2 || i == n/2 && j == n/2) yFreq[grid[i][j]]++;` |
| 507 | Split Array Largest Sum | 410 | [https://leetcode.com/problems/split-array-largest-sum/](https://leetcode.com/problems/split-array-largest-sum/) | Binary search on sum [max_element, total_sum]. Check if array can split into <= k subarrays with max sum `mid`. Greedy split: start new subarray when sum > `mid`. Find min `mid`. | Binary search with greedy split check. | Binary Search, Greedy | O(N log S) where N is array length, S is total sum | O(1) | `if (currSum + num > mid) { count++; currSum = num; } else currSum += num;` |
| 508 | The Skyline Problem | 218 | [https://leetcode.com/problems/the-skyline-problem/](https://leetcode.com/problems/the-skyline-problem/) | Sweep line: events at x-coords (start: +height, end: -height). Sort events. Use max-heap for active heights. Add/remove heights; if max height changes, add key point (x, new_max_height). | Sweep line with max-heap for height changes. | Sweep Line, Priority Queue, Geometry | O(N log N) where N is buildings | O(N) | `if (event[1] > 0) pq.offer(event[1]); else pq.remove(-event[1]); if (pq.peek() != result.get(result.size() - 1)[1]) result.add(new int[]{event[0], pq.peek()});` |
| 509 | Special Binary String | 761 | [https://leetcode.com/problems/special-binary-string/](https://leetcode.com/problems/special-binary-string/) | Recursively decompose into special substrings (balanced, prefixes balanced). Solve each substring, sort in descending order, concatenate. Base case: single character or empty. | Recursive decomposition, sort substrings descending. | Recursion, String Manipulation | O(N^2) worst case | O(N) | `count += s.charAt(i) == '1' ? 1 : -1; if (count == 0) subStrings.add('1' + makeLargestSpecial(s.substring(start + 1, i)) + '0');` |
| 510 | Expression Add Operators | 282 | [https://leetcode.com/problems/expression-add-operators/](https://leetcode.com/problems/expression-add-operators/) | Backtrack: try +, -, * or concatenate digits at each index. Track current value and last operand for multiplication precedence. Base case: end of string, check if value == target. | Backtrack with last operand for * precedence. | Backtracking, Recursion, String Manipulation | O(4^N) where N is string length | O(N) | `backtrack(num, target, i + 1, expr + "+" + currStr, value + curr, curr, result);` |
| 511 | Add Strings | 415 | [https://leetcode.com/problems/add-strings/](https://leetcode.com/problems/add-strings/) | Simulate column addition right to left. Use two pointers. Sum digits + carry, append result digit, update carry. Reverse final string. | Manual addition with carry handling. | String Manipulation, Arithmetic | O(max(L1, L2)) where L1, L2 are string lengths | O(max(L1, L2)) | `sum += carry; if (i >= 0) sum += num1.charAt(i--) - '0'; result.append(sum % 10);` |
| 512 | Ransom Note | 383 | [https://leetcode.com/problems/ransom-note/](https://leetcode.com/problems/ransom-note/) | Count magazine character frequencies. Iterate note, decrement counts. If count < 0, return false. | Frequency array for character counts. | Frequency Map, String Iteration | O(M + N) where M is magazine, N is note length | O(1) | `for (char c : ransomNote.toCharArray()) if (--freq[c - 'a'] < 0) return false;` |
| 513 | First Unique Number | 1429 | [https://leetcode.com/problems/first-unique-number/](https://leetcode.com/problems/first-unique-number/) | Use HashMap for `num -> freq` and DLL for unique numbers' order. Add: update freq; if 1, add to list; if > 1, remove. First unique: list head. | HashMap for freq, DLL for unique order. | Design, Hash Map, Doubly Linked List | O(1) average | O(N) | `if (freq.get(value) == 1) dll.addLast(value); else if (freq.get(value) == 2) dll.remove(Integer.valueOf(value));` |
| 514 | Finding MK Average | 1825 | [https://leetcode.com/problems/finding-mk-average/](https://leetcode.com/problems/finding-mk-average/) | Use three TreeSets: smallest k, middle m-2k, largest k. Maintain sums/sizes. Add new, remove oldest, rebalance sets/sums. Average = middle_sum / middle_size. | Balanced BSTs for sorted segments, rebalance on add/remove. | Data Structures, Sliding Window | O(log M) per add, O(M) constructor | O(M) | `while (small.size() < k && !mid.isEmpty()) { int val = mid.firstKey(); sum -= val; removeFromMap(mid, val); addToMap(small, val); }` |
| 515 | Pairs of Songs With Total Durations Divisible by 60 | 1010 | [https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/) | Count remainders mod 60. For r (1-59), pair with 60-r. For 0, 30, use combinations within same remainder. Sum pairs. | Pair remainders summing to 60 using frequency array. | Hash Map, Modular Arithmetic | O(N) | O(1) | `result += (long) remainders[i] * remainders[60 - i];` |
| 516 | Shortest Word Distance | 243 | [https://leetcode.com/problems/shortest-word-distance/](https://leetcode.com/problems/shortest-word-distance/) | Track latest indices of word1, word2. On encountering word1, compute distance to word2’s last index, and vice versa. Update min distance. | Track latest indices for distance calculation. | Array Iteration, Two Pointers | O(N) | O(1) | `if (words[i].equals(word1)) { idx1 = i; if (idx2 != -1) minDist = Math.min(minDist, idx1 - idx2); }` |
| 517 | Shortest Word Distance II | 244 | [https://leetcode.com/problems/shortest-word-distance-ii/](https://leetcode.com/problems/shortest-word-distance-ii/) | Map word -> sorted index list. Query: use two pointers on index lists of word1, word2 to find min absolute difference. | Two pointers on sorted index lists. | Design, Hash Map, Two Pointers | O(L) constructor, O(I1 + I2) query | O(L) | `minDist = Math.min(minDist, Math.abs(list1.get(i) - list2.get(j))); if (list1.get(i) < list2.get(j)) i++; else j++;` |
| 518 | Shortest Word Distance III | 245 | [https://leetcode.com/problems/shortest-word-distance-iii/](https://leetcode.com/problems/shortest-word-distance-iii/) | If word1 != word2, same as Shortest Word Distance I. If same, track last two indices, compute distance as current - previous. Update min. | Handle same-word case with last two indices. | Array Iteration, Two Pointers | O(N) | O(1) | `if (word1.equals(word2)) { prev = curr; curr = i; if (prev != -1) minDist = Math.min(minDist, curr - prev); }` |
| 519 | Maximum Points You Can Obtain from Cards | 1423 | [https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/) | Max points from k cards at ends = total sum - min sum of contiguous n-k middle subarray. Use sliding window for min sum. | Minimize middle subarray sum via sliding window. | Sliding Window, Array Iteration | O(N) | O(1) | `windowSum += cardPoints[i] - cardPoints[i - windowSize]; minWindowSum = Math.min(minWindowSum, windowSum);` |
| 520 | Leftmost Column with at Least a One | 1428 | [https://leetcode.com/problems/leftmost-column-with-at-least-a-one/](https://leetcode.com/problems/leftmost-column-with-at-least-a-one/) | Start top-right. If 1, move left (potential answer). If 0, move down. Stop when out of bounds. Return last valid column. | Top-right traversal: left on 1, down on 0. | Matrix Traversal, Binary Matrix | O(M + N) | O(1) | `if (mat.get(row, col) == 1) col--; else row++;` |
| 521 | Cinema Seat Allocation | 1386 | [https://leetcode.com/problems/cinema-seat-allocation/](https://leetcode.com/problems/cinema-seat-allocation/) | Check 4-seat blocks (2-5, 4-7, 6-9) per row with reserved seats in map. Prioritize 2-5, 6-9. Unreserved rows give 2 families. | Check block availability in reserved rows. | Hash Map, Set, Iteration | O(R log R + K) where R is reserved rows, K is reservations | O(K) | `if (!seats.contains(2) && !seats.contains(3) && !seats.contains(4) && !seats.contains(5)) count++;` |
| 522 | Number of Islands II | 305 | [https://leetcode.com/problems/number-of-islands-ii/](https://leetcode.com/problems/number-of-islands-ii/) | Use Union-Find. For each land (r, c), make own set. Union with land neighbors. Track island count (disjoint sets). | Union-Find for dynamic connectivity. | Union-Find, Matrix Traversal | O(K * alpha(M*N)) where K is operations, alpha is inverse Ackermann | O(M*N) | `if (r >= 0 && r < m && c >= 0 && c < n && uf.parent[r * n + c] != -1) uf.union(idx, r * n + c);` |
| 523 | Shortest Distance from All Buildings | 317 | [https://leetcode.com/problems/shortest-distance-from-all-buildings/](https://leetcode.com/problems/shortest-distance-from-all-buildings/) | Multi-source BFS from all buildings. Track total distance and reach count per empty cell. Find min distance for cells reachable by all buildings. | BFS from buildings, accumulate distances. | BFS, Matrix Traversal | O(B * M * N) where B is buildings, M*N is grid | O(M*N) | `dist[r][c] += level; reach[r][c]++; queue.offer(new int[]{r, c});` |
| 524 | Palindrome Pairs | 336 | [https://leetcode.com/problems/palindrome-pairs/](https://leetcode.com/problems/palindrome-pairs/) | Map word -> index. For each word, split into prefix/suffix. If suffix is palindrome, check reverse(prefix) in map. If prefix is palindrome, check reverse(suffix). Handle empty string. | Check palindrome parts, reverse counterparts in map. | Hash Map, String Manipulation | O(N * L^2) where N is words, L is max length | O(N) | `if (isPalindrome(right) && map.containsKey(new StringBuilder(left).reverse().toString())) result.add(Arrays.asList(map.get(revLeft), i));` |
| 525 | Valid Triangle Number | 611 | [https://leetcode.com/problems/valid-triangle-number/](https://leetcode.com/problems/valid-triangle-number/) | Sort array. Fix k. Use two pointers i, j on [0, k-1]. If nums[i] + nums[j] > nums[k], add j - i to count, decrement j. Else, increment i. | Two pointers for smaller sides, sorted array. | Sorting, Two Pointers | O(N^2) | O(1) | `if (nums[i] + nums[j] > nums[k]) { count += j - i; j--; } else i++;` |
| 526 | Rotate Function | 396 | [https://leetcode.com/problems/rotate-function/](https://leetcode.com/problems/rotate-function/) | F(k+1) = F(k) + sum(A) - n * A[n-1-k]. Compute F(0), iteratively compute F(1)...F(n-1) using formula. Track max. | Use formula to compute F(k+1) from F(k). | Array Iteration, Math | O(N) | O(1) | `f = f + sum - (long) A.length * A[A.length - i]; max = Math.max(max, f);` |
| 527 | Flatten 2D Vector | 251 | [https://leetcode.com/problems/flatten-2d-vector/](https://leetcode.com/problems/flatten-2d-vector/) | Use outer (list index), inner (element index) pointers. hasNext: advance to next valid element. next: return element, increment inner, advance outer if needed. | Pointers for list and element, advance to valid. | Design, Iterator, Two Pointers | O(1) average | O(1) | `while (outer < vector.length && inner >= vector[outer].length) { inner = 0; outer++; }` |
| 528 | Zigzag Iterator | 281 | [https://leetcode.com/problems/zigzag-iterator/](https://leetcode.com/problems/zigzag-iterator/) | Use queue of iterators. hasNext: check if queue front has next. next: dequeue iterator, get next, re-enqueue if more elements. | Queue cycles through iterators for interleaving. | Design, Iterator, Queue | O(1) average | O(k) where k is lists (2) | `Iterator<Integer> curr = queue.poll(); int val = curr.next(); if (curr.hasNext()) queue.offer(curr);` |
| 529 | Peeking Iterator | 284 | [https://leetcode.com/problems/peeking-iterator/](https://leetcode.com/problems/peeking-iterator/) | Cache peeked element. peek: if no cache, get next from iterator and store. next: return cache or iterator next, clear cache. hasNext: check cache or iterator. | Cache peeked element for efficient peek. | Design, Iterator, Caching | O(1) | O(1) | `if (peeked == null) peeked = iterator.next(); return peeked;` |
| 530 | Moving Average from Data Stream | 346 | [https://leetcode.com/problems/moving-average-from-data-stream/](https://leetcode.com/problems/moving-average-from-data-stream/) | Use queue of size `size`. Maintain sum. Add: enqueue, add to sum; if size exceeded, dequeue, subtract. Average = sum / count. | Queue with running sum for sliding window. | Design, Queue, Sliding Window | O(1) | O(size) | `queue.offer(val); sum += val; if (queue.size() > size) sum -= queue.poll();` |
| 531 | Find the Closest Element in Binary Search Tree | N/A | [https://www.geeksforgeeks.org/find-closest-element-binary-search-tree/](https://www.geeksforgeeks.org/find-closest-element-binary-search-tree/) | Traverse BST towards target. At each node, update closest value if current is closer. Move left or right based on target comparison. | BST traversal, track closest value. | Tree Traversal, Binary Search | O(H) where H is tree height | O(1) | `if (Math.abs(node.val - target) < Math.abs(closest - target)) closest = node.val;` |
| 532 | Asteroid Collision | 735 | [https://leetcode.com/problems/asteroid-collision/](https://leetcode.com/problems/asteroid-collision/) | Use stack. Push right-movers (+). Left-movers (-) collide with stack top (+). Handle collisions: equal size, both pop; smaller loses; larger survives. | Stack simulates collisions, process left-movers against right-movers. | Stack, Simulation | O(N) | O(N) | `if (stack.peek() > 0 && asteroid < 0) { if (stack.peek() < -asteroid) stack.pop(); else continue; }` |
| 533 | Daily Temperatures | 739 | [https://leetcode.com/problems/daily-temperatures/](https://leetcode.com/problems/daily-temperatures/) | Monotonic stack (decreasing temps/indices). For each temp, pop stack while current temp > stack top temp, set result[popped_index] = current_index - popped_index. Push current index. | Monotonic stack tracks waiting indices. | Stack, Monotonic Stack | O(N) | O(N) | `while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) result[stack.pop()] = i - stack.peek();` |
| 534 | Find Pivot Index | 724 | [https://leetcode.com/problems/find-pivot-index/](https://leetcode.com/problems/find-pivot-index/) | Compute total sum. Iterate, maintain left sum. Right sum = total - left - current. If left == right, return index. | Use total sum, derive right sum from left sum. | Array Iteration, Prefix Sum | O(N) | O(1) | `leftSum += nums[i]; if (leftSum - nums[i] == totalSum - leftSum) return i;` |
| 535 | My Calendar I | 729 | [https://leetcode.com/problems/my-calendar-i/](https://leetcode.com/problems/my-calendar-i/) | Store intervals in sorted list or TreeMap. Book: check overlap with existing intervals. If no overlap, add interval. | Check overlap with sorted intervals. | Data Structures, Interval Management | O(N) per booking | O(N) | `if (prev != null && prev.getValue() > start || next != null && next.getKey() < end) return false;` |
| 536 | Pascal's Triangle | 118 | [https://leetcode.com/problems/pascals-triangle/](https://leetcode.com/problems/pascals-triangle/) | Build row by row. Each element is sum of two elements above in previous row. Edges are 1. | Compute each row using previous row’s elements. | Array, Dynamic Programming | O(numRows^2) | O(numRows^2) | `curr.add(prev.get(j - 1) + prev.get(j));` |
| 537 | Count and Say | 38 | [https://leetcode.com/problems/count-and-say/](https://leetcode.com/problems/count-and-say/) | Iteratively generate n-th term from previous. Count consecutive digits in prev term, append count+digit to new term. | Generate term by describing previous term’s digits. | String Manipulation, Simulation | O(N * L) where L is term length | O(L) | `while (j < curr.length()) { if (curr.charAt(j) == curr.charAt(i)) count++; else { next.append(count).append(curr.charAt(i)); i = j; count = 1; } j++; }` |
| 538 | Target Sum | 494 | [https://leetcode.com/problems/target-sum/](https://leetcode.com/problems/target-sum/) | Transform to subset sum: find S1 such that `2*S1 = TotalSum + Target`. Use DP: `dp[s]` = ways to get sum s. Iterate nums, update `dp[s + num] += dp[s]`. | Reduce to subset sum with DP. | Dynamic Programming, Subset Sum | O(N * TotalSum) | O(TotalSum) | `for (int num : nums) for (int s = targetSum; s >= num; s--) dp[s] += dp[s - num];` |
| 539 | Nested List Weight Sum | 339 | [https://leetcode.com/problems/nested-list-weight-sum/](https://leetcode.com/problems/nested-list-weight-sum/) | Recursive DFS: for each nested integer, sum value * depth. For nested lists, recurse with depth + 1. | Multiply integers by depth, recurse on lists. | Recursion, DFS | O(N) where N is total elements | O(D) where D is max depth | `if (nestedList.isInteger()) return nestedList.getInteger() * depth; for (NestedInteger ni : nestedList.getList()) sum += dfs(ni, depth + 1);` |
| 540 | Nested List Weight Sum II | 364 | [https://leetcode.com/problems/nested-list-weight-sum-ii/](https://leetcode.com/problems/nested-list-weight-sum-ii/) | BFS: process level by level. Maintain unweighted_sum (current level) and weighted_sum (total). Add unweighted_sum to weighted_sum each level. | Single-pass BFS, weight by remaining levels. | BFS | O(N) | O(W) where W is max width | `for (NestedInteger ni : currLevel) { if (ni.isInteger()) unweightedSum += ni.getInteger(); else nextLevel.addAll(ni.getList()); } weightedSum += unweightedSum;` |
| 541 | Flatten Nested List Iterator | 341 | [https://leetcode.com/problems/flatten-nested-list-iterator/](https://leetcode.com/problems/flatten-nested-list-iterator/) | Use stack. Push nested lists/integers in reverse. hasNext: pop lists, push their elements in reverse until integer on top. next: pop integer. | Stack flattens lists by pushing elements in reverse. | Stack, Iterator Design | O(1) average | O(D) | `while (!stack.isEmpty() && !stack.peek().isInteger()) for (NestedInteger ni : stack.pop().getList()) stack.push(ni);` |
| 542 | Water and Jug Problem | 365 | [https://leetcode.com/problems/water-and-jug-problem/](https://leetcode.com/problems/water-and-jug-problem/) | Measurable amounts are multiples of GCD(jug1, jug2). Check if `target <= jug1 + jug2` and `target % GCD == 0`. Handle target = 0. | Use GCD to determine measurable amounts. | Math, Number Theory | O(log(min(jug1, jug2))) | O(1) | `return target == 0 || (target <= jug1 + jug2 && target % gcd(jug1, jug2) == 0);` |
| 543 | Candy Crush | 723 | [https://leetcode.com/problems/candy-crush/](https://leetcode.com/problems/candy-crush/) | Simulate: mark 3+ adjacent identical candies, crush (set to 0), let fall (move non-zero down). Repeat until no crushes. | Mark, crush, and drop candies iteratively. | Simulation, Matrix Manipulation | O((R*C)^2) worst case | O(R*C) | `for (int i = 0; i < R; i++) for (int j = 0; j < C; j++) if (Math.abs(board[i][j]) >= 3) mark[i][j] = true;` |
| 544 | Remove Comments | 722 | [https://leetcode.com/problems/remove-comments/](https://leetcode.com/problems/remove-comments/) | State machine: track if in block comment. Process char by char, handle `/*`, `*/`, `//`. Append non-comment chars to result. | State machine skips comment characters. | String Parsing, State Machine | O(T) where T is total chars | O(T) | `if (!inBlock && c == '/' && i + 1 < line.length() && line.charAt(i + 1) == '*') { inBlock = true; i++; }` |
| 545 | Keys and Rooms | 841 | [https://leetcode.com/problems/keys-and-rooms/](https://leetcode.com/problems/keys-and-rooms/) | DFS/BFS from room 0. Use visited set. Explore neighbors (rooms via keys). Check if all rooms visited. | Graph traversal to check reachability. | DFS/BFS, Graph Traversal | O(N + E) where N is rooms, E is keys | O(N) | `for (int key : rooms.get(room)) if (!visited.contains(key)) dfs(key, rooms, visited);` |
| 546 | Analyze User Website Visit Pattern | 1152 | [https://leetcode.com/problems/analyze-user-website-visit-pattern/](https://leetcode.com/problems/analyze-user-website-visit-pattern/) | Group visits by user, sort by time. Generate unique 3-length subsequences per user. Count pattern frequencies across users. Find max freq, lexicographically smallest. | Generate subsequences, count frequencies. | Hash Map, Sorting, Subsequences | O(N * L^3) where N is users, L is max visits | O(N * L^3) | `for (int i = 0; i < websites.size(); i++) for (int j = i + 1; j < websites.size(); j++) for (int k = j + 1; k < websites.size(); k++) patterns.add(websites.get(i) + "," + websites.get(j) + "," + websites.get(k));` |
| 547 | Maximum Number of Events That Can Be Attended | 1353 | [https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/) | Sort events by start day. Use min-heap for end days of available events. Iterate days, add events starting today, remove ended, attend earliest-ending event. | Greedy: attend event with earliest end day. | Sorting, Priority Queue, Greedy | O(N log N + D) where D is max days | O(N) | `pq.offer(events[j][1]); j++; while (!pq.isEmpty() && pq.peek() < day) pq.poll(); if (!pq.isEmpty()) { pq.poll(); count++; }` |
| 548 | Delete Nodes And Return Forest | 1110 | [https://leetcode.com/problems/delete-nodes-and-return-forest/](https://leetcode.com/problems/delete-nodes-and-return-forest/) | Post-order DFS. If node value in delete set, add children to result if not null, return null. Else, process children, add root to result if is_root. | Post-order to handle children before parent. | Tree Traversal, Recursion | O(N) | O(H + D) where H is height, D is delete set size | `if (to_delete.contains(node.val)) { if (node.left != null) result.add(dfs(node.left, true, to_delete)); return null; }` |
| 549 | Snapshot Array | 1146 | [https://leetcode.com/problems/snapshot-array/](https://leetcode.com/problems/snapshot-array/) | Per index, store list of `(snap_id, value)` pairs. set: add `(current_snap_id, val)`. snap: increment snap_id. get: binary search for latest snap_id <= target. | Store history per index, binary search for get. | Design, Array, Binary Search | O(1) set/snap, O(log S) get | O(T) where T is total sets | `history.get(index).add(new int[]{snap_id, val}); int idx = Collections.binarySearch(history.get(index), new int[]{snap_id, 0}, (a, b) -> a[0] - b[0]);` |




| Sr No | Problem Name | Problem No | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java/SQL) |
|-------|--------------|------------|------|-----------------|-------|---------|------------------|------------------|-----------------------------|
| 551 | Throne Inheritance | 1600 | [https://leetcode.com/problems/throne-inheritance/](https://leetcode.com/problems/throne-inheritance/) | Design a monarchy system using a tree (map: name -> children list) and a set for deceased. `birth`: add child to parent's list. `death`: mark name in deceased set. `getInheritanceOrder`: DFS pre-order traversal, skipping deceased names. Handles dynamic updates efficiently. Edge case: king deceased, still starts traversal. | Pre-order DFS ensures correct succession order. | Design, Tree, DFS | O(1) for birth/death, O(N) for inheritance where N is total people | O(N) for tree and set | `if (!deceased.contains(curr)) order.add(curr); for (String child : children.get(curr)) dfs(child, order);` |
| 552 | Number of Ways to Form a Target String Given a Dictionary | 1639 | [https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/) | Dynamic Programming: `dp[i][j]` = ways to form target[0..i-1] using dictionary[0..j-1]. For each position j, precompute char frequency in column j. Transition: if target[i-1] matches, add `dp[i-1][j-1] * freq`. Optimize to 1D DP. Use modulo 10^9+7 for large results. Edge cases: empty target, no matches in dictionary. | Precompute column frequencies for O(1) lookup per step. | Dynamic Programming, Counting | O(T * D * 26) where T is target length, D is dict length | O(T) with 1D DP | `dp[i] = (dp[i] + dp[i-1] * charCount[j][target.charAt(i-1) - 'a']) % MOD;` |
| 553 | Remove Sub-Folders from the Filesystem | 1233 | [https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/) | Sort paths lexicographically so parent folders appear before sub-folders. Iterate through sorted list: if current path starts with previous valid path + '/', skip it (sub-folder); otherwise, add to result and update previous. Edge cases: ["/a", "/a/b"], ["/a/b/c", "/a/b"]. | Sorting ensures parent check precedes sub-folders. | Sorting, String | O(N log N + N * L) where N is paths, L is max path length | O(N) for result | `if (prev.isEmpty() || !folder.startsWith(prev + "/")) result.add(folder); prev = folder;` |
| 554 | Largest Color Value in a Directed Graph | 1857 | [https://leetcode.com/problems/largest-color-value-in-a-directed-graph/](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/) | Use topological sort (Kahn’s algorithm) to detect cycles (return -1 if found) and process nodes in order. DP: `dp[u][c]` = max count of color c ending at node u. Update based on neighbors’ max counts + 1 if u has color c. Track global max. Edge cases: cycles, single node, disconnected components. | Topological order ensures acyclic DP updates. | Topological Sort, DP | O(V + E * 26) where V is nodes, E is edges | O(V * 26) for DP table | `dp[u][c] = Math.max(dp[u][c], dp[v][c] + (colors.charAt(u) == c + 'a' ? 1 : 0));` |
| 555 | Rotating the Box | 1861 | [https://leetcode.com/problems/rotating-the-box/](https://leetcode.com/problems/rotating-the-box/) | Rotate grid 90° clockwise: (i,j) -> (j, m-1-i). Then, for each column in rotated grid, simulate gravity bottom-up: move stones '#' past '.' to '*' or bottom. Process column-by-column to place stones correctly. Edge cases: all obstacles, no stones. | Rotate first, then handle gravity per column. | Matrix, Simulation | O(R * C) where R, C are grid dimensions | O(R * C) for rotated grid | `for (int j = 0; j < n; j++) rotated[j][m-1-i] = box[i][j];` |
| 556 | Delete Duplicate Folders in System | 1946 | [https://leetcode.com/problems/delete-duplicate-folders-in-system/](https://leetcode.com/problems/delete-duplicate-folders-in-system/) | Build folder tree, serialize subtrees (sorted children + their serialized form). Use map to track serialized strings to node lists. Mark nodes in lists with size > 1 as duplicates. Reconstruct paths, skipping marked nodes. Edge cases: nested duplicates, single folder. | Serialization uniquely identifies duplicate subtrees. | Tree, Hash Map | O(N * L) where N is nodes, L is max serialization length | O(N * L) for map | `map.computeIfAbsent(serial, k -> new ArrayList<>()).add(node); if (map.get(serial).size() > 1) mark.addAll(map.get(serial));` |
| 557 | Check if an Original String Exists Given Two Encoded Strings | 2060 | [https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/](https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/) | Recursion with memoization on (p1, p2, diff): p1, p2 are positions in strings, diff is char count difference. Match chars or parse numbers (skip digits’ value). Memoize to avoid recomputation. Return true if same original string possible. Edge cases: large numbers, invalid encoding. | Memoization prunes exponential search space. | Recursion, Memoization | O(L1 * L2 * D) where L1, L2 are lengths, D is max diff | O(L1 * L2 * D) for memo | `if (memo[p1][p2].containsKey(diff)) return memo[p1][p2].get(diff);` |
| 558 | Possible Bipartition | 886 | [https://leetcode.com/problems/possible-bipartition/](https://leetcode.com/problems/possible-bipartition/) | Graph coloring with BFS: assign nodes 0 or 1. For each uncolored node, color it 0, neighbors 1, and propagate. If adjacent nodes have same color, return false. Check all components. Edge cases: no edges, disconnected graph. | BFS ensures consistent bipartite coloring. | BFS, Graph | O(N + E) where N is nodes, E is edges | O(N + E) for adj list | `if (colors[neighbor] == colors[node]) return false; colors[neighbor] = 1 - colors[node];` |
| 559 | All Possible Full Binary Trees | 894 | [https://leetcode.com/problems/all-possible-full-binary-trees/](https://leetcode.com/problems/all-possible-full-binary-trees/) | Recursion with memoization: for odd n, FBT(n) = root + FBT(i) + FBT(n-1-i). Base case: n=1 is single node. Memoize FBT(n) to avoid recomputation. Combine all valid left-right pairs. Edge case: n even (return empty). | Memoization reduces time to Catalan number complexity. | Recursion, Tree | O(2^n / sqrt(n)) (Catalan number) | O(2^n / sqrt(n)) for memo | `for (TreeNode left : memo[i]) for (TreeNode right : memo[n-1-i]) result.add(new TreeNode(0, left, right));` |
| 560 | Reveal Cards In Increasing Order | 950 | [https://leetcode.com/problems/reveal-cards-in-increasing-order/](https://leetcode.com/problems/reveal-cards-in-increasing-order/) | Reverse simulation: sort deck ascending. Use queue of indices (0 to n-1). Place largest card at front, move next front to back, repeat. Ensures reveal order matches problem. Edge case: single card. | Reverse process mimics reveal sequence. | Queue, Simulation | O(N log N) for sorting | O(N) for queue | `result[queue.poll()] = deck[i]; if (!queue.isEmpty()) queue.offer(queue.poll());` |
| 561 | Move Pieces to Obtain a String | 2337 | [https://leetcode.com/problems/move-pieces-to-obtain-a-string/](https://leetcode.com/problems/move-pieces-to-obtain-a-string/) | Two pointers: skip underscores in start and target. Check non-underscore chars match. Validate 'L' moves left (start idx >= target idx), 'R' moves right (start idx <= target idx). Edge cases: only underscores, empty strings. | Validate movement direction for L/R pieces. | Two Pointers, String | O(N) where N is string length | O(1) | `if (c1 != '_' && c2 != '_') { if (c1 != c2 || (c1 == 'L' && i < j) || (c1 == 'R' && i > j)) return false; }` |
| 562 | Split Message Based on Limit | 2478 | [https://leetcode.com/problems/split-message-based-on-limit/](https://leetcode.com/problems/split-message-based-on-limit/) | Binary search for min parts y where message + suffixes `<x/y>` fit in y * limit. Compute total length with suffixes. If <= y * limit, construct parts by filling up to limit - suffix length. Edge cases: message too long, limit too small. | Binary search optimizes part count. | Binary Search, String | O(log N * log N) for search and suffix calc | O(N) for result | `if (totalLen <= y * (limit - suffixLen)) left = y; else right = y - 1;` |
| 564 | Detect Squares | 2013 | [https://leetcode.com/problems/detect-squares/](https://leetcode.com/problems/detect-squares/) | Design: map (x,y) -> count for points. `add`: increment count. `count`: for (x1,y1), check (x2,y2) where |x1-x2| = |y1-y2|. Multiply counts of diagonal corners. Edge case: no valid squares. | Use diagonal length to find square corners. | Hash Map, Geometry | O(1) add, O(N) count where N is points | O(N) for map | `if (Math.abs(x1 - x2) == Math.abs(y1 - y2) && x1 != x2) count += map.getOrDefault(x2, y2, 0) * map.getOrDefault(x1, y2, 0) * map.getOrDefault(x2, y1, 0);` |
| 565 | Battleships in a Board | 419 | [https://leetcode.com/problems/battleships-in-a-board/](https://leetcode.com/problems/battleships-in-a-board/) | Count top-left 'X' cells (no 'X' above or left) to avoid double-counting ships. Iterate grid, check (i-1,j) and (i,j-1). Edge cases: empty board, single cell. | Only count ship heads to simplify logic. | Matrix, Counting | O(M * N) where M, N are dimensions | O(1) | `if (board[i][j] == 'X' && (i == 0 || board[i-1][j] != 'X') && (j == 0 || board[i][j-1] != 'X')) count++;` |
| 566 | Rabbits in Forest | 781 | [https://leetcode.com/problems/rabbits-in-forest/](https://leetcode.com/problems/rabbits-in-forest/) | Group rabbits by answer a. For c rabbits saying a, need ceil(c / (a+1)) groups of a+1 rabbits. Sum total = groups * (a+1). Edge case: empty answers. | Ceiling division ensures minimal groups. | Hash Map, Math | O(N) where N is answers | O(N) for map | `count += (freq.getOrDefault(a, 0) + a) / (a + 1) * (a + 1);` |
| 567 | Print in Order | 1114 | [https://leetcode.com/problems/print-in-order/](https://leetcode.com/problems/print-in-order/) | Use semaphores: `sem_second` (init 0), `sem_third` (init 0). `first` releases `sem_second`, `second` waits on it and releases `sem_third`, `third` waits on `sem_third`. Ensures strict order. Edge case: concurrent calls. | Semaphores enforce sequential execution. | Concurrency | O(1) per call | O(1) for semaphores | `sem_second.release(); sem_second.acquire(); sem_third.release();` |
| 568 | Separate Squares I | 3162 | [https://leetcode.com/problems/separate-squares-i/](https://leetcode.com/problems/separate-squares-i/) | Assume grid of 1s (squares) and 0s. Use DFS to find connected components of 1s, verify each is a square (equal width/height). BFS between squares to check separation by 0s. Edge cases: no squares, non-square components. | DFS for shape, BFS for separation check. | DFS, BFS, Matrix | O(M * N) for traversal | O(M * N) for visited | `if (grid[i][j] == 1) dfs(i, j, grid, component);` |
| 571 | Compare Version Numbers | 165 | [https://leetcode.com/problems/compare-version-numbers/](https://leetcode.com/problems/compare-version-numbers/) | Split versions by '.', compare parts as integers. Treat missing parts as 0. Return 1, -1, or 0 based on comparison. Edge cases: leading zeros, unequal lengths. | Parse and pad with zeros for comparison. | String, Array | O(L) where L is max version length | O(L) for split arrays | `if (p1[i] != p2[i]) return p1[i] > p2[i] ? 1 : -1;` |
| 572 | Length of Last Word | 58 | [https://leetcode.com/problems/length-of-last-word/](https://leetcode.com/problems/length-of-last-word/) | Trim trailing spaces, count chars from end until space or start. Handles multiple spaces. Edge cases: empty string, all spaces. | Backward iteration simplifies last word logic. | String | O(N) where N is string length | O(1) | `while (i >= 0 && s.charAt(i) != ' ') { count++; i--; }` |
| 573 | Valid Number | 65 | [https://leetcode.com/problems/valid-number/](https://leetcode.com/problems/valid-number/) | State machine: track digits, decimal, exponent, signs. Validate char placement (e.g., digits required before 'e'). Edge cases: multiple signs, invalid formats. | Flags ensure structural validity. | String, State Machine | O(N) where N is string length | O(1) | `if (c == '.' && !decimal_seen && !exponent_seen) decimal_seen = true; else if (!digit_seen) return false;` |
| 574 | Plus One | 66 | [https://leetcode.com/problems/plus-one/](https://leetcode.com/problems/plus-one/) | Add 1 to digits array from right, propagate carry. If carry remains, extend array with leading 1. Edge case: all 9s (e.g., [9,9] -> [1,0,0]). | Carry handling with array extension. | Array, Math | O(N) where N is digit count | O(N) for result | `digits[i] = sum % 10; carry = sum / 10;` |
| 575 | Restore IP Addresses | 93 | [https://leetcode.com/problems/restore-ip-addresses/](https://leetcode.com/problems/restore-ip-addresses/) | Backtrack: try 1-3 digits per part, validate (0-255, no leading zeros unless '0'). Build 4 parts, add valid IPs. Edge cases: string too short/long. | Early validation prunes invalid branches. | Backtracking, String | O(3^4 * N) where N is string length | O(N) for recursion | `if (val >= 0 && val <= 255 && (s.charAt(start) != '0' || len == 1)) backtrack(start + len, parts + 1, curr + part + ".", s, result);` |
| 576 | Distinct Subsequences | 115 | [https://leetcode.com/problems/distinct-subsequences/](https://leetcode.com/problems/distinct-subsequences/) | DP: `dp[i][j]` = ways to form t[0..i-1] from s[0..j-1]. If chars match, add `dp[i-1][j-1]` to `dp[i][j-1]`. Optimize to 1D DP. Edge cases: empty strings. | 1D DP reduces space usage. | Dynamic Programming | O(|s| * |t|) where |s|, |t| are lengths | O(|t|) with 1D DP | `if (s.charAt(j-1) == t.charAt(i-1)) dp[i] += dp[i-1];` |
| 577 | Find Smallest Letter Greater Than Target | 744 | [https://leetcode.com/problems/find-smallest-letter-greater-than-target/](https://leetcode.com/problems/find-smallest-letter-greater-than-target/) | Binary search for first letter > target in sorted array. Wrap around to first letter if none found. Edge cases: target >= all letters. | Upper bound search with modulo wrap. | Binary Search | O(log N) where N is array length | O(1) | `if (letters[mid] <= target) left = mid + 1; else right = mid;` |
| 578 | Palindromic Substrings | 647 | [https://leetcode.com/problems/palindromic-substrings/](https://leetcode.com/problems/palindromic-substrings/) | Expand around each center (char and between chars) to count palindromes. Check odd and even lengths. Edge cases: single char, all same chars. | Dual expansion covers all palindrome types. | String, Two Pointers | O(N^2) where N is string length | O(1) | `while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) { count++; left--; right++; }` |
| 579 | Construct the Rectangle | 492 | [https://leetcode.com/problems/construct-the-rectangle/](https://leetcode.com/problems/construct-the-rectangle/) | From sqrt(area) down, find first W dividing area. L = area/W. Minimizes L-W. Edge cases: area = 1, prime areas. | Start at sqrt for optimal L-W pair. | Math | O(sqrt(area)) | O(1) | `if (area % w == 0) return new int[]{area / w, w};` |
| 580 | Delete Node in a Linked List | 237 | [https://leetcode.com/problems/delete-node-in-a-linked-list/](https://leetcode.com/problems/delete-node-in-a-linked-list/) | Copy next node’s value to current, skip next node by updating pointer. Assumes not tail node. Edge case: single node (not applicable per problem). | Overwrite and bypass next node. | Linked List | O(1) | O(1) | `node.val = node.next.val; node.next = node.next.next;` |
| 581 | Range Sum Query 2D - Immutable | 304 | [https://leetcode.com/problems/range-sum-query-2d-immutable/](https://leetcode.com/problems/range-sum-query-2d-immutable/) | Precompute 2D prefix sum: `prefixSum[i][j]` = sum from (0,0) to (i,j). Query: subtract overlapping regions using inclusion-exclusion. Edge cases: query at edges (row1/col1 = 0). | Prefix sum enables O(1) range queries. | Prefix Sum, DP | O(M*N) constructor, O(1) query | O(M*N) for prefix sum | `return prefixSum[row2][col2] - (row1 > 0 ? prefixSum[row1-1][col2] : 0) - (col1 > 0 ? prefixSum[row2][col1-1] : 0) + (row1 > 0 && col1 > 0 ? prefixSum[row1-1][col1-1] : 0);` |
| 582 | Kill Process | N/A | [https://www.geeksforgeeks.org/kill-processes-in-a-tree/](https://www.geeksforgeeks.org/kill-processes-in-a-tree/) | Build adjacency list from pid and ppid. DFS from killed process, collect all descendants (including itself). Edge cases: no children, root killed. | DFS traverses process tree efficiently. | Tree, DFS | O(N) where N is processes | O(N) for adj list | `void dfs(int node, List<Integer> result) { result.add(node); for (int child : adj.get(node)) dfs(child, result); }` |
| 583 | Two Sum IV - Input is a BST | 653 | [https://leetcode.com/problems/two-sum-iv-input-is-a-bst/](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) | Inorder traversal to get sorted array, then two pointers to find pair summing to k. Alternatively, use set during DFS: check if k - curr.val exists. Edge cases: no pair, duplicate values. | Set-based DFS avoids sorting overhead. | BST, Two Pointers or Hash Set | O(N) for DFS/set approach | O(N) for set or array | `if (set.contains(k - root.val)) return true; set.add(root.val);` |
| 587 | Erect the Fence | N/A | [https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/](https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/) | Graham Scan or Jarvis March to find convex hull. Sort points by x, then y. Iterate to find boundary points using cross-product for orientation. Edge cases: collinear points, < 3 points. | Cross-product determines turn direction. | Computational Geometry | O(N log N) for sorting + O(N * H) where H is hull points | O(N) for points | `int orient = (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1]); if (orient < 0) hull.add(p2);` |
| 588 | Design In-Memory File System | 588 | [https://leetcode.com/problems/design-in-memory-file-system/](https://leetcode.com/problems/design-in-memory-file-system/) | Trie-like structure: Node with map to children and content (for files). `ls`: traverse path, list children or file name. `mkdir`: create directories. `addContent`: append to file. `readContent`: return file content. Edge cases: empty path, file as dir. | Trie simplifies path operations. | Design, Trie | O(L) for path ops where L is path length | O(N) where N is nodes | `for (String dir : path.split("/")) curr = curr.children.computeIfAbsent(dir, k -> new Node());` |
| 589 | N-ary Tree Preorder Traversal | 589 | [https://leetcode.com/problems/n-ary-tree-preorder-traversal/](https://leetcode.com/problems/n-ary-tree-preorder-traversal/) | Recursive DFS: add root value, recurse on children. Alternatively, iterative with stack: push root, pop and push children in reverse. Edge cases: null root, no children. | Stack reverses child order for preorder. | Tree, DFS | O(N) where N is nodes | O(N) for recursion/stack | `result.add(node.val); for (Node child : node.children) preorder(child, result);` |
| 590 | N-ary Tree Postorder Traversal | 590 | [https://leetcode.com/problems/n-ary-tree-postorder-traversal/](https://leetcode.com/problems/n-ary-tree-postorder-traversal/) | Recursive DFS: recurse on children, then add root value. Iterative: use stack, push root, pop and add to result (reverse at end). Edge cases: null root, single node. | Postorder is reverse of preorder with adjustment. | Tree, DFS | O(N) where N is nodes | O(N) for recursion/stack | `for (Node child : node.children) postorder(child, result); result.add(node.val);` |
| 591 | Tag Validator | 591 | [https://leetcode.com/problems/tag-validator/](https://leetcode.com/problems/tag-validator/) | Stack-based parsing: push opening tags, match closing tags. Validate tag names (uppercase, 1-9 chars). Handle CDATA sections separately. Edge cases: malformed tags, nested CDATA. | Stack ensures proper tag nesting. | String, Stack | O(N) where N is string length | O(N) for stack | `if (isClosingTag(s, i)) { if (stack.isEmpty() || !stack.pop().equals(tag)) return false; }` |
| 592 | Fraction Addition and Subtraction | 592 | [https://leetcode.com/problems/fraction-addition-and-subtraction/](https://leetcode.com/problems/fraction-addition-and-subtraction/) | Parse fractions, compute common denominator (LCM), add numerators. Reduce final fraction using GCD. Handle signs and integer parts. Edge cases: all negative, zero result. | GCD simplifies fraction at end. | Math, String Parsing | O(N * log D) where N is fractions, D is max denominator | O(1) | `int g = gcd(Math.abs(num), den); num /= g; den /= g;` |
| 593 | Valid Square | N/A | [https://www.geeksforgeeks.org/check-if-four-points-form-a-square/](https://www.geeksforgeeks.org/check-if-four-points-form-a-square/) | Compute all 6 pairwise distances between 4 points. Sort distances: valid square has 4 equal sides and 2 equal diagonals (side * sqrt(2)). Edge cases: collinear points, duplicates. | Distance frequency validates square properties. | Geometry, Math | O(1) for 4 points, O(N log N) if generalized | O(1) | `if (distFreq.size() != 2 || distFreq.get(side) != 4 || distFreq.get(diagonal) != 2) return false;` |
| 594 | Longest Harmonious Subsequence | 594 | [https://leetcode.com/problems/longest-harmonious-subsequence/](https://leetcode.com/problems/longest-harmonious-subsequence/) | Map numbers to frequencies. For each num, check num+1 in map; max length = freq[num] + freq[num+1]. Edge cases: no harmonious pair, all same num. | Adjacent frequency sum finds longest pair. | Hash Map | O(N) where N is array length | O(N) for map | `int len = map.getOrDefault(num, 0) + map.getOrDefault(num + 1, 0); max = Math.max(max, len);` |
| 598 | Range Addition II | 598 | [https://leetcode.com/problems/range-addition-ii/](https://leetcode.com/problems/range-addition-ii/) | For each operation [x,y], track min x and min y affected. Final count = minX * minY (all cells in this rectangle incremented at least once). Edge cases: no ops, full grid. | Min dimensions give overlapping region. | Math, Simulation | O(K) where K is operations | O(1) | `minX = Math.min(minX, op[0]); minY = Math.min(minY, op[1]);` |
| 599 | Minimum Index Sum of Two Lists | 599 | [https://leetcode.com/problems/minimum-index-sum-of-two-lists/](https://leetcode.com/problems/minimum-index-sum-of-two-lists/) | Map list1 strings to indices. For each list2 string, compute index sum if in map. Track min sum and corresponding strings. Edge cases: no common strings, ties. | Map reduces lookup time for common strings. | Hash Map | O(N + M) where N, M are list lengths | O(N) for map | `if (map.containsKey(str)) { int sum = i + map.get(str); if (sum < minSum) { minSum = sum; result.clear(); result.add(str); } }` |



| Sr No | Problem Name | Problem No | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java/SQL) |
|-------|--------------|------------|------|-----------------|-------|---------|------------------|------------------|-----------------------------|
| 600 | Number of Connected Components in an Undirected Graph | 323 | [https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) | Count connected components in an undirected graph. Use DFS/BFS or Union-Find. **DFS/BFS**: Iterate through all nodes; if a node is unvisited, perform DFS/BFS to mark all nodes in its component as visited and increment a counter. **Union-Find**: Initialize each node in its own set; iterate through edges to union sets; count the number of disjoint sets remaining. Edge cases: empty graph, single node. | Use DFS/BFS to count traversals from unvisited nodes or Union-Find to count disjoint sets efficiently. | Graph Traversal, Union-Find | O(V + E) for DFS/BFS, O(E α(V)) for Union-Find | O(V + E) for adjacency list in DFS/BFS, O(V) for Union-Find | `if (!visited[node]) { dfs(node, adj, visited); count++; }` |
| 601 | Graph Valid Tree | 261 | [https://leetcode.com/problems/graph-valid-tree/](https://leetcode.com/problems/graph-valid-tree/) | Check if an undirected graph is a valid tree (n nodes, n-1 edges, connected, no cycles). Verify edge count is n-1. Use **Union-Find**: Iterate edges; if unioning two nodes already in the same set, a cycle exists—return false. Ensure one component by checking all nodes are connected. Alternatively, use DFS/BFS for connectivity. Edge cases: multiple components, cycles. | Union-Find efficiently checks both connectivity and cycles with one pass. | Graph, Union-Find | O(E α(V)) where V is nodes, E is edges | O(V) for Union-Find | `if (find(u) == find(v)) return false; union(u, v);` |
| 602 | Redundant Connection | 684 | [https://leetcode.com/problems/redundant-connection/](https://leetcode.com/problems/redundant-connection/) | Find the redundant edge causing a cycle in a graph with n nodes and n edges. Use **Union-Find**: Iterate through edges (u, v); if u and v are in the same set (find(u) == find(v)), that edge is redundant—return it; otherwise, union them. Edge cases: tree structure (no redundant edge), multiple cycles. | The first edge connecting nodes already in the same set is the redundant one. | Union-Find, Cycle Detection | O(E α(V)) where E is edges, V is nodes | O(V) for Union-Find | `if (find(u) == find(v)) return edge; union(u, v);` |
| 603 | Redundant Connection II | 685 | [https://leetcode.com/problems/redundant-connection-ii/](https://leetcode.com/problems/redundant-connection-ii/) | Find the redundant edge in a directed graph (n nodes, n edges). Two cases: **In-degree 2**: Identify nodes with two incoming edges; test removing each candidate edge to check if a tree forms (n-1 edges, no cycles via Union-Find). **Cycle**: If no in-degree 2, use Union-Find on the graph to detect the edge forming a cycle. Edge cases: multiple candidates, no cycle. | Prioritize in-degree 2 nodes, then fall back to cycle detection with Union-Find. | Directed Graph, Union-Find | O(V + E α(V)) where V is nodes, E is edges | O(V) for Union-Find | `if (find(u) == find(v)) return edge; union(u, v);` |
| 604 | Alien Dictionary | 269 | [https://leetcode.com/problems/alien-dictionary/](https://leetcode.com/problems/alien-dictionary/) | Determine the order of characters in an alien language from a sorted dictionary. Build a directed graph: for adjacent words, the first differing characters (u, v) imply an edge u -> v. Use **Topological Sort** (Kahn's or DFS) to derive the order. Detect cycles (invalid dictionary) using DFS or indegree check. Edge cases: single word, prefix words. | Graph edges reveal character precedence from adjacent word pairs. | Topological Sort, DFS | O(C) where C is total characters | O(U) where U is unique characters | `for (char c : indegree.keySet()) if (indegree.get(c) == 0) queue.offer(c);` |
| 605 | Swim in Rising Water | 778 | [https://leetcode.com/problems/swim-in-rising-water/](https://leetcode.com/problems/swim-in-rising-water/) | Find the minimum time (max elevation on path) to travel from (0,0) to (n-1,n-1). **Dijkstra**: Use a priority queue with priority as the max elevation encountered; explore neighbors, update min-max elevation to reach each cell. **Binary Search**: Guess a time T, use DFS/BFS to check reachability with elevation ≤ T, adjust T. Edge cases: single cell, uniform grid. | Dijkstra optimizes the path’s max elevation; binary search leverages monotonicity. | Dijkstra, Binary Search | O(E log V) for Dijkstra, O(V^2 log MaxElevation) for binary search | O(V) for priority queue | `pq.offer(new int[]{grid[0][0], 0, 0}); while (!pq.isEmpty()) { int[] curr = pq.poll(); if (curr[1] == n-1 && curr[2] == n-1) return curr[0]; }` |
| 606 | All Nodes Distance K in Binary Tree | 863 | [https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/) | Find all nodes at distance K from a target node. Convert the tree to an undirected graph by adding parent pointers to an adjacency list. Perform **BFS** from the target node, tracking distance; collect nodes when distance equals K. Use a visited set to avoid cycles. Edge cases: K=0, target is root. | BFS ensures shortest paths in an undirected graph representation. | BFS, Tree to Graph | O(N) where N is nodes | O(N) for adjacency list | `queue.offer(new int[]{target.val, 0}); while (!queue.isEmpty()) { int[] curr = queue.poll(); if (curr[1] == k) result.add(curr[0]); }` |
| 607 | Find All Possible Recipes from Given Supplies | 2115 | [https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/](https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/) | Determine which recipes can be made from given supplies. Use **Topological Sort (Kahn's)**: Build a graph (ingredients -> recipes); compute in-degrees (number of ingredients needed). Start a queue with supplies (in-degree 0); process nodes, reducing in-degrees of dependent recipes; collect recipes when in-degree becomes 0. Edge cases: cyclic dependencies, no recipes. | Topological sort resolves dependencies incrementally. | Topological Sort, BFS | O(V + E) where V is nodes, E is edges | O(V + E) for graph | `if (indegree.get(recipe) == 0) queue.offer(recipe);` |
| 608 | All Ancestors of a Node in a Directed Acyclic Graph | 2192 | [https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/](https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) | Find all ancestors of each node in a DAG. Build a reverse graph (child -> parents). **Optimized**: Use topological sort; process nodes in order, computing ancestors[u] = parents[u] ∪ ancestors[parents[u]]. **Naive**: DFS/BFS from each node on the reverse graph. Edge cases: leaf nodes, no ancestors. | Reverse graph with topological sort optimizes ancestor computation. | DFS, Topological Sort | O(V + E) with topological sort | O(V * V) for storing ancestors | `for (int parent : reverseGraph.get(node)) ancestors[node].addAll(ancestors[parent]);` |
| 609 | Minimum Weighted Subgraph With the Required Paths | 2203 | [https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/](https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/) | Find the minimum weighted subgraph with paths from src1 -> m, src2 -> m, m -> dest. Run **Dijkstra** thrice: from src1, src2, and dest (on reversed graph). For each node m, compute total = dist1[m] + dist2[m] + dist_rev[m]; return the minimum total. Handle unreachable cases with infinity checks. Edge cases: no valid path, negative weights absent. | Three Dijkstra runs compute all necessary shortest paths efficiently. | Dijkstra, Shortest Path | O(E log V) where E is edges, V is nodes | O(V) for distances | `long total = dist1[m] + dist2[m] + dist_rev[m]; min = Math.min(min, total);` |
| 610 | Path Existence Queries in a Graph I | 1971 | [https://leetcode.com/problems/find-if-path-exists-in-graph/](https://leetcode.com/problems/find-if-path-exists-in-graph/) | Answer queries about path existence in an undirected graph. **Union-Find**: Precompute connectivity by unioning nodes via edges; for each query (s, e), check if find(s) == find(e). **Alternative**: DFS/BFS per query (less efficient for many queries). Edge cases: disconnected graph, self-loops. | Union-Find preprocesses connectivity for fast query responses. | Union-Find, Graph | O(N + E + Q * α(N)) where Q is queries | O(N) for Union-Find | `if (find(u) == find(v)) return true;` |
| 611 | Design Circular Queue | 622 | [https://leetcode.com/problems/design-circular-queue/](https://leetcode.com/problems/design-circular-queue/) | Design a circular queue with enqueue, dequeue, Front, Rear, isEmpty, isFull. Use an array with front and rear pointers; apply modulo arithmetic (e.g., (rear + 1) % size) for wrap-around. Track size or use a flag to distinguish full vs. empty states. Edge cases: full queue, empty queue. | Modulo arithmetic ensures circular behavior seamlessly. | Design, Queue | O(1) for all operations | O(size) for array | `queue[(rear + 1) % size] = value; rear = (rear + 1) % size;` |
| 612 | Implement Queue Using Stacks | 232 | [https://leetcode.com/problems/implement-queue-using-stacks/](https://leetcode.com/problems/implement-queue-using-stacks/) | Implement a queue using two stacks. Push to stack1; for pop/peek, if stack2 is empty, transfer all elements from stack1 to stack2 (reversing order), then pop/peek from stack2. Empty check: both stacks empty. Edge cases: empty queue, consecutive pops. | Transfer elements only when stack2 is depleted for amortized efficiency. | Design, Stack | O(1) amortized for push/pop | O(N) for stacks | `while (!stack1.isEmpty()) stack2.push(stack1.pop());` |
| 613 | Design HashMap | 706 | [https://leetcode.com/problems/design-hashmap/](https://leetcode.com/problems/design-hashmap/) | Design a hash map with put, get, remove operations. Use an array of linked lists (separate chaining). Hash function: key % array.length. Handle collisions by appending to the list at the index. Optionally resize if load factor exceeds a threshold. Edge cases: collisions, empty map. | Separate chaining simplifies collision resolution. | Design, Hash Table | O(1) average for put/get/remove | O(N) for array and lists | `int index = key % array.length; list.add(new Entry(key, value));` |
| 614 | Top K Frequent Elements | 347 | [https://leetcode.com/problems/top-k-frequent-elements/](https://leetcode.com/problems/top-k-frequent-elements/) | Find the top k frequent elements. Use a HashMap to count frequencies. Use a **Min-Heap** of size k: add each (element, freq); if size > k, poll smallest frequency. Collect heap elements. **Alternative**: Bucket sort with frequency as index. Edge cases: k=1, all elements identical. | Min-heap maintains the top k efficiently in O(N log k). | Hash Map, Min-Heap | O(N log k) where N is elements, k is k | O(N) for map and heap | `if (heap.size() > k) heap.poll();` |
| 615 | Min Stack | 155 | [https://leetcode.com/problems/min-stack/](https://leetcode.com/problems/min-stack/) | Design a stack with O(1) push, pop, top, getMin. Use two stacks: one for elements, one for mins. Push: add to main stack; if element ≤ min stack top, push to min stack. Pop: remove from main; if popped equals min stack top, pop min stack. Edge cases: empty stack, duplicate mins. | Auxiliary min stack tracks minimums at each step. | Design, Stack | O(1) for all operations | O(N) for stacks | `if (element <= minStack.peek()) minStack.push(element);` |
| 616 | Max Stack | 716 | [https://leetcode.com/problems/max-stack/](https://leetcode.com/problems/max-stack/) | Design a stack with push, pop, top, peekMax, popMax. Use a **Doubly Linked List** for elements and a **TreeMap** (value -> list of nodes) for max tracking. Push: add to list and map. Pop: remove list tail, update map. PeekMax: TreeMap.lastKey(). PopMax: remove a node for lastKey. Edge cases: multiple max values, empty stack. | TreeMap enables O(log N) max operations. | Design, DLL, TreeMap | O(log N) for peekMax/popMax | O(N) for list and map | `TreeMap.lastKey(); map.get(max).removeLast();` |
| 617 | Stack \| Infix to Postfix | N/A | [https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/](https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/) | Convert infix expression to postfix using a stack. Iterate: Operands output directly; Operators push based on precedence; ‘(’ push; ‘)’ pop until ‘(’, outputting operators. Pop remaining operators. Edge cases: mismatched parentheses, invalid expression. | Stack manages operator precedence effectively. | Stack, String Parsing | O(N) where N is expression length | O(N) for stack | `while (!stack.isEmpty() && precedence(op) <= precedence(stack.peek())) output.append(stack.pop());` |
| 618 | N-Queens | 51 | [https://leetcode.com/problems/n-queens/](https://leetcode.com/problems/n-queens/) | Place N queens on an NxN board with no attacks. Use **Backtracking**: For each row, try placing a queen in each column; check conflicts (column, diagonals) using sets; if valid, recurse to next row; backtrack on failure. Edge cases: n=1, n=0. | Track used columns and diagonals to prune invalid placements. | Backtracking, Recursion | O(N!) where N is board size | O(N) for recursion stack | `if (!cols.contains(col) && !diag1.contains(row - col) && !diag2.contains(row + col)) { board[row][col] = 'Q'; }` |
| 619 | N-Queens II | 52 | [https://leetcode.com/problems/n-queens-ii/](https://leetcode.com/problems/n-queens-ii/) | Count valid N-Queens placements. Use **Backtracking** like N-Queens, but increment a counter at row == N instead of storing boards. Track conflicts with sets or arrays. Edge cases: n=1, n=0. | Count solutions directly without constructing boards. | Backtracking, Recursion | O(N!) where N is board size | O(N) for recursion stack | `if (row == n) count++; else backtrack(row + 1, board, used);` |
| 620 | Beautiful Arrangement | 526 | [https://leetcode.com/problems/beautiful-arrangement/](https://leetcode.com/problems/beautiful-arrangement/) | Count permutations of 1..n where perm[i] % i == 0 or i % perm[i] == 0. Use **Backtracking**: At each index, try unused numbers; if condition holds, mark used, recurse; backtrack. Use bitmask or array for used numbers. Edge cases: n=1, large n. | Bitmask optimizes tracking of used numbers. | Backtracking, Permutations | O(N!) where N is number | O(N) for recursion stack | `if ((index % num == 0 || num % index == 0) && !used[num]) { used[num] = true; backtrack(index + 1); }` |
| 621 | Iterative Letter Combinations of a Phone Number | N/A | [https://www.geeksforgeeks.org/iterative-letter-combinations-of-a-phone-number/](https://www.geeksforgeeks.org/iterative-letter-combinations-of-a-phone-number/) | Generate letter combinations iteratively. Use a queue: Start with [""]. For each digit, dequeue all strings; for each letter of the digit, append to the string and enqueue. Edge cases: empty digits, single digit. | Queue builds combinations level by level iteratively. | Iteration, Queue | O(4^N * N) where N is digits | O(4^N * N) for queue | `for (char letter : mapping[digit]) queue.offer(curr + letter);` |
| 622 | Backtracking | N/A | [https://www.geeksforgeeks.org/backtracking-algorithms/](https://www.geeksforgeeks.org/backtracking-algorithms/) | Backtracking is a technique for building solutions incrementally, undoing steps (backtracking) when constraints fail. Common in problems like N-Queens, Sudoku. Recursively explore states; if invalid, revert and try alternatives. | Undo steps to explore alternative paths efficiently. | Algorithmic Technique | Varies by problem | Varies by problem | `if (isValid(state)) { backtrack(nextState); }` |
| 623 | House Robber | 198 | [https://leetcode.com/problems/house-robber/](https://leetcode.com/problems/house-robber/) | Maximize loot from non-adjacent houses. Use **DP**: dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Optimize to O(1) space with two variables (prev, prevPrev). Edge cases: empty array, single house. | Track max loot with and without the previous house. | Dynamic Programming | O(N) where N is houses | O(1) with space optimization | `curr = Math.max(prev, prevPrev + nums[i]);` |
| 624 | Unique Paths | 62 | [https://leetcode.com/problems/unique-paths/](https://leetcode.com/problems/unique-paths/) | Count unique paths from top-left to bottom-right (right/down moves). **DP**: dp[i][j] = dp[i-1][j] + dp[i][j-1]; optimize to 1D array. **Combinatorial**: C(m+n-2, m-1). Edge cases: 1x1 grid, large m/n. | 1D DP reduces space; combinatorics avoids iteration. | Dynamic Programming, Combinatorics | O(M * N) for DP, O(M + N) for combinatorics | O(M) or O(N) for 1D DP | `dp[j] = dp[j] + dp[j-1];` |
| 625 | Climbing Stairs | 70 | [https://leetcode.com/problems/climbing-stairs/](https://leetcode.com/problems/climbing-stairs/) | Count ways to climb n stairs (1 or 2 steps). **DP**: dp[i] = dp[i-1] + dp[i-2]; Fibonacci sequence; optimize to O(1) space with two variables. Edge cases: n=1, n=0. | Two variables mimic Fibonacci for efficiency. | Dynamic Programming, Fibonacci | O(N) where N is steps | O(1) with space optimization | `curr = prev + prevPrev;` |
| 626 | Maximal Rectangle | 85 | [https://leetcode.com/problems/maximal-rectangle/](https://leetcode.com/problems/maximal-rectangle/) | Find the largest rectangle of 1s in a binary matrix. For each row, compute a histogram of consecutive 1s (heights). Use a **Stack** to solve the largest rectangle in histogram problem per row; track max area. Edge cases: all 0s, single row. | Histogram transformation simplifies to a known problem. | DP, Stack, Matrix | O(M * N) where M, N are dimensions | O(N) for histogram stack | `while (!stack.isEmpty() && heights[stack.peek()] > heights[i]) { int h = heights[stack.pop()]; int w = stack.isEmpty() ? i : i - stack.peek() - 1; maxArea = Math.max(maxArea, h * w); }` |
| 627 | Perfect Squares | 279 | [https://leetcode.com/problems/perfect-squares/](https://leetcode.com/problems/perfect-squares/) | Find the minimum number of perfect squares summing to n. **DP**: dp[i] = min(dp[i - j*j] for j in 1..sqrt(i)) + 1; base dp[0] = 0. **BFS**: Queue levels from n to 0, counting squares used. Edge cases: n=0, n=1. | DP iterates over square subtractions; BFS explores level-wise. | Dynamic Programming, BFS | O(N * sqrt(N)) for DP, O(N) for BFS | O(N) for DP or BFS queue | `dp[i] = Math.min(dp[i], dp[i - j*j] + 1);` |
| 628 | Linked List Cycle | 141 | [https://leetcode.com/problems/linked-list-cycle/](https://leetcode.com/problems/linked-list-cycle/) | Detect a cycle in a linked list. Use **Floyd’s Cycle Detection**: Slow pointer moves 1 step, fast moves 2; if they meet, a cycle exists; if fast reaches null, no cycle. Edge cases: empty list, cycle at head. | Fast pointer catches slow in a cycle, proving its existence. | Two Pointers, Cycle Detection | O(N) where N is nodes | O(1) | `if (fast == slow) return true; slow = slow.next; fast = fast.next.next;` |
| 629 | Remove Nth Node From End of List | 19 | [https://leetcode.com/problems/remove-nth-node-from-end-of-list/](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | Remove the nth node from the end of a linked list. Use **Two Pointers**: First pointer moves n steps ahead; then both move until first reaches the end; second is before the nth node—update its next pointer. Use a dummy node for head removal. Edge cases: remove head, n=1. | Second pointer lags by n nodes for precise positioning. | Two Pointers, Linked List | O(N) where N is list length | O(1) | `first = first.next; if (first == null) return head.next; second = second.next;` |
| 630 | Binary Tree Preorder Traversal | 144 | [https://leetcode.com/problems/binary-tree-preorder-traversal/](https://leetcode.com/problems/binary-tree-preorder-traversal/) | Traverse a binary tree in preorder (root, left, right). **Recursive**: Visit root, recurse left, recurse right. **Iterative**: Use a stack; push root, pop and visit, push right then left. Edge cases: empty tree, skewed tree. | Stack pushes right before left to process left first. | Tree Traversal, Stack | O(N) where N is nodes | O(H) for stack, H is height | `stack.push(root.right); stack.push(root.left);` |
| 631 | Binary Tree Postorder Traversal | 145 | [https://leetcode.com/problems/binary-tree-postorder-traversal/](https://leetcode.com/problems/binary-tree-postorder-traversal/) | Traverse a binary tree in postorder (left, right, root). **Recursive**: Recurse left, recurse right, visit root. **Iterative**: Use two stacks; push to stack1, pop to stack2, push children to stack1; pop stack2 for order. Edge cases: empty tree, single node. | Reverse preorder modification yields postorder iteratively. | Tree Traversal, Stack | O(N) where N is nodes | O(N) for stacks | `while (!stack1.isEmpty()) { Node node = stack1.pop(); stack2.push(node); if (node.left != null) stack1.push(node.left); if (node.right != null) stack1.push(node.right); }` |
| 632 | Path Sum | 112 | [https://leetcode.com/problems/path-sum/](https://leetcode.com/problems/path-sum/) | Check if a root-to-leaf path sums to a target. Use **DFS**: Recurse with current sum + node.val; at a leaf, check if sum equals target. Edge cases: negative values, zero sum. | Accumulate the sum recursively down to leaves. | DFS, Recursion | O(N) where N is nodes | O(H) for recursion stack | `if (node.left == null && node.right == null) return currentSum + node.val == target;` |
| 633 | Path Sum II | 113 | [https://leetcode.com/problems/path-sum-ii/](https://leetcode.com/problems/path-sum-ii/) | Find all root-to-leaf paths summing to a target. Use **DFS with Backtracking**: Track path list; at a leaf, if sum equals target, add path to result; recurse with node added, backtrack by removing it. Edge cases: multiple paths, negative values. | Maintain and revert path list for each exploration. | DFS, Backtracking | O(N) where N is nodes | O(H) for recursion stack | `if (node.left == null && node.right == null && currentSum + node.val == target) result.add(new ArrayList<>(path));` |
| 634 | Flatten Binary Tree to Linked List | 114 | [https://leetcode.com/problems/flatten-binary-tree-to-linked-list/](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) | Flatten a binary tree to a linked list in preorder. **Recursive**: Postorder—flatten left, flatten right, attach right to the end of left, set left to null. **Iterative**: Find rightmost of left subtree, attach right subtree, shift pointers. Edge cases: skewed tree, empty tree. | Postorder ensures subtrees are processed before reattachment. | Tree Traversal, Recursion | O(N) where N is nodes | O(H) for recursion stack | `TreeNode rightmost = prev; while (rightmost.right != null) rightmost = rightmost.right; rightmost.right = curr.right; curr.right = curr.left; curr.left = null;` |
| 635 | Minimum Depth of Binary Tree | 111 | [https://leetcode.com/problems/minimum-depth-of-binary-tree/](https://leetcode.com/problems/minimum-depth-of-binary-tree/) | Find the minimum depth from root to a leaf. **BFS**: Level-order traversal; return the level of the first leaf encountered. **DFS**: Min of left and right depths, adjusting for nodes with one child. Edge cases: empty tree, unbalanced tree. | BFS finds the shortest path to a leaf efficiently. | BFS, Tree Traversal | O(N) where N is nodes | O(W) for BFS queue, W is max width | `if (node.left == null && node.right == null) return level;` |
| 636 | Maximum Depth of Binary Tree | 104 | [https://leetcode.com/problems/maximum-depth-of-binary-tree/](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Find the maximum depth from root to a leaf. **DFS**: 1 + max(left depth, right depth). **BFS**: Count levels in level-order traversal. Edge cases: empty tree, single node. | Recursive DFS computes max depth naturally. | DFS, Tree Traversal | O(N) where N is nodes | O(H) for recursion stack | `return 1 + Math.max(maxDepth(node.left), maxDepth(node.right));` |
| 637 | Top K Frequent Words | 692 | [https://leetcode.com/problems/top-k-frequent-words/](https://leetcode.com/problems/top-k-frequent-words/) | Find the top k frequent words (freq desc, alpha asc for ties). Use a HashMap for frequencies. **Min-Heap** of size k with custom comparator (lower freq first, higher alpha for ties); collect and reverse for order. Edge cases: k=1, frequency ties. | Custom comparator ensures frequency and lexical ordering. | Hash Map, Min-Heap | O(N log k) where N is words | O(N) for map and heap | `if (heap.size() > k) heap.poll();` |
| 638 | Next Greater Element I | 496 | [https://leetcode.com/problems/next-greater-element-i/](https://leetcode.com/problems/next-greater-element-i/) | For each element in nums1, find its next greater element in nums2. Use a **Monotonic Stack** on nums2: Build a map of element -> next greater; pop smaller elements as larger ones arrive. Lookup nums1 in map. Edge cases: no greater element, duplicates. | Stack finds next greater efficiently in one pass. | Monotonic Stack, Hash Map | O(N + M) where N, M are array lengths | O(N) for stack and map | `while (!stack.isEmpty() && nums2[i] > stack.peek()) map.put(stack.pop(), nums2[i]);` |
| 639 | K-diff Pairs in an Array | 532 | [https://leetcode.com/problems/k-diff-pairs-in-an-array/](https://leetcode.com/problems/k-diff-pairs-in-an-array/) | Count unique pairs with |nums[i] - nums[j]| = k. Use a HashMap for frequencies. **k > 0**: For each num, check if num + k exists in map; add pair. **k = 0**: Count elements with freq ≥ 2. Avoid duplicates with a set. Edge cases: k < 0, no pairs. | Set ensures unique pairs; map handles frequency. | Hash Map, Set | O(N) where N is array length | O(N) for map and set | `if (map.containsKey(num + k)) pairs.add(new int[]{num, num + k});` |
| 640 | Baseball Game | 682 | [https://leetcode.com/problems/baseball-game/](https://leetcode.com/problems/baseball-game/) | Compute the total score from operations. Use a **Stack**: Integer—push; ‘C’—pop; ‘D’—push 2 * top; ‘+’—push sum of top two. Sum stack for result. Edge cases: invalid ops, empty stack. | Stack simulates operations in order naturally. | Stack, Simulation | O(N) where N is operations | O(N) for stack | `if (op.equals("C")) stack.pop(); else if (op.equals("D")) stack.push(2 * stack.peek());` |
| 641 | Implement Stack using Queues | 225 | [https://leetcode.com/problems/implement-stack-using-queues/](https://leetcode.com/problems/implement-stack-using-queues/) | Implement a stack using one queue. Push: Add element, rotate queue (dequeue and enqueue all but new element) to put it at front. Pop: Dequeue. Edge cases: empty stack, multiple pushes. | Rotation mimics LIFO behavior with a queue. | Design, Queue | O(N) for push, O(1) for pop | O(N) for queue | `for (int i = 0; i < queue.size() - 1; i++) queue.offer(queue.poll());` |
| 642 | Design Snake Game | 353 | [https://leetcode.com/problems/design-snake-game/](https://leetcode.com/problems/design-snake-game/) | Design a snake game with move, eat, collide logic. Use a **Deque** for snake body (head at front) and a **Set** for collision checks. Move: Update head; check wall/self-collision; if food, extend, else remove tail. Edge cases: hit wall, self-collision. | Deque enables O(1) head/tail ops; set ensures fast lookups. | Design, Deque, Set | O(1) per move | O(W * H + F) where W, H are grid, F is food | `if (body.contains(newHead) || !inBounds(newHead)) return -1;` |
| 643 | Design Underground System | 1396 | [https://leetcode.com/problems/design-underground-system/](https://leetcode.com/problems/design-underground-system/) | Track average travel times. Use two maps: id -> (start_station, start_time); (start, end) -> (total_time, count). CheckIn: Store start info. CheckOut: Compute trip time, update route stats. GetAverage: Return total/count. Edge cases: multiple check-ins, no data. | Maps efficiently store and compute route statistics. | Design, Hash Map | O(1) for operations | O(C + R) where C is customers, R is routes | `totalTime += tripTime; count++;` |
| 644 | Design Front Middle Back Queue | 1670 | [https://leetcode.com/problems/design-front-middle-back-queue/](https://leetcode.com/problems/design-front-middle-back-queue/) | Design a queue with front, middle, back operations. Use two **Deques**: front and back, balanced (front size ≈ back size). Middle ops rebalance by shifting elements. Edge cases: odd/even sizes, empty queue. | Rebalancing maintains middle access in O(1) amortized time. | Design, Deque | O(1) amortized | O(N) for deques | `if (front.size() > back.size()) back.addFirst(front.removeLast());` |
| 645 | Design Browser History | 1472 | [https://leetcode.com/problems/design-browser-history/](https://leetcode.com/problems/design-browser-history/) | Design browser history with visit, back, forward. Use a **List**: Current index tracks position; visit adds to list, clears forward history; back/forward adjust index. Edge cases: back beyond start, forward beyond end. | List with index simulates navigation simply. | Design, List | O(1) for visit, O(steps) for back/forward | O(N) for history list | `history.subList(current + 1, history.size()).clear(); history.add(url); current++;` |
| 646 | Design Parking System | 1603 | [https://leetcode.com/problems/design-parking-system/](https://leetcode.com/problems/design-parking-system/) | Design a parking system with spots per car type. Use an array for capacities. addCar: If spots[type] > 0, decrement and return true; else false. Edge cases: no spots, invalid type. | Array leverages fixed types for O(1) access. | Design, Array | O(1) for addCar | O(1) for array | `if (spots[type] > 0) { spots[type]--; return true; }` |
| 647 | Design Authentication Manager | 1797 | [https://leetcode.com/problems/design-authentication-manager/](https://leetcode.com/problems/design-authentication-manager/) | Design an authentication manager with generate, renew, countUnexpired. Use a **Map** (tokenId -> expiration_time). Generate: Set expiration. Renew: Update if unexpired. Count: Count tokens with expiration > currentTime. Edge cases: expired tokens, no tokens. | Map tracks expiration times efficiently. | Design, Hash Map | O(1) for generate/renew, O(N) for count | O(N) for map | `if (map.containsKey(tokenId) && map.get(tokenId) > currentTime) map.put(tokenId, currentTime + ttl);` |
| 648 | Design Skiplist | 1206 | [https://leetcode.com/problems/design-skiplist/](https://leetcode.com/problems/design-skiplist/) | Design a skiplist for O(log N) average search/insert/delete. Use multiple levels of sorted linked lists; higher levels skip nodes probabilistically. Insert: Assign random level, update pointers. Edge cases: duplicates, large ranges. | Random levels balance performance probabilistically. | Design, Skiplist | O(log N) average for operations | O(N) average | `if (randomLevel() > currentLevel) addNewLevel();` |
