| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 1 | Two Sum | 1 | https://leetcode.com/problems/two-sum/ | Use a HashMap to store encountered numbers and their indices. For each element nums[i], check if target - nums[i] (the complement) exists in the map. If yes, return indices. If no, add nums[i] and its index to the map. | HashMap for O(1) complement lookup. | Hash Map | O(n) | O(n) | `if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i);` |
| 2 | Longest Substring Without Repeating Characters | 3 | https://leetcode.com/problems/longest-substring-without-repeating-characters/ | Use a sliding window approach with two pointers (start, end) and a Set/Map to track characters within the window [start, end). Expand end. If s.charAt(end) is in the set, shrink the window by incrementing start and removing s.charAt(start) from the set until the duplicate is removed. Update max length. | Sliding window with Set/Map for efficient duplicate checks. | Sliding Window | O(n) | O(min(n, m)) (where m is alphabet size) | `if (set.contains(s.charAt(end))) { set.remove(s.charAt(start++)); } else { set.add(s.charAt(end++)); maxLen = Math.max(maxLen, end - start); }` |
| 3 | Median of Two Sorted Arrays | 4 | https://leetcode.com/problems/median-of-two-sorted-arrays/ | Use binary search on the smaller array to find the correct partition point partitionX. Calculate the corresponding partition partitionY in the other array such that partitionX + partitionY = (n+m+1)/2. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. Adjust binary search range based on comparison. | Binary search on partitions to find median in logarithmic time. | Binary Search | O(log(min(n, m))) | O(1) | `if (maxLeftX <= minRightY && maxLeftY <= minRightX) { // Found partition } else if (maxLeftX > minRightY) { high = partitionX - 1; } else { low = partitionX + 1; }` |
| 4 | Maximum Subarray | 53 | https://leetcode.com/problems/maximum-subarray/ | Kadane's Algorithm: Iterate through the array, maintaining currentMax (max sum ending at current position) and globalMax (max sum found so far). currentMax = max(num, currentMax + num). Update globalMax = max(globalMax, currentMax). | Kadane's: Discard subarray prefix if its sum becomes negative. | Dynamic Programming / Greedy | O(n) | O(1) | `currentMax = Math.max(num, currentMax + num); globalMax = Math.max(globalMax, currentMax);` |
| 5 | Merge Intervals | 56 | https://leetcode.com/problems/merge-intervals/ | Sort intervals based on start times. Iterate through sorted intervals, merging overlapping ones. If the current interval overlaps with the last merged interval in the result list (current.start <= last.end), update the end of the last interval (last.end = max(last.end, current.end)). Otherwise, add the current interval as a new entry. | Sort by start then merge greedily. | Sorting / Greedy | O(n log n) | O(n) (for result list) or O(log n) (for sort) | `if (merged.isEmpty() || current.start > merged.get(merged.size() - 1).end) { merged.add(current); } else { merged.get(merged.size() - 1).end = Math.max(merged.get(merged.size() - 1).end, current.end); }` |
| 6 | Reverse Linked List | 206 | https://leetcode.com/problems/reverse-linked-list/ | Iterative approach: Use three pointers: prev (initially null), curr (initially head), and nextTemp. While curr is not null, store curr.next in nextTemp, set curr.next to prev, update prev to curr, and move curr to nextTemp. | Iterative reversal using three pointers (prev, curr, next). | Linked List | O(n) | O(1) | `ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp;` |
| 7 | LRU Cache | 146 | https://leetcode.com/problems/lru-cache/ | Use a HashMap for O(1) key lookup and a Doubly Linked List (DLL) to maintain the order of usage. Map keys to DLL nodes. On get or put (update), move the accessed node to the front of the DLL. On put when capacity is reached, remove the node from the tail of the DLL and the corresponding entry from the map. | HashMap + Doubly Linked List for O(1) get/put. | Hash Map / Doubly Linked List | O(1) for get and put | O(capacity) | `// On access (get/put): removeNode(node); addToFront(node); // On put full: Node tail = removeTail(); map.remove(tail.key);` |
| 8 | Generate Parentheses | 22 | https://leetcode.com/problems/generate-parentheses/ | Use backtracking (recursive approach). Maintain counts of open and close parentheses used. Add '(' if open < n. Add ')' if close < open. Base case: if length is 2*n, add the string to the result list. | Backtracking with constraints on open/close counts. | Backtracking / Recursion | O(4^n / (n^(3/2))) (Catalan Number) | O(n) (recursion stack) + O(n * 4^n / (n^(3/2))) (result storage) | `if (open < max) backtrack(list, str + '(', open + 1, close, max); if (close < open) backtrack(list, str + ')', open, close + 1, max);` |
| 9 | Lowest Common Ancestor of a Binary Tree | 236 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ | Recursive approach. Base cases: If root is null, p, or q, return root. Recursively find LCA in left and right subtrees (leftLCA, rightLCA). If both are non-null, current root is LCA. If only one is non-null, return that one. If both are null, return null. | Recursive search; LCA is the node where paths to p and q diverge. | Tree / Recursion / DFS | O(n) | O(n) (worst case, skewed tree) O(h) (average, height) | `ListNode leftLCA = lowestCommonAncestor(root.left, p, q); ListNode rightLCA = lowestCommonAncestor(root.right, p, q); if (leftLCA != null && rightLCA != null) return root; return (leftLCA != null) ? leftLCA : rightLCA;` |
| 10 | Longest Increasing Subsequence | 300 | https://leetcode.com/problems/longest-increasing-subsequence/ | DP with Memoization: Define dp[i] as the LIS ending at index i. To compute dp[i], iterate j from 0 to i-1. If nums[i] > nums[j], then dp[i] = max(dp[i], 1 + dp[j]). Alternatively, O(n log n) approach using patience sorting (maintain tails of potential LIS). | DP state dp[i] = LIS length ending at i. (Or O(n log n) patience sort). | Dynamic Programming | O(n^2) for basic DP, O(n log n) optimized | O(n) | `for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLength = Math.max(maxLength, dp[i]);` (for O(n^2) DP) |
| 11 | Search in Rotated Sorted Array | 33 | https://leetcode.com/problems/search-in-rotated-sorted-array/ | Modified Binary Search. Find the pivot point (minimum element) first OR directly adapt binary search. In each step, determine which half (left or right of mid) is sorted. Check if the target lies within the sorted half's range. Adjust low and high accordingly. | Modified binary search adapting to the rotation point. | Binary Search | O(log n) | O(1) | `if (nums[low] <= nums[mid]) { // Left half sorted if (target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; } else { // Right half sorted ... }` |
| 12 | Number of Islands | 200 | https://leetcode.com/problems/number-of-islands/ | Iterate through the grid. If a cell contains '1' and hasn't been visited, increment the island count and start a DFS or BFS from that cell to mark all connected '1's as visited (e.g., change '1' to '0' or use a separate visited array). | DFS/BFS traversal to explore and mark connected land cells. | Graph Traversal (DFS/BFS) | O(m*n) | O(m*n) (recursion stack for DFS or queue/visited array for BFS) | `if (grid[r][c] == '1') { count++; dfs(grid, r, c); // or bfs } // dfs(grid, r, c): mark grid[r][c] = '0'; explore neighbors` |
| 13 | Container With Most Water | 11 | https://leetcode.com/problems/container-with-most-water/ | Use two pointers, left at index 0 and right at index n-1. Calculate area min(height[left], height[right]) * (right - left). Update max area. Move the pointer pointing to the shorter line inward (left++ if height[left] < height[right], else right--). | Two pointers: move the shorter height pointer inward. | Two Pointers | O(n) | O(1) | `area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--;` |
| 14 | Trapping Rain Water | 42 | https://leetcode.com/problems/trapping-rain-water/ | Calculate maxLeft[i] (max height to the left of i) and maxRight[i] (max height to the right of i) for all i. The water trapped at index i is max(0, min(maxLeft[i], maxRight[i]) - height[i]). Sum these amounts. Can be optimized to O(1) space using two pointers. | Water at i depends on min(max_left, max_right) - height[i]. | Dynamic Programming / Two Pointers | O(n) | O(n) (for DP arrays) or O(1) (for Two Pointer) | `water += Math.max(0, Math.min(maxLeft[i], maxRight[i]) - height[i]); // DP <br> // Two Pointer: if (leftMax < rightMax) { water += leftMax - height[left]; left++; } else { water += rightMax - height[right]; right--; }` |
| 15 | Merge Two Sorted Lists | 21 | https://leetcode.com/problems/merge-two-sorted-lists/ | Iterative approach: Use a dummy head node. Maintain a current pointer for the merged list. Compare heads of list1 and list2. Append the smaller node to current.next and advance that list's pointer. Update current. After loop, append the remaining non-null list. | Dummy head node simplifies merging logic. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode dummy = new ListNode(0); ListNode current = dummy; ... if (list1.val <= list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; ... return dummy.next;` |
| 16 | Add Two Numbers | 2 | https://leetcode.com/problems/add-two-numbers/ | Iterate through both lists simultaneously using a dummy head for the result list. Keep track of carry. At each step, calculate sum = l1.val + l2.val + carry. The digit for the new node is sum % 10, and the new carry is sum / 10. Handle remaining nodes and final carry. | Simulate elementary addition with carry using linked lists. | Linked List / Simulation | O(max(n, m)) | O(max(n, m)) (for result list) | `int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); carry = sum / 10; curr.next = new ListNode(sum % 10); ...` |
| 17 | Binary Tree Inorder Traversal | 94 | https://leetcode.com/problems/binary-tree-inorder-traversal/ | Recursive approach: Helper function inorder(node, list). Base case: if node is null, return. Recursively call inorder(node.left, list), then add node.val to the list, then recursively call inorder(node.right, list). Iterative uses a Stack. | Standard recursive inorder traversal (Left-Root-Right). | Tree Traversal (DFS) | O(n) | O(n) (recursion stack / explicit stack) | `inorder(node.left, result); result.add(node.val); inorder(node.right, result);` |
| 18 | Validate Binary Search Tree | 98 | https://leetcode.com/problems/validate-binary-search-tree/ | Recursive approach: Pass down valid range (min, max) for each node. For a node, check if node.val > min and node.val < max. Recursively call for left child with range (min, node.val) and right child with range (node.val, max). | Recursive check passing valid range [min, max] down. | Tree Traversal (DFS) | O(n) | O(n) (recursion stack) | `return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);` |
| 19 | Binary Tree Level Order Traversal | 102 | https://leetcode.com/problems/binary-tree-level-order-traversal/ | Use Breadth-First Search (BFS) with a Queue. Initialize queue with root. While queue is not empty, get the size (levelSize). Process levelSize nodes: dequeue node, add its value to current level list, enqueue its non-null children. Add level list to result. | BFS using a queue to process nodes level by level. | Tree Traversal (BFS) | O(n) | O(w) (where w is max width of tree/queue size) | `int levelSize = queue.size(); List<Integer> currentLevel = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); ... queue.offer(child); }` |
| 20 | Serialize and Deserialize Binary Tree | 297 | https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ | Serialization (e.g., Preorder): Use DFS. Append node value to string/builder. If null, append a marker (e.g., 'null' or '#'). Recursively serialize left and right. Deserialization: Use a Queue/Iterator of the split serialized string. Build tree recursively. Read value, if marker, return null. Create node, recursively build left, then right. | Use Preorder/Level Order traversal with null markers for serialization. Rebuild recursively/iteratively during deserialization. | Tree Traversal (DFS/BFS) | O(n) | O(n) | `// Serialize (Preorder) sb.append(node.val).append(','); serializeHelper(node.left, sb); serializeHelper(node.right, sb); // Deserialize (Preorder) String val = nodes.poll(); if (val.equals("#")) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(nodes); node.right = deserializeHelper(nodes);` |
| 21 | Coin Change | 322 | https://leetcode.com/problems/coin-change/ | DP with Memoization. memo[amount] stores min coins for that amount. Base case: memo[0]=0. Recursive step: memo[amount] = 1 + min(solve(amount - coin)) for each coin c <= amount. Initialize memo with -1 (uncomputed) or Integer.MAX_VALUE. | DP state memo[i] = min coins for amount i. Check for Integer.MAX_VALUE to handle impossible cases. | Dynamic Programming | O(amount * coins) | O(amount) | `if (memo[rem] != -1) return memo[rem]; int minCoins = Integer.MAX_VALUE; for (int coin : coins) { if (rem >= coin) { int res = solve(rem - coin); if (res != Integer.MAX_VALUE) minCoins = Math.min(minCoins, 1 + res); } } memo[rem] = minCoins;` |
| 22 | Find Minimum in Rotated Sorted Array | 153 | https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ | Modified Binary Search. Compare nums[mid] with nums[high]. If nums[mid] < nums[high], the minimum is in the left half (including mid), so high = mid. Otherwise, the minimum is in the right half (mid + 1), so low = mid + 1. Loop ends when low == high. | Compare mid with high to decide which half contains the pivot/minimum. | Binary Search | O(log n) | O(1) | `if (nums[mid] < nums[high]) { high = mid; } else { low = mid + 1; }` |
| 23 | Course Schedule | 207 | https://leetcode.com/problems/course-schedule/ | Topological Sort using Kahn's Algorithm (BFS). Build adjacency list and calculate in-degrees. Initialize queue with nodes having in-degree 0. Process queue: dequeue node, decrement in-degree of neighbors. If neighbor's in-degree becomes 0, enqueue it. Count processed nodes; if count equals numCourses, return true. | Kahn's Algorithm (BFS + in-degree counting) for cycle detection. | Graph / Topological Sort | O(V+E) | O(V+E) (for adjacency list and in-degrees) | `Queue<Integer> queue = new LinkedList<>(); // Add nodes with inDegree 0 while (!queue.isEmpty()) { int course = queue.poll(); count++; for (int neighbor : adj.get(course)) { if (--inDegree[neighbor] == 0) queue.offer(neighbor); } } return count == numCourses;` |
| 24 | Word Ladder | 127 | https://leetcode.com/problems/word-ladder/ | BFS on implicit graph. Start BFS from beginWord. Each level represents one transformation. Use a Set for wordList for O(1) lookup and a Set for visited words. In each step, generate all possible 1-letter transformations of the current word. If a transformation is in wordList and not visited, add to queue and mark visited. | BFS for shortest path in unweighted graph. Generate neighbors by changing one char at a time. | Graph / BFS | O(N * M^2) (N=wordList size, M=word length) | O(N*M) (for word set and visited set/queue) | `for (int i = 0; i < word.length(); i++) { char[] chars = word.toCharArray(); for (char c = 'a'; c <= 'z'; c++) { chars[i] = c; String neighbor = new String(chars); if (wordSet.contains(neighbor) && !visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } }` |
| 25 | Group Anagrams | 49 | https://leetcode.com/problems/group-anagrams/ | Use a HashMap where the key represents the character count/sorted version of a string, and the value is a list of anagrams. Iterate through strs, generate the key for each string (e.g., sort the string or create a count array string like 'a1b1c0...'), and add the original string to the list associated with that key. | Canonical representation (sorted string or char count) as HashMap key. | Hash Map | O(N * K log K) or O(N*K) (N=num strings, K=max length) | O(N*K) (for storing anagram groups) | `char[] ca = str.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);` |
| 26 | Valid Parentheses | 20 | https://leetcode.com/problems/valid-parentheses/ | Use a Stack. Iterate through the string. If an opening bracket ('(', '{', '[') is encountered, push it onto the stack. If a closing bracket is found, check if the stack is empty or if the top element is the corresponding opening bracket. If not, return false. Pop if it matches. After iteration, the stack must be empty. | Stack to match opening/closing brackets LIFO order. | Stack | O(n) | O(n) | `if (c == '(' || c == '{' || c == '[') stack.push(c); else if (stack.isEmpty() || !isMatching(stack.pop(), c)) return false;` |
| 27 | Combination Sum | 39 | https://leetcode.com/problems/combination-sum/ | Backtracking/DFS. Define a recursive function findCombinations(index, currentSum, currentList). Base cases: if currentSum == target, add currentList to results. If currentSum > target or index >= candidates.length, return. Recursive step: Include candidates[index] (call findCombinations(index, ..., ...) again) and Exclude candidates[index] (call findCombinations(index + 1, ..., ...)). | Standard backtracking allowing element reuse. | Backtracking / Recursion | O(N^(T/M)) (approx, N=candidates, T=target, M=min candidate) | O(T/M) (recursion depth) + O(Result Size) | `// Include candidate[i] currentList.add(candidates[i]); backtrack(result, currentList, candidates, remaining - candidates[i], i); // crucial: pass i not i+1 currentList.remove(currentList.size() - 1); // Backtrack` |
| 28 | Permutations | 46 | https://leetcode.com/problems/permutations/ | Backtracking/DFS. Use a boolean used array or swap elements. Define backtrack(currentPermutation). Base case: if currentPermutation.size() == nums.length, add to results. Loop through nums: if nums[i] is not used, add it to currentPermutation, mark as used, recurse (backtrack(...)), unmark, remove from currentPermutation. | Backtracking with mechanism (visited array/swapping) to track used elements. | Backtracking / Recursion | O(N * N!) | O(N) (recursion depth) + O(N * N!) (result storage) | `if (tempList.size() == nums.length) { result.add(new ArrayList<>(tempList)); } else { for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; tempList.add(nums[i]); backtrack(result, tempList, nums, used); tempList.remove(tempList.size() - 1); used[i] = false; } }` |
| 29 | Word Search | 79 | https://leetcode.com/problems/word-search/ | Backtracking/DFS. Iterate through each cell as a potential starting point. Call DFS helper search(r, c, index). Base case: index == word.length(), return true. Check bounds, if board[r][c] != word.charAt(index), return false. Mark current cell (e.g., board[r][c] = '#'). Explore 4 neighbors recursively search(nr, nc, index + 1). If any returns true, return true. Unmark cell (backtrack) board[r][c] = originalChar. Return false if no path found. | DFS with backtracking (marking visited path). | Backtracking / DFS | O(N * M * 4^L) (N, M=dims, L=word length) | O(L) (recursion depth) | `char temp = board[r][c]; board[r][c] = '#'; // Mark visited boolean found = dfs(board, r+1, c, word, index+1) || dfs(board, r-1, c, word, index+1) || dfs(board, r, c+1, word, index+1) || dfs(board, r, c-1, word, index+1); board[r][c] = temp; // Backtrack` |
| 30 | Sudoku Solver | 37 | https://leetcode.com/problems/sudoku-solver/ | Backtracking. Find the next empty cell ('.'). Try filling it with digits '1' through '9'. For each digit, check if it's valid (using helper isValid(row, col, digit) checking row, col, and 3x3 subgrid). If valid, place digit and recursively call solve(). If recursive call returns true, return true. If not, backtrack (reset cell to '.'). If no digit works for the cell, return false. Base case: no empty cells found, return true. | Backtracking search trying digits 1-9 in empty cells, pruning invalid states. | Backtracking / Recursion | O(9^(N*N)) (with pruning, much faster in practice) | O(N*N) (recursion depth/board state) | `for (char c = '1'; c <= '9'; c++) { if (isValid(board, row, col, c)) { board[row][col] = c; if (solve(board)) return true; board[row][col] = '.'; // Backtrack } } return false;` |
