| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 1 | Two Sum | 1 | https://leetcode.com/problems/two-sum/ | Use a HashMap to store encountered numbers and their indices. For each element nums[i], check if target - nums[i] (the complement) exists in the map. If yes, return indices. If no, add nums[i] and its index to the map. | HashMap for O(1) complement lookup. | Hash Map | O(n) | O(n) | `if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i);` |
| 2 | Longest Substring Without Repeating Characters | 3 | https://leetcode.com/problems/longest-substring-without-repeating-characters/ | Use a sliding window approach with two pointers (start, end) and a Set/Map to track characters within the window [start, end). Expand end. If s.charAt(end) is in the set, shrink the window by incrementing start and removing s.charAt(start) from the set until the duplicate is removed. Update max length. | Sliding window with Set/Map for efficient duplicate checks. | Sliding Window | O(n) | O(min(n, m)) (where m is alphabet size) | `if (set.contains(s.charAt(end))) { set.remove(s.charAt(start++)); } else { set.add(s.charAt(end++)); maxLen = Math.max(maxLen, end - start); }` |
| 3 | Median of Two Sorted Arrays | 4 | https://leetcode.com/problems/median-of-two-sorted-arrays/ | Use binary search on the smaller array to find the correct partition point partitionX. Calculate the corresponding partition partitionY in the other array such that partitionX + partitionY = (n+m+1)/2. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. Adjust binary search range based on comparison. | Binary search on partitions to find median in logarithmic time. | Binary Search | O(log(min(n, m))) | O(1) | `if (maxLeftX <= minRightY && maxLeftY <= minRightX) { // Found partition } else if (maxLeftX > minRightY) { high = partitionX - 1; } else { low = partitionX + 1; }` |
| 4 | Maximum Subarray | 53 | https://leetcode.com/problems/maximum-subarray/ | Kadane's Algorithm: Iterate through the array, maintaining currentMax (max sum ending at current position) and globalMax (max sum found so far). currentMax = max(num, currentMax + num). Update globalMax = max(globalMax, currentMax). | Kadane's: Discard subarray prefix if its sum becomes negative. | Dynamic Programming / Greedy | O(n) | O(1) | `currentMax = Math.max(num, currentMax + num); globalMax = Math.max(globalMax, currentMax);` |
| 5 | Merge Intervals | 56 | https://leetcode.com/problems/merge-intervals/ | Sort intervals based on start times. Iterate through sorted intervals, merging overlapping ones. If the current interval overlaps with the last merged interval in the result list (current.start <= last.end), update the end of the last interval (last.end = max(last.end, current.end)). Otherwise, add the current interval as a new entry. | Sort by start then merge greedily. | Sorting / Greedy | O(n log n) | O(n) (for result list) or O(log n) (for sort) | `if (merged.isEmpty() || current.start > merged.get(merged.size() - 1).end) { merged.add(current); } else { merged.get(merged.size() - 1).end = Math.max(merged.get(merged.size() - 1).end, current.end); }` |
| 6 | Reverse Linked List | 206 | https://leetcode.com/problems/reverse-linked-list/ | Iterative approach: Use three pointers: prev (initially null), curr (initially head), and nextTemp. While curr is not null, store curr.next in nextTemp, set curr.next to prev, update prev to curr, and move curr to nextTemp. | Iterative reversal using three pointers (prev, curr, next). | Linked List | O(n) | O(1) | `ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp;` |
| 7 | LRU Cache | 146 | https://leetcode.com/problems/lru-cache/ | Use a HashMap for O(1) key lookup and a Doubly Linked List (DLL) to maintain the order of usage. Map keys to DLL nodes. On get or put (update), move the accessed node to the front of the DLL. On put when capacity is reached, remove the node from the tail of the DLL and the corresponding entry from the map. | HashMap + Doubly Linked List for O(1) get/put. | Hash Map / Doubly Linked List | O(1) for get and put | O(capacity) | `// On access (get/put): removeNode(node); addToFront(node); // On put full: Node tail = removeTail(); map.remove(tail.key);` |
| 8 | Generate Parentheses | 22 | https://leetcode.com/problems/generate-parentheses/ | Use backtracking (recursive approach). Maintain counts of open and close parentheses used. Add '(' if open < n. Add ')' if close < open. Base case: if length is 2*n, add the string to the result list. | Backtracking with constraints on open/close counts. | Backtracking / Recursion | O(4^n / (n^(3/2))) (Catalan Number) | O(n) (recursion stack) + O(n * 4^n / (n^(3/2))) (result storage) | `if (open < max) backtrack(list, str + '(', open + 1, close, max); if (close < open) backtrack(list, str + ')', open, close + 1, max);` |
| 9 | Lowest Common Ancestor of a Binary Tree | 236 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ | Recursive approach. Base cases: If root is null, p, or q, return root. Recursively find LCA in left and right subtrees (leftLCA, rightLCA). If both are non-null, current root is LCA. If only one is non-null, return that one. If both are null, return null. | Recursive search; LCA is the node where paths to p and q diverge. | Tree / Recursion / DFS | O(n) | O(n) (worst case, skewed tree) O(h) (average, height) | `ListNode leftLCA = lowestCommonAncestor(root.left, p, q); ListNode rightLCA = lowestCommonAncestor(root.right, p, q); if (leftLCA != null && rightLCA != null) return root; return (leftLCA != null) ? leftLCA : rightLCA;` |
| 10 | Longest Increasing Subsequence | 300 | https://leetcode.com/problems/longest-increasing-subsequence/ | DP with Memoization: Define dp[i] as the LIS ending at index i. To compute dp[i], iterate j from 0 to i-1. If nums[i] > nums[j], then dp[i] = max(dp[i], 1 + dp[j]). Alternatively, O(n log n) approach using patience sorting (maintain tails of potential LIS). | DP state dp[i] = LIS length ending at i. (Or O(n log n) patience sort). | Dynamic Programming | O(n^2) for basic DP, O(n log n) optimized | O(n) | `for (int j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } maxLength = Math.max(maxLength, dp[i]);` (for O(n^2) DP) |
| 11 | Search in Rotated Sorted Array | 33 | https://leetcode.com/problems/search-in-rotated-sorted-array/ | Modified Binary Search. Find the pivot point (minimum element) first OR directly adapt binary search. In each step, determine which half (left or right of mid) is sorted. Check if the target lies within the sorted half's range. Adjust low and high accordingly. | Modified binary search adapting to the rotation point. | Binary Search | O(log n) | O(1) | `if (nums[low] <= nums[mid]) { // Left half sorted if (target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; } else { // Right half sorted ... }` |
| 12 | Number of Islands | 200 | https://leetcode.com/problems/number-of-islands/ | Iterate through the grid. If a cell contains '1' and hasn't been visited, increment the island count and start a DFS or BFS from that cell to mark all connected '1's as visited (e.g., change '1' to '0' or use a separate visited array). | DFS/BFS traversal to explore and mark connected land cells. | Graph Traversal (DFS/BFS) | O(m*n) | O(m*n) (recursion stack for DFS or queue/visited array for BFS) | `if (grid[r][c] == '1') { count++; dfs(grid, r, c); // or bfs } // dfs(grid, r, c): mark grid[r][c] = '0'; explore neighbors` |
| 13 | Container With Most Water | 11 | https://leetcode.com/problems/container-with-most-water/ | Use two pointers, left at index 0 and right at index n-1. Calculate area min(height[left], height[right]) * (right - left). Update max area. Move the pointer pointing to the shorter line inward (left++ if height[left] < height[right], else right--). | Two pointers: move the shorter height pointer inward. | Two Pointers | O(n) | O(1) | `area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--;` |
| 14 | Trapping Rain Water | 42 | https://leetcode.com/problems/trapping-rain-water/ | Calculate maxLeft[i] (max height to the left of i) and maxRight[i] (max height to the right of i) for all i. The water trapped at index i is max(0, min(maxLeft[i], maxRight[i]) - height[i]). Sum these amounts. Can be optimized to O(1) space using two pointers. | Water at i depends on min(max_left, max_right) - height[i]. | Dynamic Programming / Two Pointers | O(n) | O(n) (for DP arrays) or O(1) (for Two Pointer) | `water += Math.max(0, Math.min(maxLeft[i], maxRight[i]) - height[i]); // DP <br> // Two Pointer: if (leftMax < rightMax) { water += leftMax - height[left]; left++; } else { water += rightMax - height[right]; right--; }` |
| 15 | Merge Two Sorted Lists | 21 | https://leetcode.com/problems/merge-two-sorted-lists/ | Iterative approach: Use a dummy head node. Maintain a current pointer for the merged list. Compare heads of list1 and list2. Append the smaller node to current.next and advance that list's pointer. Update current. After loop, append the remaining non-null list. | Dummy head node simplifies merging logic. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode dummy = new ListNode(0); ListNode current = dummy; ... if (list1.val <= list2.val) { current.next = list1; list1 = list1.next; } else { current.next = list2; list2 = list2.next; } current = current.next; ... return dummy.next;` |
| 16 | Add Two Numbers | 2 | https://leetcode.com/problems/add-two-numbers/ | Iterate through both lists simultaneously using a dummy head for the result list. Keep track of carry. At each step, calculate sum = l1.val + l2.val + carry. The digit for the new node is sum % 10, and the new carry is sum / 10. Handle remaining nodes and final carry. | Simulate elementary addition with carry using linked lists. | Linked List / Simulation | O(max(n, m)) | O(max(n, m)) (for result list) | `int sum = carry + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); carry = sum / 10; curr.next = new ListNode(sum % 10); ...` |
| 17 | Binary Tree Inorder Traversal | 94 | https://leetcode.com/problems/binary-tree-inorder-traversal/ | Recursive approach: Helper function inorder(node, list). Base case: if node is null, return. Recursively call inorder(node.left, list), then add node.val to the list, then recursively call inorder(node.right, list). Iterative uses a Stack. | Standard recursive inorder traversal (Left-Root-Right). | Tree Traversal (DFS) | O(n) | O(n) (recursion stack / explicit stack) | `inorder(node.left, result); result.add(node.val); inorder(node.right, result);` |
| 18 | Validate Binary Search Tree | 98 | https://leetcode.com/problems/validate-binary-search-tree/ | Recursive approach: Pass down valid range (min, max) for each node. For a node, check if node.val > min and node.val < max. Recursively call for left child with range (min, node.val) and right child with range (node.val, max). | Recursive check passing valid range [min, max] down. | Tree Traversal (DFS) | O(n) | O(n) (recursion stack) | `return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);` |
| 19 | Binary Tree Level Order Traversal | 102 | https://leetcode.com/problems/binary-tree-level-order-traversal/ | Use Breadth-First Search (BFS) with a Queue. Initialize queue with root. While queue is not empty, get the size (levelSize). Process levelSize nodes: dequeue node, add its value to current level list, enqueue its non-null children. Add level list to result. | BFS using a queue to process nodes level by level. | Tree Traversal (BFS) | O(n) | O(w) (where w is max width of tree/queue size) | `int levelSize = queue.size(); List<Integer> currentLevel = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); ... queue.offer(child); }` |
| 20 | Serialize and Deserialize Binary Tree | 297 | https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ | Serialization (e.g., Preorder): Use DFS. Append node value to string/builder. If null, append a marker (e.g., 'null' or '#'). Recursively serialize left and right. Deserialization: Use a Queue/Iterator of the split serialized string. Build tree recursively. Read value, if marker, return null. Create node, recursively build left, then right. | Use Preorder/Level Order traversal with null markers for serialization. Rebuild recursively/iteratively during deserialization. | Tree Traversal (DFS/BFS) | O(n) | O(n) | `// Serialize (Preorder) sb.append(node.val).append(','); serializeHelper(node.left, sb); serializeHelper(node.right, sb); // Deserialize (Preorder) String val = nodes.poll(); if (val.equals("#")) return null; TreeNode node = new TreeNode(Integer.parseInt(val)); node.left = deserializeHelper(nodes); node.right = deserializeHelper(nodes);` |
| 21 | Coin Change | 322 | https://leetcode.com/problems/coin-change/ | DP with Memoization. memo[amount] stores min coins for that amount. Base case: memo[0]=0. Recursive step: memo[amount] = 1 + min(solve(amount - coin)) for each coin c <= amount. Initialize memo with -1 (uncomputed) or Integer.MAX_VALUE. | DP state memo[i] = min coins for amount i. Check for Integer.MAX_VALUE to handle impossible cases. | Dynamic Programming | O(amount * coins) | O(amount) | `if (memo[rem] != -1) return memo[rem]; int minCoins = Integer.MAX_VALUE; for (int coin : coins) { if (rem >= coin) { int res = solve(rem - coin); if (res != Integer.MAX_VALUE) minCoins = Math.min(minCoins, 1 + res); } } memo[rem] = minCoins;` |
| 22 | Find Minimum in Rotated Sorted Array | 153 | https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ | Modified Binary Search. Compare nums[mid] with nums[high]. If nums[mid] < nums[high], the minimum is in the left half (including mid), so high = mid. Otherwise, the minimum is in the right half (mid + 1), so low = mid + 1. Loop ends when low == high. | Compare mid with high to decide which half contains the pivot/minimum. | Binary Search | O(log n) | O(1) | `if (nums[mid] < nums[high]) { high = mid; } else { low = mid + 1; }` |
| 23 | Course Schedule | 207 | https://leetcode.com/problems/course-schedule/ | Topological Sort using Kahn's Algorithm (BFS). Build adjacency list and calculate in-degrees. Initialize queue with nodes having in-degree 0. Process queue: dequeue node, decrement in-degree of neighbors. If neighbor's in-degree becomes 0, enqueue it. Count processed nodes; if count equals numCourses, return true. | Kahn's Algorithm (BFS + in-degree counting) for cycle detection. | Graph / Topological Sort | O(V+E) | O(V+E) (for adjacency list and in-degrees) | `Queue<Integer> queue = new LinkedList<>(); // Add nodes with inDegree 0 while (!queue.isEmpty()) { int course = queue.poll(); count++; for (int neighbor : adj.get(course)) { if (--inDegree[neighbor] == 0) queue.offer(neighbor); } } return count == numCourses;` |
| 24 | Word Ladder | 127 | https://leetcode.com/problems/word-ladder/ | BFS on implicit graph. Start BFS from beginWord. Each level represents one transformation. Use a Set for wordList for O(1) lookup and a Set for visited words. In each step, generate all possible 1-letter transformations of the current word. If a transformation is in wordList and not visited, add to queue and mark visited. | BFS for shortest path in unweighted graph. Generate neighbors by changing one char at a time. | Graph / BFS | O(N * M^2) (N=wordList size, M=word length) | O(N*M) (for word set and visited set/queue) | `for (int i = 0; i < word.length(); i++) { char[] chars = word.toCharArray(); for (char c = 'a'; c <= 'z'; c++) { chars[i] = c; String neighbor = new String(chars); if (wordSet.contains(neighbor) && !visited.contains(neighbor)) { queue.offer(neighbor); visited.add(neighbor); } } }` |
| 25 | Group Anagrams | 49 | https://leetcode.com/problems/group-anagrams/ | Use a HashMap where the key represents the character count/sorted version of a string, and the value is a list of anagrams. Iterate through strs, generate the key for each string (e.g., sort the string or create a count array string like 'a1b1c0...'), and add the original string to the list associated with that key. | Canonical representation (sorted string or char count) as HashMap key. | Hash Map | O(N * K log K) or O(N*K) (N=num strings, K=max length) | O(N*K) (for storing anagram groups) | `char[] ca = str.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);` |
| 26 | Valid Parentheses | 20 | https://leetcode.com/problems/valid-parentheses/ | Use a Stack. Iterate through the string. If an opening bracket ('(', '{', '[') is encountered, push it onto the stack. If a closing bracket is found, check if the stack is empty or if the top element is the corresponding opening bracket. If not, return false. Pop if it matches. After iteration, the stack must be empty. | Stack to match opening/closing brackets LIFO order. | Stack | O(n) | O(n) | `if (c == '(' || c == '{' || c == '[') stack.push(c); else if (stack.isEmpty() || !isMatching(stack.pop(), c)) return false;` |
| 27 | Combination Sum | 39 | https://leetcode.com/problems/combination-sum/ | Backtracking/DFS. Define a recursive function findCombinations(index, currentSum, currentList). Base cases: if currentSum == target, add currentList to results. If currentSum > target or index >= candidates.length, return. Recursive step: Include candidates[index] (call findCombinations(index, ..., ...) again) and Exclude candidates[index] (call findCombinations(index + 1, ..., ...)). | Standard backtracking allowing element reuse. | Backtracking / Recursion | O(N^(T/M)) (approx, N=candidates, T=target, M=min candidate) | O(T/M) (recursion depth) + O(Result Size) | `// Include candidate[i] currentList.add(candidates[i]); backtrack(result, currentList, candidates, remaining - candidates[i], i); // crucial: pass i not i+1 currentList.remove(currentList.size() - 1); // Backtrack` |
| 28 | Permutations | 46 | https://leetcode.com/problems/permutations/ | Backtracking/DFS. Use a boolean used array or swap elements. Define backtrack(currentPermutation). Base case: if currentPermutation.size() == nums.length, add to results. Loop through nums: if nums[i] is not used, add it to currentPermutation, mark as used, recurse (backtrack(...)), unmark, remove from currentPermutation. | Backtracking with mechanism (visited array/swapping) to track used elements. | Backtracking / Recursion | O(N * N!) | O(N) (recursion depth) + O(N * N!) (result storage) | `if (tempList.size() == nums.length) { result.add(new ArrayList<>(tempList)); } else { for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; tempList.add(nums[i]); backtrack(result, tempList, nums, used); tempList.remove(tempList.size() - 1); used[i] = false; } }` |
| 29 | Word Search | 79 | https://leetcode.com/problems/word-search/ | Backtracking/DFS. Iterate through each cell as a potential starting point. Call DFS helper search(r, c, index). Base case: index == word.length(), return true. Check bounds, if board[r][c] != word.charAt(index), return false. Mark current cell (e.g., board[r][c] = '#'). Explore 4 neighbors recursively search(nr, nc, index + 1). If any returns true, return true. Unmark cell (backtrack) board[r][c] = originalChar. Return false if no path found. | DFS with backtracking (marking visited path). | Backtracking / DFS | O(N * M * 4^L) (N, M=dims, L=word length) | O(L) (recursion depth) | `char temp = board[r][c]; board[r][c] = '#'; // Mark visited boolean found = dfs(board, r+1, c, word, index+1) || dfs(board, r-1, c, word, index+1) || dfs(board, r, c+1, word, index+1) || dfs(board, r, c-1, word, index+1); board[r][c] = temp; // Backtrack` |
| 30 | Sudoku Solver | 37 | https://leetcode.com/problems/sudoku-solver/ | Backtracking. Find the next empty cell ('.'). Try filling it with digits '1' through '9'. For each digit, check if it's valid (using helper isValid(row, col, digit) checking row, col, and 3x3 subgrid). If valid, place digit and recursively call solve(). If recursive call returns true, return true. If not, backtrack (reset cell to '.'). If no digit works for the cell, return false. Base case: no empty cells found, return true. | Backtracking search trying digits 1-9 in empty cells, pruning invalid states. | Backtracking / Recursion | O(9^(N*N)) (with pruning, much faster in practice) | O(N*N) (recursion depth/board state) | `for (char c = '1'; c <= '9'; c++) { if (isValid(board, row, col, c)) { board[row][col] = c; if (solve(board)) return true; board[row][col] = '.'; // Backtrack } } return false;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 32 | Minimum Window Substring | 76 | https://leetcode.com/problems/minimum-window-substring/ | Sliding Window with Frequency Maps. Use two HashMaps (or arrays) `tFreq` for pattern `t` and `windowFreq` for current window in `s`. Use `required` count (distinct chars in `t`) and `formed` count (distinct chars in window matching `required` count). Expand `end` pointer, update `windowFreq` and `formed`. When `formed == required`, shrink `start` pointer, update window, check if still valid (`formed == required`), and update min window. | Sliding window with two pointers and frequency maps to track character counts. | Sliding Window / Hash Map | O(\|S\| + \|T\|) | O(\|T\|) or O(alphabet size) | `while (formed == required) { // Shrink window updateMinWindow(...); char leftChar = s.charAt(start); windowFreq[leftChar]--; if (tFreq.containsKey(leftChar) && windowFreq[leftChar] < tFreq.get(leftChar)) { formed--; } start++; }` |
| 33 | 3Sum | 15 | https://leetcode.com/problems/3sum/ | Sort the array. Iterate through the array with index `i` from 0 to n-3. For each `nums[i]`, use two pointers `left = i + 1` and `right = n - 1`. Calculate `sum = nums[i] + nums[left] + nums[right]`. If `sum == 0`, add `[nums[i], nums[left], nums[right]]` to result, increment `left`, decrement `right`, and skip duplicates. If `sum < 0`, `left++`. If `sum > 0`, `right--`. Skip duplicates for `i` as well. | Sort + Two Pointers approach after fixing one element. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) depending on sort | `while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) { result.add(Arrays.asList(nums[i], nums[left], nums[right])); while (left < right && nums[left] == nums[left+1]) left++; // Skip duplicates while (left < right && nums[right] == nums[right-1]) right--; left++; right--; } else if (sum < 0) left++; else right--; }` |
| 34 | Merge k Sorted Lists | 23 | https://leetcode.com/problems/merge-k-sorted-lists/ | Use a Min-Heap (PriorityQueue) to store the head nodes of the k lists, ordered by value. Repeatedly extract the minimum node from the heap, add it to the result list (using a dummy head), and if the extracted node has a `next`, add `next` to the heap. | Min-Heap to efficiently find the smallest current element across k lists. | Heap (Priority Queue) | O(N log k) N=total nodes, k=lists | O(k) for heap, O(N) for result list | `PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a.val)); for (ListNode node : lists) { if (node != null) pq.offer(node); } while (!pq.isEmpty()) { ListNode minNode = pq.poll(); current.next = minNode; current = current.next; if (minNode.next != null) pq.offer(minNode.next); }` |
| 35 | Construct Binary Tree from Preorder and Inorder Traversal | 105 | https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ | Recursive approach. Use preorder to identify the root (`preorder[preStart]`). Find the root's index (`inIndex`) in the inorder traversal (use a HashMap for O(1) lookup). Elements left of `inIndex` in inorder form the left subtree, elements right form the right subtree. Recursively build left subtree using `preorder[preStart+1 ...]` and `inorder[inStart ... inIndex-1]`. Recursively build right subtree using remaining preorder and `inorder[inIndex+1 ... inEnd]`. | Preorder gives root, Inorder splits left/right subtrees. HashMap for Inorder lookup. | Tree / Recursion / DFS / Hash Map | O(N) | O(N) for map and recursion stack | `int rootVal = preorder[preStart]; TreeNode root = new TreeNode(rootVal); int inIndex = map.get(rootVal); int leftSize = inIndex - inStart; root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, inorder, inStart, inIndex - 1, map); root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, inorder, inIndex + 1, inEnd, map);` |
| 36 | Longest Palindromic Substring | 5 | https://leetcode.com/problems/longest-palindromic-substring/ | Expand Around Center approach. Iterate through the string, considering each character `i` and each pair `(i, i+1)` as potential centers of a palindrome. For each center, expand outwards (`left--`, `right++`) while `s.charAt(left) == s.charAt(right)`. Keep track of the longest palindrome found. | Expand from center (odd and even length palindromes). | String / Dynamic Programming / Two Pointers | O(n^2) | O(1) | `for (int i = 0; i < s.length(); i++) { expandAroundCenter(s, i, i); // Odd length expandAroundCenter(s, i, i + 1); // Even length } // expandAroundCenter updates global start/maxLength` |
| 37 | Contains Duplicate | 217 | https://leetcode.com/problems/contains-duplicate/ | Use a HashSet. Iterate through the array `nums`. For each number, try to add it to the set. If `set.add(num)` returns `false`, it means the number is already in the set, so return `true`. If the loop finishes without finding duplicates, return `false`. | HashSet for O(1) average time duplicate checking. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) { if (!set.add(num)) return true; } return false;` |
| 38 | Longest Repeating Character Replacement | 424 | https://leetcode.com/problems/longest-repeating-character-replacement/ | Sliding Window. Maintain a window `[start, end]` and a frequency map (array `int[26]`) of characters in the window. Keep track of the frequency of the most frequent character (`maxFreq`). If `windowSize (end - start + 1) - maxFreq > k`, the window is invalid (too many replacements needed). Shrink the window by incrementing `start` and decrementing the count of `s.charAt(start)`. Update `maxLength` in each step. | Sliding window tracking max frequency and replacements needed. | Sliding Window / Hash Map | O(n) | O(1) (alphabet size 26) | `count[s.charAt(end) - 'A']++; maxFreq = Math.max(maxFreq, count[s.charAt(end) - 'A']); while (end - start + 1 - maxFreq > k) { count[s.charAt(start) - 'A']--; start++; // Note: maxFreq doesn't need explicit decrement here, it corrects itself } maxLength = Math.max(maxLength, end - start + 1);` |
| 39 | Sliding Window Maximum | 239 | https://leetcode.com/problems/sliding-window-maximum/ | Use a Deque (Double-Ended Queue) to store indices of elements in the current window. The deque maintains indices in decreasing order of their corresponding values in `nums`. Before adding a new index `i`, remove indices from the back whose values are less than or equal to `nums[i]`. Remove indices from the front that are out of the window `(deque.peekFirst() <= i - k)`. The maximum element for the window ending at `i` is always `nums[deque.peekFirst()]`. | Monotonic Decreasing Deque to efficiently query max in window. | Sliding Window / Deque | O(n) | O(k) | `while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) { deque.pollLast(); } deque.offerLast(i); if (deque.peekFirst() <= i - k) { deque.pollFirst(); } if (i >= k - 1) { result[i - k + 1] = nums[deque.peekFirst()]; }` |
| 40 | Linked List Cycle II | 142 | https://leetcode.com/problems/linked-list-cycle-ii/ | Floyd's Cycle-Finding Algorithm (Tortoise and Hare). Use two pointers, `slow` moving one step and `fast` moving two steps. If they meet, there's a cycle. To find the start of the cycle, reset `slow` to the head of the list. Then move both `slow` and `fast` (which is at the meeting point) one step at a time. They will meet again at the start of the cycle. | Floyd's algorithm: detect cycle, then find start node by moving one pointer from head and another from meeting point at same speed. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { // Cycle detected slow = head; while (slow != fast) { slow = slow.next; fast = fast.next; } return slow; // Cycle start } } return null;` |
| 42 | Reverse Nodes in k-Group | 25 | https://leetcode.com/problems/reverse-nodes-in-k-group/ | Recursive or Iterative. Iterative: Use a `dummy` head. Find the start (`groupPrev`) and end (`kth`) of a group of k nodes. If `kth` is null, break. Reverse the sublist from `groupPrev.next` to `kth` (using standard list reversal). Connect the previous part (`groupPrev`) to the new head of the reversed group, and connect the tail of the reversed group to the node after `kth`. Update `groupPrev` to the tail of the reversed group. | Reverse sublists of size k and reconnect them carefully. | Linked List | O(n) | O(1) iterative / O(n/k) recursive | `// Inside loop, after finding groupPrev and kth Node groupStart = groupPrev.next; Node groupEnd = kth; Node nextGroupStart = kth.next; // Reverse group from groupStart to groupEnd ... // Reconnect groupPrev.next = reversedHead; groupStart.next = nextGroupStart; // groupStart is now tail groupPrev = groupStart;` |
| 43 | Binary Tree Maximum Path Sum | 124 | https://leetcode.com/problems/binary-tree-maximum-path-sum/ | Recursive DFS approach. Define a helper function `maxGain(node)` that returns the maximum path sum starting at `node` and going downwards (either left or right). Inside `maxGain`, calculate `max(0, maxGain(node.left))` and `max(0, maxGain(node.right))`. Update a global `maxSum` variable with `node.val + leftGain + rightGain`. The function returns `node.val + max(leftGain, rightGain)`. | Recursive helper returns max gain downwards; global variable tracks max path sum possibly including split at node. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int leftGain = Math.max(0, maxGain(node.left)); int rightGain = Math.max(0, maxGain(node.right)); maxSum = Math.max(maxSum, node.val + leftGain + rightGain); // Update global return node.val + Math.max(leftGain, rightGain); // Return max path downwards` |
| 44 | Longest Common Subsequence | 1143 | https://leetcode.com/problems/longest-common-subsequence/ | DP with Memoization. `memo[i][j]` stores LCS length for `text1[i...]` and `text2[j...]`. Base case: if `i` or `j` reaches end, return 0. If `memo[i][j]` computed, return it. If `text1.charAt(i) == text2.charAt(j)`, result is `1 + solve(i+1, j+1)`. Otherwise, result is `max(solve(i+1, j), solve(i, j+1))`. Store and return result. | DP state `memo[i][j]` = LCS of suffixes starting at i,j. | Dynamic Programming | O(m*n) | O(m*n) | `if (memo[i][j] != null) return memo[i][j]; if (text1.charAt(i) == text2.charAt(j)) { memo[i][j] = 1 + solve(i + 1, j + 1, text1, text2, memo); } else { memo[i][j] = Math.max(solve(i + 1, j, text1, text2, memo), solve(i, j + 1, text1, text2, memo)); } return memo[i][j];` |
| 45 | Edit Distance | 72 | https://leetcode.com/problems/edit-distance/ | DP with Memoization. `memo[i][j]` stores min distance between `word1[i...]` and `word2[j...]`. Base cases: if `i` reaches end, return `len2 - j`; if `j` reaches end, return `len1 - i`. If `memo[i][j]` computed, return. If `word1[i] == word2[j]`, result is `solve(i+1, j+1)`. Otherwise, result is `1 + min(solve(i+1, j), solve(i, j+1), solve(i+1, j+1))` (delete, insert, replace). | DP state `memo[i][j]` = edit distance for suffixes. Consider match/replace, delete, insert options. | Dynamic Programming | O(m*n) | O(m*n) | `if (word1.charAt(i) == word2.charAt(j)) { memo[i][j] = solve(i + 1, j + 1, word1, word2, memo); } else { int delete = solve(i + 1, j, word1, word2, memo); int insert = solve(i, j + 1, word1, word2, memo); int replace = solve(i + 1, j + 1, word1, word2, memo); memo[i][j] = 1 + Math.min(delete, Math.min(insert, replace)); }` |
| 46 | Word Break | 139 | https://leetcode.com/problems/word-break/ | DP with Memoization. `memo[i]` stores whether `s[i...]` can be segmented. `memo` can be Boolean or Integer (0=uncomputed, 1=true, -1=false). Base case: if `i == s.length()`, return true. If `memo[i]` computed, return result. Iterate `j` from `i` to `s.length()-1`. If `s.substring(i, j+1)` is in `wordDict` and `solve(j+1)` returns true, set `memo[i] = true` and return true. If loop finishes, set `memo[i] = false`. | DP state `memo[i]` = can `s[i...]` be broken? Try all prefixes starting at `i`. | Dynamic Programming | O(n*m*k) n=s len, m=dict size, k=word len. Optimised O(n^2*k) or O(n^3) | O(n) | `if (memo[start] != null) return memo[start]; for (int end = start; end < s.length(); end++) { String word = s.substring(start, end + 1); if (wordDict.contains(word) && solve(end + 1, s, wordDict, memo)) { memo[start] = true; return true; } } memo[start] = false;` |
| 47 | Burst Balloons | 312 | https://leetcode.com/problems/burst-balloons/ | DP with Memoization. `memo[left][right]` stores max coins for bursting balloons *between* index `left` and `right` (exclusive). Add 1s at boundaries of `nums`. Iterate `k` from `left+1` to `right-1` representing the *last* balloon to burst in `(left, right)`. Cost is `nums[left]*nums[k]*nums[right] + solve(left, k) + solve(k, right)`. Maximize over `k`. | DP state `memo[l][r]` = max coins in `(l,r)`. Key is iterating the *last* balloon burst in the interval. | Dynamic Programming | O(n^3) | O(n^2) | `if (memo[left][right] > 0) return memo[left][right]; int maxCoins = 0; for (int k = left + 1; k < right; k++) { int coins = nums[left] * nums[k] * nums[right]; coins += solve(left, k, nums, memo) + solve(k, right, nums, memo); maxCoins = Math.max(maxCoins, coins); } memo[left][right] = maxCoins;` |
| 48 | Find First and Last Position of Element in Sorted Array | 34 | https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ | Binary Search twice. One search finds the leftmost index (`low`): if `nums[mid] == target`, potentially keep searching left (`high = mid - 1`), store `mid` as potential answer. Another search finds the rightmost index (`high`): if `nums[mid] == target`, potentially keep searching right (`low = mid + 1`), store `mid`. | Two modified binary searches: one biased left, one biased right. | Binary Search | O(log n) | O(1) | `// Find Leftmost int findBound(int[] nums, int target, boolean isFirst) { // ... inside BS loop if (nums[mid] == target) { index = mid; if (isFirst) high = mid - 1; else low = mid + 1; } //... } left = findBound(nums, target, true); right = findBound(nums, target, false);` |
| 49 | Course Schedule II | 210 | https://leetcode.com/problems/course-schedule-ii/ | Topological Sort (Kahn's or DFS). Kahn's: Same as Course Schedule I, but add dequeued nodes to a result list/array. If final count != numCourses, return empty array. DFS: Use 3 states (visiting, visited). Perform DFS. Add node to result list *after* visiting all neighbors (post-order). Reverse the result list. Detect cycles using 'visiting' state. | Topological sort storing the order. Return empty array if cycle detected. | Graph / Topological Sort | O(V+E) | O(V+E) | `// Kahn's: Add to result list after dequeuing // DFS: Add node to head of list/stack in post-order visit. Detect cycle with VISITING state. List<Integer> result = new ArrayList<>(); // Kahn's // ... add to queue, process ... result.add(course); // Add node after processing it // ... return result.stream().mapToInt(i->i).toArray(); // if count == numCourses` |
| 50 | Implement Trie (Prefix Tree) | 208 | https://leetcode.com/problems/implement-trie-prefix-tree/ | Create a `TrieNode` class containing `children` (e.g., `TrieNode[26]` or `Map<Character, TrieNode>`) and an `isEndOfWord` boolean flag. `insert`: Traverse from root, creating nodes if they don't exist. Mark `isEndOfWord` at the end. `search`: Traverse from root. If path exists and ends with `isEndOfWord`, return true. `startsWith`: Traverse from root. If path exists, return true. | Node-based structure where each node represents a character and path represents prefix/word. | Trie / Design | O(L) for ops, L=word length | O(N*L) total nodes/chars | `class TrieNode { TrieNode[] children = new TrieNode[26]; boolean isEndOfWord; } // Insert: TrieNode curr = root; for (char c : word.toCharArray()) { if (curr.children[c - 'a'] == null) curr.children[c - 'a'] = new TrieNode(); curr = curr.children[c - 'a']; } curr.isEndOfWord = true;` |
| 51 | Rotate Array | 189 | https://leetcode.com/problems/rotate-array/ | Reversal Algorithm: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining `n-k` elements. (Make sure `k = k % n`). This is O(n) time and O(1) space. | Three reversals achieve rotation in-place. | Array Manipulation | O(n) | O(1) | `k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);` |
| 52 | Sort Colors | 75 | https://leetcode.com/problems/sort-colors/ | Dutch National Flag algorithm (3-way partitioning). Use three pointers: `low=0`, `mid=0`, `high=n-1`. While `mid <= high`: If `nums[mid] == 0`, swap `nums[low]` and `nums[mid]`, increment both `low` and `mid`. If `nums[mid] == 1`, increment `mid`. If `nums[mid] == 2`, swap `nums[mid]` and `nums[high]`, decrement `high` (do not increment `mid` as swapped element needs checking). | Dutch National Flag (DNF) algorithm for 3-way partition. | Array / Two Pointers / Sorting | O(n) | O(1) | `while (mid <= high) { if (nums[mid] == 0) { swap(nums, low++, mid++); } else if (nums[mid] == 1) { mid++; } else { swap(nums, mid, high--); } }` |
| 53 | Find All Anagrams in a String | 438 | https://leetcode.com/problems/find-all-anagrams-in-a-string/ | Sliding Window with Character Counts. Maintain two frequency maps (arrays `int[26]`), one for pattern `p` (`pCount`) and one for the current window in `s` (`sCount`). Initialize window of size `p.length()`. Compare `sCount` and `pCount`. Slide the window one step at a time: decrement count for char leaving window, increment count for char entering window. Compare counts at each step. | Sliding window with frequency map comparison. | Sliding Window / Hash Map | O(\|S\|) | O(1) (alphabet size 26) | `int[] pCount = new int[26]; int[] sCount = new int[26]; // Fill pCount, initial sCount for (int i = pLen; i < sLen; i++) { if (Arrays.equals(sCount, pCount)) result.add(i - pLen); sCount[s.charAt(i - pLen) - 'a']--; sCount[s.charAt(i) - 'a']++; } // Final check for last window` |
| 54 | Two Sum II - Input Array Is Sorted | 167 | https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ | Use two pointers, `left` starting at index 0 and `right` starting at index `n-1`. Calculate `sum = numbers[left] + numbers[right]`. If `sum == target`, return `[left + 1, right + 1]`. If `sum < target`, increment `left` to increase the sum. If `sum > target`, decrement `right` to decrease the sum. | Two pointers moving inwards on a sorted array. | Two Pointers | O(n) | O(1) | `while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) { return new int[]{left + 1, right + 1}; } else if (sum < target) { left++; } else { right--; } }` |
| 55 | Reorder List | 143 | https://leetcode.com/problems/reorder-list/ | 1. Find the middle node using slow/fast pointers. 2. Reverse the second half of the list starting from `middle.next`. Set `middle.next = null` to split lists. 3. Merge the first half and the reversed second half: Interleave nodes one by one from each half. | Find Mid -> Reverse 2nd Half -> Merge Alternately. | Linked List / Two Pointers | O(n) | O(1) | `// 1. Find Middle ListNode slow = head, fast = head; //... // 2. Reverse Second Half ListNode secondHead = reverse(slow.next); slow.next = null; // Split // 3. Merge ListNode first = head; while (secondHead != null) { ListNode temp1 = first.next; ListNode temp2 = secondHead.next; first.next = secondHead; secondHead.next = temp1; first = temp1; secondHead = temp2; }` |
| 56 | Sort List | 148 | https://leetcode.com/problems/sort-list/ | Use Merge Sort. Base case: if list is empty or has one node, return it. Find the middle of the list using slow/fast pointers. Split the list into two halves. Recursively sort the left half (`sortList(head)`) and the right half (`sortList(middle)`). Merge the two sorted halves using a standard merge function (like merge two sorted lists). | Merge Sort adapted for Linked Lists. | Linked List / Sorting / Recursion / Merge Sort | O(n log n) | O(log n) recursion stack | `// Find middle ListNode mid = getMid(head); // Split ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); // Merge return merge(left, right);` |
| 57 | Diameter of Binary Tree | 543 | https://leetcode.com/problems/diameter-of-binary-tree/ | Use DFS. Define a helper function `height(node)` that returns the height of the subtree rooted at `node`. Inside this function, recursively calculate `leftHeight = height(node.left)` and `rightHeight = height(node.right)`. The diameter *passing through* `node` is `leftHeight + rightHeight`. Update a global/instance variable `maxDiameter = max(maxDiameter, leftHeight + rightHeight)`. The function `height(node)` returns `1 + max(leftHeight, rightHeight)`. | DFS calculating height; diameter is max(leftHeight + rightHeight) across all nodes. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int maxDiameter = 0; int height(TreeNode node) { if (node == null) return 0; int leftH = height(node.left); int rightH = height(node.right); maxDiameter = Math.max(maxDiameter, leftH + rightH); return 1 + Math.max(leftH, rightH); }` |
| 58 | Kth Smallest Element in a BST | 230 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/ | Inorder Traversal (Recursive or Iterative). Perform an inorder traversal (Left, Root, Right) which visits nodes in ascending order for a BST. Maintain a counter. When the counter reaches `k`, the current node's value is the answer. Iterative using a stack is common. | Inorder traversal visits BST nodes in sorted order. | Tree / BST / Inorder Traversal | O(H + k) avg, O(N) worst | O(H) avg, O(N) worst (stack) | `Stack<TreeNode> stack = new Stack<>(); while (true) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (--k == 0) return root.val; root = root.right; }` |
| 59 | Partition Equal Subset Sum | 416 | https://leetcode.com/problems/partition-equal-subset-sum/ | DP (Memoization). Calculate total sum. If odd, return false. Target sum is `totalSum / 2`. Define `memo[i][s]` = can subset sum `s` be formed using elements up to index `i`. Base cases: `s=0` is true. `i<0` or `s<0` is false. Recurrence: `solve(i-1, s)` (exclude `nums[i]`) OR `solve(i-1, s - nums[i])` (include `nums[i]`). | Reduce to Subset Sum problem with target = totalSum / 2. | Dynamic Programming | O(n * sum) | O(n * sum) | `Boolean[][] memo; boolean solve(int[] nums, int i, int target) { if (target == 0) return true; if (i < 0 || target < 0) return false; if (memo[i][target] != null) return memo[i][target]; boolean include = solve(nums, i - 1, target - nums[i]); boolean exclude = solve(nums, i - 1, target); memo[i][target] = include || exclude; return memo[i][target]; }` |
| 60 | Longest Palindromic Subsequence | 516 | https://leetcode.com/problems/longest-palindromic-subsequence/ | DP with Memoization. `memo[i][j]` stores the length of the LPS for the substring `s[i..j]`. Base case: `memo[i][i] = 1`. If `s.charAt(i) == s.charAt(j)`, then `memo[i][j] = 2 + solve(i+1, j-1)`. If not equal, `memo[i][j] = max(solve(i+1, j), solve(i, j-1))`. | DP state `memo[i][j]` = LPS length in `s[i..j]`. Match ends or take max of subproblems. | Dynamic Programming | O(n^2) | O(n^2) | `Integer[][] memo; int solve(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != null) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) { memo[i][j] = 2 + solve(s, i + 1, j - 1); } else { memo[i][j] = Math.max(solve(s, i + 1, j), solve(s, i, j - 1)); } return memo[i][j]; }` |
| 61 | Palindrome Partitioning | 131 | https://leetcode.com/problems/palindrome-partitioning/ | Backtracking/DFS. Define `backtrack(start, currentList)`. Iterate `end` from `start` to `n-1`. Check if `s.substring(start, end + 1)` is a palindrome. If yes, add it to `currentList`, recurse `backtrack(end + 1, currentList)`, then remove the substring (backtrack). Base case: `start == n`, add `currentList` to results. | Backtracking exploring all partitions, checking palindrome property for each part. | Backtracking / Recursion | O(N * 2^N) | O(N) recursion depth | `for (int end = start; end < s.length(); end++) { if (isPalindrome(s, start, end)) { currentList.add(s.substring(start, end + 1)); backtrack(end + 1, currentList, s, result); currentList.remove(currentList.size() - 1); // Backtrack } }` |
| 62 | Decode Ways | 91 | https://leetcode.com/problems/decode-ways/ | DP with Memoization. `memo[i]` stores ways to decode `s[i...]`. Base case: `memo[n] = 1`. If `s[i] == '0'`, `memo[i] = 0`. One-digit decode: `ways = solve(i+1)`. Two-digit decode: If `i+1 < n` and `s[i..i+1]` is '10'-'26', `ways += solve(i+2)`. Store result in `memo[i]`. | DP state `memo[i]` = ways to decode suffix `s[i...]`. Handle '0' and 1/2 digit checks. | Dynamic Programming | O(n) | O(n) | `if (memo[i] != null) return memo[i]; if (s.charAt(i) == '0') return 0; int ways = solve(i + 1, s, memo); if (i + 1 < s.length()) { int twoDigit = Integer.parseInt(s.substring(i, i + 2)); if (twoDigit >= 10 && twoDigit <= 26) { ways += solve(i + 2, s, memo); } } memo[i] = ways;` |
| 63 | Longest Increasing Path in a Matrix | 329 | https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ | DP (Memoization) + DFS. `memo[r][c]` stores LIP length starting at `(r, c)`. Initialize memo with 0. Iterate through all cells, call DFS if `memo[r][c] == 0`. DFS(r, c): If `memo[r][c] > 0` return it. Calculate `maxPath = 1`. Explore 4 neighbors `(nr, nc)`. If valid and `matrix[nr][nc] > matrix[r][c]`, `maxPath = max(maxPath, 1 + dfs(nr, nc))`. Store `memo[r][c] = maxPath`. | DFS with memoization to avoid recomputing LIP from same cell. | DFS / Dynamic Programming | O(m*n) | O(m*n) | `if (memo[r][c] > 0) return memo[r][c]; int maxLen = 1; for (int[] dir : directions) { int nr = r + dir[0], nc = c + dir[1]; if (/* valid neighbor */ && matrix[nr][nc] > matrix[r][c]) { maxLen = Math.max(maxLen, 1 + dfs(matrix, nr, nc, memo)); } } memo[r][c] = maxLen;` |
| 64 | Pacific Atlantic Water Flow | 417 | https://leetcode.com/problems/pacific-atlantic-water-flow/ | DFS/BFS from both oceans. Create two boolean matrices `pacific` and `atlantic`. Start DFS/BFS from all border cells adjacent to Pacific, mark reachable cells in `pacific`. Do the same for Atlantic border cells and `atlantic` matrix. Iterate through the grid, if `pacific[r][c]` and `atlantic[r][c]` are both true, add `(r, c)` to result. | Start search from ocean boundaries inwards. | DFS / BFS | O(m*n) | O(m*n) | `// dfs(matrix, r, c, visited, prevHeight) for (int i = 0; i < rows; i++) { dfs(matrix, i, 0, pacific, Integer.MIN_VALUE); // Pacific border dfs(matrix, i, cols - 1, atlantic, Integer.MIN_VALUE); // Atlantic border } // ... same for top/bottom borders ... List<List<Integer>> result = new ArrayList<>(); for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) if (pacific[r][c] && atlantic[r][c]) result.add(Arrays.asList(r,c));` |
| 65 | Reconstruct Itinerary | 332 | https://leetcode.com/problems/reconstruct-itinerary/ | Hierholzer's algorithm variation using DFS. Build graph where `adj<String, PriorityQueue<String>>` stores destinations lexicographically. Start DFS from "JFK". In `dfs(airport)`: While neighbors exist, `dfs(neighbor)`. Add `airport` to the front of the result list *after* visiting all neighbors (post-order traversal). | Post-order DFS traversal on graph with sorted adjacency lists (MinHeap). | DFS / Graph / Eulerian Path | O(E log E) or O(E) if radix sort | O(V+E) | `Map<String, PriorityQueue<String>> adj; LinkedList<String> result; void dfs(String airport) { PriorityQueue<String> neighbors = adj.get(airport); while (neighbors != null && !neighbors.isEmpty()) { dfs(neighbors.poll()); } result.addFirst(airport); // Add post-visit }` |
| 66 | Design Twitter | 355 | https://leetcode.com/problems/design-twitter/ | Use HashMaps: `userMap<userId, UserObject>`. `UserObject` contains `Set<Integer> following` and `List<Tweet> tweets`. `Tweet` class has `id`, `timestamp`. `postTweet`: Add tweet to user's tweet list (keep it sorted/limited). `getNewsFeed`: Get user's tweets + tweets from all followees. Use a Max-Heap (PriorityQueue) ordered by timestamp to merge these tweet lists and get the top 10 recent. | HashMaps for users/following, Lists/Heaps for tweets. | Design / Hash Map / Heap | O(F*T*logK) feed, O(1) follow/post (F=following, T=tweets/user, K=10) | O(Users + Tweets + Follows) | `class User { Set<Integer> following = new HashSet<>(); LinkedList<Tweet> tweets = new LinkedList<>(); } Map<Integer, User> userMap; // getNewsFeed PriorityQueue<Tweet> maxHeap = new PriorityQueue<>((a,b)->b.timestamp-a.timestamp); // Add self tweets + followee tweets to heap... poll top 10` |
| 67 | Word Search II | 212 | https://leetcode.com/problems/word-search-ii/ | Build a Trie from the `words`. Perform DFS on the `board` starting from each cell. In the DFS function `dfs(r, c, currentNode)`, check bounds, visited status. Get char `board[r][c]`. If `currentNode` doesn't have child for char, return. Move to child node. If `childNode.word != null`, add it to result and set `childNode.word = null` (avoid duplicates). Mark cell visited, explore 4 neighbors, unmark cell. | Trie stores dictionary words for efficient prefix checking during board DFS. | Trie / DFS / Backtracking | O(M*N*4*3^(L-1)) M,N=dims, L=max word len. Dominated by Trie build + DFS. | O(Total Chars in words) for Trie | `void dfs(char[][] board, int r, int c, TrieNode node, List<String> result) { //... base cases ... char ch = board[r][c]; TrieNode child = node.children[ch - 'a']; if (child == null) return; if (child.word != null) { result.add(child.word); child.word = null; // Avoid duplicates } board[r][c] = '#'; // Mark visited // dfs neighbors... board[r][c] = ch; // Unmark }` |
| 68 | Design Add and Search Words Data Structure | 211 | https://leetcode.com/problems/design-add-and-search-words-data-structure/ | Use a Trie structure (`TrieNode` with children and `isEndOfWord`). `addWord` is standard Trie insertion. `search(word)` needs modification: If char is '.', recursively call `search` on all non-null children of the current node and return true if any succeed. If char is a letter, follow the specific child branch. If path doesn't exist, return false. | Trie with modified search to handle '.' wildcard by exploring all children. | Trie / Design / DFS | O(L) add, O(N*26^L) search worst-case (.), N=nodes, L=len | O(Total Chars) for Trie | `boolean searchHelper(String word, int k, TrieNode node) { if (k == word.length()) return node.isEndOfWord; char ch = word.charAt(k); if (ch == '.') { for (TrieNode child : node.children) { if (child != null && searchHelper(word, k + 1, child)) return true; } return false; } else { // Standard Trie traversal } }` |
| 69 | Longest Valid Parentheses | 32 | https://leetcode.com/problems/longest-valid-parentheses/ | Stack approach: Push indices of '(' onto stack. When ')' is encountered: if stack not empty, pop index `start`. Length is `current_index - start + 1`. Update `maxLength`. Alternative DP: `dp[i]` = length of LVP *ending* at `i`. If `s[i] == ')'`: if `s[i-1] == '('`, `dp[i] = dp[i-2] + 2`. If `s[i-1] == ')'` and matching '(' exists at `i - dp[i-1] - 1`, `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`. | Stack stores indices to calculate length upon finding matching ')', or DP relation. | Stack / Dynamic Programming | O(n) | O(n) stack/DP array | `// Stack approach Stack<Integer> stack = new Stack<>(); stack.push(-1); // Base for length calculation for (int i=0; i<s.length(); ++i) { if (s.charAt(i) == '(') stack.push(i); else { stack.pop(); if (stack.isEmpty()) stack.push(i); // New base else maxLen = Math.max(maxLen, i - stack.peek()); } }` |
| 70 | Remove Invalid Parentheses | 301 | https://leetcode.com/problems/remove-invalid-parentheses/ | BFS Approach: Start BFS with the initial string. Use a queue and a set `visited` to avoid cycles. At each level, process strings from the queue. If a string is valid, add it to the result list. If result is found, stop exploring deeper levels (since we want minimum removals). Generate next level strings by removing one '(' or ')' from each current string and adding to queue if not visited. | Level-order BFS guarantees finding shortest paths (minimum removals) first. | BFS / String Manipulation | O(N * 2^N) worst case | O(N * 2^N) visited set | `Queue<String> queue; Set<String> visited; List<String> result; boolean found = false; while (!queue.isEmpty()) { String curr = queue.poll(); if (isValid(curr)) { result.add(curr); found = true; } if (found) continue; // Found min removals level for (int i = 0; i < curr.length(); i++) { // Generate next strings by removing one char... if (!visited.contains(nextStr)) { queue.offer(nextStr); visited.add(nextStr); } } }` |
| 71 | Combination Sum II | 40 | https://leetcode.com/problems/combination-sum-ii/ | Backtracking with sorting to handle duplicates. Sort `candidates`. Define `backtrack(startIndex, currentSum, currentList)`. Base cases: `currentSum == target` (add copy of `currentList`), `currentSum > target` (return). Loop `i` from `startIndex` to `n-1`. **Crucial**: If `i > startIndex && candidates[i] == candidates[i-1]`, continue (skip duplicate combination). Add `candidates[i]` to list, recurse `backtrack(i + 1, ...)`, backtrack (remove). | Sort + skip duplicates in backtracking loop (`i > startIndex`). Use `i+1` in recursion. | Backtracking / Recursion | O(2^N) | O(N) recursion depth | `Arrays.sort(candidates); // ... backtrack function ... for (int i = start; i < candidates.length; i++) { if (i > start && candidates[i] == candidates[i - 1]) continue; // Skip duplicates if (candidates[i] > remaining) break; // Pruning tempList.add(candidates[i]); backtrack(result, tempList, candidates, remaining - candidates[i], i + 1); // Use i+1 tempList.remove(tempList.size() - 1); }` |
| 72 | Move Zeroes | 283 | https://leetcode.com/problems/move-zeroes/ | Two Pointers (Slow/Fast or Read/Write). Initialize `writePointer = 0`. Iterate through array with `readPointer` from 0 to `n-1`. If `nums[readPointer]` is not zero, set `nums[writePointer] = nums[readPointer]` and increment `writePointer`. After loop, fill remaining positions from `writePointer` to `n-1` with zeros. | In-place modification using a write pointer for non-zero elements. | Array / Two Pointers | O(n) | O(1) | `int insertPos = 0; for (int num : nums) { if (num != 0) { nums[insertPos++] = num; } } while (insertPos < nums.length) { nums[insertPos++] = 0; }` |
| 73 | Minimum Size Subarray Sum | 209 | https://leetcode.com/problems/minimum-size-subarray-sum/ | Sliding Window. Initialize `start = 0`, `currentSum = 0`, `minLength = Integer.MAX_VALUE`. Iterate `end` from 0 to `n-1`. Add `nums[end]` to `currentSum`. While `currentSum >= target`: update `minLength = Math.min(minLength, end - start + 1)`, subtract `nums[start]` from `currentSum`, and increment `start`. Return `minLength` or 0 if not found. | Sliding window expands right, shrinks left when sum condition met. | Sliding Window / Two Pointers | O(n) | O(1) | `while (end < nums.length) { currentSum += nums[end]; while (currentSum >= target) { minLength = Math.min(minLength, end - start + 1); currentSum -= nums[start]; start++; } end++; }` |
| 74 | 3Sum Closest | 16 | https://leetcode.com/problems/3sum-closest/ | Sort array. Initialize `closestSum`. Iterate `i` from 0 to `n-3`. Use two pointers `left = i + 1`, `right = n - 1`. Calculate `currentSum = nums[i] + nums[left] + nums[right]`. If `abs(currentSum - target) < abs(closestSum - target)`, update `closestSum = currentSum`. If `currentSum == target`, return target. If `currentSum < target`, `left++`. Else `right--`. Skip duplicates for `i` not strictly needed but good practice. | Sort + Two Pointers, track sum closest to target. | Two Pointers / Sorting | O(n^2) | O(log n) or O(n) sort | `Arrays.sort(nums); int closestSum = nums[0] + nums[1] + nums[2]; // Initial guess for (int i = 0; i < nums.length - 2; i++) { int left = i + 1, right = nums.length - 1; while (left < right) { int currentSum = nums[i] + nums[left] + nums[right]; if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) { closestSum = currentSum; } if (currentSum < target) left++; else if (currentSum > target) right--; else return target; // Exact match } }` |
| 75 | 4Sum | 18 | https://leetcode.com/problems/4sum/ | Sort array. Use nested loops: outer loop `i`, inner loop `j`. Skip duplicates for `i` and `j`. Inside `j` loop, use two pointers `left = j + 1`, `right = n - 1` to find pairs summing to `target - nums[i] - nums[j]`. Calculate `currentSum`. If equal to target, add quadruplet, increment `left`, decrement `right`, skip duplicates for `left` and `right`. If `sum < target`, `left++`. If `sum > target`, `right--`. | Sort + Nested Loops + Two Pointers. Handle duplicates at all levels. | Two Pointers / Sorting | O(n^3) | O(log n) or O(n) sort | `// Outer loops for i, j (with duplicate checks) // Inner two pointers int twoSumTarget = target - nums[i] - nums[j]; int left = j + 1, right = n - 1; while (left < right) { int sum = nums[left] + nums[right]; if (sum == twoSumTarget) { result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); // Skip duplicates for left & right left++; right--; } else if (sum < twoSumTarget) left++; else right--; }` |
| 76 | Palindrome Linked List | 234 | https://leetcode.com/problems/palindrome-linked-list/ | Find middle node using slow/fast pointers. Reverse the second half of the list starting from `middle.next`. Compare the first half (from `head`) with the reversed second half node by node. Restore list afterwards if needed (reverse second half again). | Find Mid -> Reverse 2nd Half -> Compare 1st and Reversed 2nd. | Linked List / Two Pointers | O(n) | O(1) | `ListNode mid = findMiddle(head); ListNode secondHead = reverse(mid.next); // mid.next = null if needed boolean isPalindrome = true; while (secondHead != null) { if (head.val != secondHead.val) { isPalindrome = false; break; } head = head.next; secondHead = secondHead.next; }` |
| 77 | Intersection of Two Linked Lists | 160 | https://leetcode.com/problems/intersection-of-two-linked-lists/ | Two Pointers approach: Initialize `pA = headA`, `pB = headB`. Traverse both. If `pA` reaches end, redirect it to `headB`. If `pB` reaches end, redirect it to `headA`. They will meet at the intersection node (or null if no intersection) after at most two passes through combined lists. | Pointers traverse both lists; switching heads aligns them for meeting at intersection. | Linked List / Two Pointers | O(n + m) | O(1) | `ListNode pA = headA, pB = headB; while (pA != pB) { pA = (pA == null) ? headB : pA.next; pB = (pB == null) ? headA : pB.next; } return pA; // Returns intersection node or null` |
| 78 | Invert Binary Tree | 226 | https://leetcode.com/problems/invert-binary-tree/ | Recursive DFS: Base case: if `node == null`, return null. Swap `node.left` and `node.right`. Recursively call `invertTree(node.left)` and `invertTree(node.right)`. Return `node`. Iterative BFS also works. | Recursively swap left and right children. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `if (root == null) return null; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root;` |
| 79 | Binary Tree Right Side View | 199 | https://leetcode.com/problems/binary-tree-right-side-view/ | BFS (Level Order Traversal). Use a queue. In each level, iterate through all nodes currently in the queue (`levelSize`). Keep track of the value of the *last* node processed at each level. Add this last node's value to the result list. | Level order traversal, adding the last node encountered at each level. | Tree / BFS | O(n) | O(w) max width | `Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (i == levelSize - 1) { result.add(node.val); // Add last element } if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } }` |
| 80 | Subtree of Another Tree | 572 | https://leetcode.com/problems/subtree-of-another-tree/ | Recursive approach. Define `isSubtree(root, subRoot)`. Base case: `subRoot` is null -> true. `root` is null -> false. Check if `root` and `subRoot` form the same tree using `isSameTree(root, subRoot)`. If yes, return true. Otherwise, return `isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)`. `isSameTree` checks equality recursively. | Check if same tree at current node OR if subtree exists in left OR right child. | Tree / Recursion / DFS | O(m*n) worst case, O(m+n) avg | O(h) recursion depth | `boolean isSameTree(TreeNode p, TreeNode q) { // Standard same tree check } boolean isSubtree(TreeNode root, TreeNode subRoot) { if (subRoot == null) return true; if (root == null) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); }` |
| 81 | Balanced Binary Tree | 110 | https://leetcode.com/problems/balanced-binary-tree/ | Recursive DFS. Helper function `checkHeight(node)` returns height if balanced, -1 otherwise. Base case: null node returns 0. Get left/right heights recursively. If either is -1 or `abs(leftH - rightH) > 1`, return -1. Else, return `1 + max(leftH, rightH)`. Main function checks if `checkHeight(root) != -1`. | Combine height calculation and balance check in one recursive pass. | Tree / Recursion / DFS | O(n) | O(h) recursion stack | `int checkHeight(TreeNode node) { if (node == null) return 0; int leftH = checkHeight(node.left); if (leftH == -1) return -1; int rightH = checkHeight(node.right); if (rightH == -1) return -1; if (Math.abs(leftH - rightH) > 1) return -1; return 1 + Math.max(leftH, rightH); }` |
| 82 | Symmetric Tree | 101 | https://leetcode.com/problems/symmetric-tree/ | Recursive helper `isMirror(node1, node2)`. Checks if two trees are mirror images. Base cases: Both null -> true; one null -> false. Return `(node1.val == node2.val) && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left)`. Initial call: `isMirror(root.left, root.right)`. | Recursive comparison of left subtree with mirror image of right subtree. | Tree / Recursion / DFS / BFS | O(n) | O(h) recursion / O(w) BFS queue | `boolean isMirror(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }` |
| 83 | Populating Next Right Pointers in Each Node | 116 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ | Level Order Traversal (BFS) or Optimized Iterative/Recursive using existing `next`. BFS: Standard level order, connect `prev.next = current` within each level. Optimized Iterative (O(1) space): Use two pointers `levelStart` and `curr`. Iterate `levelStart` down levels. Inner loop uses `curr` to traverse current level using `next` pointers, setting `curr.left.next = curr.right` and `curr.right.next = curr.next != null ? curr.next.left : null`. | Use BFS or leverage perfect tree structure for O(1) space iteration using `next` pointers. | Tree / BFS / DFS | O(n) | O(w) BFS / O(1) optimized | `// Optimized Iterative (O(1) space) Node levelStart = root; while (levelStart != null && levelStart.left != null) { Node curr = levelStart; while (curr != null) { curr.left.next = curr.right; if (curr.next != null) curr.right.next = curr.next.left; curr = curr.next; } levelStart = levelStart.left; }` |
| 84 | Minimum Path Sum | 64 | https://leetcode.com/problems/minimum-path-sum/ | DP (Tabulation in-place). `grid[r][c]` stores min path sum to reach `(r, c)`. Initialize first row and first column based on previous cell. For other cells `(r, c)`, `grid[r][c] = grid[r][c] + min(grid[r-1][c], grid[r][c-1])`. Result is `grid[m-1][n-1]`. | DP state `dp[r][c]` = min sum to reach cell `(r,c)`. In-place update. | Dynamic Programming | O(m*n) | O(1) (in-place) / O(m*n) memo | `for (int r = 0; r < m; r++) { for (int c = 0; c < n; c++) { if (r == 0 && c == 0) continue; else if (r == 0) grid[r][c] += grid[r][c-1]; else if (c == 0) grid[r][c] += grid[r-1][c]; else grid[r][c] += Math.min(grid[r-1][c], grid[r][c-1]); } }` |
| 85 | Coin Change II | 518 | https://leetcode.com/problems/coin-change-ii/ | DP (Unbounded Knapsack). `dp[i]` = number of ways to make amount `i`. Initialize `dp[0] = 1`. Iterate through each `coin` in `coins`. For each `coin`, iterate through amounts `j` from `coin` up to `amount`. Update `dp[j] = dp[j] + dp[j - coin]`. Result is `dp[amount]`. | DP state `dp[i]` = number of combinations for amount `i`. Outer loop coins, inner loop amounts. | Dynamic Programming | O(amount * coins) | O(amount) | `int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } }` |
| 86 | House Robber II | 213 | https://leetcode.com/problems/house-robber-ii/ | Reduce to two House Robber I problems. Because first and last houses cannot be robbed together, calculate max profit for `nums[0...n-2]` (excluding last) and max profit for `nums[1...n-1]` (excluding first). Return the maximum of these two results. Use standard House Robber I DP logic for subproblems. | Solve two subproblems excluding first/last house respectively. | Dynamic Programming | O(n) | O(1) (using optimized HR I) | `if (nums.length == 1) return nums[0]; int max1 = robHelper(nums, 0, nums.length - 2); int max2 = robHelper(nums, 1, nums.length - 1); return Math.max(max1, max2); // robHelper implements House Robber I DP` |
| 87 | Unique Paths II | 63 | https://leetcode.com/problems/unique-paths-ii/ | DP (Tabulation in-place or separate DP array). `dp[r][c]` = number of paths to `(r, c)`. If `obstacleGrid[r][c] == 1`, `dp[r][c] = 0`. Else, `dp[r][c] = dp[r-1][c] + dp[r][c-1]`. Handle first row/col initialization carefully considering obstacles. Start `dp[0][0] = 1` if no obstacle. | DP state `dp[r][c]` = unique paths to `(r,c)`. Set paths to 0 if obstacle. | Dynamic Programming | O(m*n) | O(m*n) or O(n) space | `dp[r][c] = 0; // If obstacleGrid[r][c] == 1 else if (r==0 && c==0) dp[r][c] = 1; else if (r==0) dp[r][c] = dp[r][c-1]; else if (c==0) dp[r][c] = dp[r-1][c]; else dp[r][c] = dp[r-1][c] + dp[r][c-1];` |
| 88 | Search a 2D Matrix | 74 | https://leetcode.com/problems/search-a-2d-matrix/ | Treat matrix as a sorted 1D array of size `m*n`. Perform standard binary search. Map 1D index `mid` back to 2D coordinates: `row = mid / cols`, `col = mid % cols`. Compare `matrix[row][col]` with target. | Binary search on flattened matrix indices. | Binary Search | O(log(m*n)) | O(1) | `int low = 0, high = rows * cols - 1; while (low <= high) { int mid = low + (high - low) / 2; int row = mid / cols; int col = mid % cols; if (matrix[row][col] == target) return true; else if (matrix[row][col] < target) low = mid + 1; else high = mid - 1; }` |
| 89 | Kth Smallest Element in a Sorted Matrix | 378 | https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ | Binary Search on value range `[matrix[0][0], matrix[m-1][n-1]]`. For a `mid` value, count elements `<= mid` using a staircase search (start top-right or bottom-left, O(m+n)). If `count < k`, search upper half (`low = mid + 1`). If `count >= k`, search lower half (`high = mid`), storing potential answer. | Binary search on answer range, count elements efficiently. | Binary Search / Matrix | O((m+n) * log(max-min)) | O(1) | `int countLE(int[][] matrix, int x) { // Staircase search O(m+n) } int low = matrix[0][0], high = matrix[rows-1][cols-1]; int ans = low; while (low <= high) { int mid = low + (high - low) / 2; if (countLE(matrix, mid) >= k) { ans = mid; high = mid - 1; } else { low = mid + 1; } }` |
| 90 | Rotting Oranges | 994 | https://leetcode.com/problems/rotting-oranges/ | Multi-source BFS. Initialize queue with all initial rotten oranges (2s). Keep track of `freshOranges` count. Perform BFS level by level. Each level signifies one minute. Dequeue rotten orange, explore 4 neighbors. If fresh neighbor (1) found, make it rotten (2), decrement `freshOranges`, enqueue neighbor. After BFS, return minutes elapsed if `freshOranges == 0`, else -1. | Multi-source BFS tracking levels (minutes) and remaining fresh count. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `// Initial pass: count fresh, add rotten to queue Queue<int[]> queue; int minutes = 0; while (!queue.isEmpty() && freshCount > 0) { int size = queue.size(); minutes++; for (int i=0; i<size; ++i) { // Dequeue, explore neighbors, rot fresh ones, decrement freshCount, enqueue new rotten } } return freshCount == 0 ? minutes : -1;` |

| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 91 | Surrounded Regions | 130 | https://leetcode.com/problems/surrounded-regions/ | DFS/BFS from borders. Iterate through border cells `(r, c)`. If `board[r][c] == 'O'`, start DFS/BFS and mark connected 'O's as 'E' (escaped). Then, iterate board again: 'O' → 'X' (surrounded), 'E' → 'O' (not surrounded). | Start from borders to find non-surrounded 'O's first, then flip remaining 'O's. | DFS / BFS / Graph | O(m*n) | O(m*n) recursion/queue | `void capture(char[][] board, int r, int c) { // DFS/BFS marking 'O' to 'E' } for (int r=0; r<rows; ++r) { if (board[r][0]=='O') capture(board,r,0); if (board[r][cols-1]=='O') capture(board,r,cols-1); } // ... top/bottom ... for (int r=0; r<rows; ++r) for (int c=0; c<cols; ++c) { if (board[r][c]=='O') board[r][c]='X'; else if (board[r][c]=='E') board[r][c]='O'; }` |
| 92 | Shortest Path in Binary Matrix | 1091 | https://leetcode.com/problems/shortest-path-in-binary-matrix/ | BFS on grid. Queue stores `int[]{row, col}`. Use grid for visited/distance (set `grid[r][c] = distance`). Start from `(0,0)` with distance 1. Explore 8 neighbors. Return distance when `(n-1,n-1)` reached, or -1 if queue empty. Check `grid[0][0]` and `grid[n-1][n-1]` are 0. | BFS for shortest path in unweighted grid with 8-directional moves. | BFS / Graph | O(m*n) | O(m*n) queue/grid | `Queue<int[]> queue = new LinkedList<>(); if (grid[0][0] == 1) return -1; queue.offer(new int[]{0, 0}); grid[0][0] = 1; int distance = 1; while (!queue.isEmpty()) { // Process level if (r == rows - 1 && c == cols - 1) return distance; // Explore 8 neighbors, set grid[nr][nc]=distance+1 }` |
| 93 | Cheapest Flights Within K Stops | 787 | https://leetcode.com/problems/cheapest-flights-within-k-stops/ | Modified Dijkstra. PriorityQueue stores `(cost, city, stops)`. Use `minCost[city][stops]` for pruning. Relax neighbors if `stops < k`. Alternatively, Bellman-Ford: relax edges `k+1` times with `newCosts` array. | Track stops in state to limit path length. | Graph / Dijkstra / Bellman-Ford | O(E + V log V) Dijkstra / O(k*E) Bellman-Ford | O(V*k) Dijkstra / O(V) Bellman-Ford | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); pq.offer(new int[]{0, src, 0}); int[][] minCost = new int[n][k + 2]; // Fill INF while (!pq.isEmpty()) { // Poll, relax neighbors if stops < k+1 }` |
| 94 | Network Delay Time | 743 | https://leetcode.com/problems/network-delay-time/ | Dijkstra's. Build adjacency list `Map<Integer, List<int[]>>`. Initialize `minTime[node]` with infinity, `minTime[k] = 0`. PriorityQueue stores `(time, node)`. Relax neighbors if shorter path found. Return max `minTime` or -1 if unreachable nodes exist. | Standard Dijkstra for shortest paths from source. | Graph / Dijkstra | O(E log V) | O(V+E) | `PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0])); int[] minTime = new int[n + 1]; Arrays.fill(minTime, Integer.MAX_VALUE); minTime[k] = 0; pq.offer(new int[]{0, k}); while (!pq.isEmpty()) { // Poll, relax neighbors }` |
| 95 | Design Tic-Tac-Toe | 348 | https://leetcode.com/problems/design-tic-tac-toe/ | O(1) move check. Use `rows[n]`, `cols[n]`, `diagonal1`, `diagonal2`. Player 1: +1, Player 2: -1. After move, check if `abs(rows[r]) == n`, `abs(cols[c]) == n`, or diagonals equal `n`. Return winner. | Sum row/col/diagonal to detect win in O(1). | Design / Array | O(1) per move | O(n) | `int[] rows; int[] cols; int diag1, diag2; int size; int move(int row, int col, int player) { int val = (player == 1) ? 1 : -1; rows[row] += val; cols[col] += val; if (row == col) diag1 += val; if (row + col == size - 1) diag2 += val; if (Math.abs(rows[row])==size || ...) return player; return 0; }` |
| 96 | Evaluate Reverse Polish Notation | 150 | https://leetcode.com/problems/evaluate-reverse-polish-notation/ | Stack-based. For each token: if number, push to stack; if operator, pop two numbers (op2, op1), compute `op1 op op2`, push result. Return final stack value. | Stack evaluates RPN by processing operators immediately. | Stack | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); for (String token : tokens) { if (isOperator(token)) { int op2 = stack.pop(); int op1 = stack.pop(); stack.push(evaluate(op1, op2, token)); } else { stack.push(Integer.parseInt(token)); } } return stack.pop();` |
| 97 | Basic Calculator | 224 | https://leetcode.com/problems/basic-calculator/ | Stack for parentheses. Track `result`, `number`, `sign`. For '(', push `result` and `sign`, reset `result`. For ')', compute expression, multiply by popped sign, add popped result. Add `number * sign` to result for digits. | Stack manages nested expressions and signs. | Stack / String | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int result = 0; int number = 0; int sign = 1; for (char c : s.toCharArray()) { if (c == '(') { stack.push(result); stack.push(sign); result = 0; sign = 1; } else if (c == ')') { result += sign * number; number = 0; result *= stack.pop(); result += stack.pop(); } }` |
| 98 | Basic Calculator II | 227 | https://leetcode.com/problems/basic-calculator-ii/ | No-Stack approach. Track `result`, `lastNum`, `currentNum`, `operation`. For '+' or '-': `result += lastNum`, update `lastNum`. For '*' or '/': update `lastNum = lastNum op currentNum`. Handle final number. | Process */ immediately, delay +/- by tracking last number. | Stack / String | O(n) | O(1) | `int result = 0, lastNum = 0, currentNum = 0; char operation = '+'; for (int i=0; i<s.length(); ++i) { if (!Character.isDigit(c) && c != ' ' || i == s.length() - 1) { if (operation == '+') { result += lastNum; lastNum = currentNum; } else if (operation == '-') { result += lastNum; lastNum = -currentNum; } else if (operation == '*') lastNum *= currentNum; else lastNum /= currentNum; operation = c; currentNum = 0; } } result += lastNum;` |
| 99 | Letter Combinations of a Phone Number | 17 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/ | Backtracking. Map digits to letters. Recurse with `backtrack(index, current)`. Base case: `index == digits.length()`, add `current`. For each letter of current digit, append and recurse. | Explore all letter combinations recursively. | Backtracking / Recursion / String | O(4^N * N) | O(N) recursion depth | `Map<Character, String> map; List<String> result; void backtrack(int index, StringBuilder current, String digits) { if (index == digits.length()) { result.add(current.toString()); return; } String letters = map.get(digits.charAt(index)); for (char c : letters.toCharArray()) { current.append(c); backtrack(index + 1, current, digits); current.deleteCharAt(current.length() - 1); } }` |
| 100 | K Closest Points to Origin | 973 | https://leetcode.com/problems/k-closest-points-to-origin/ | Max-Heap of size `k`. Store points in heap ordered by descending distance squared. For each point: add to heap; if size > k, poll max. Return heap contents. | Max-Heap maintains k smallest distances. | Heap (Priority Queue) / Sorting | O(N log k) | O(k) | `PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])); for (int[] point : points) { maxHeap.offer(point); if (maxHeap.size() > k) maxHeap.poll(); } int[][] result = new int[k][2]; while (k-- > 0) result[k] = maxHeap.poll();` |
| 101 | Squares of a Sorted Array | 977 | https://leetcode.com/problems/squares-of-a-sorted-array/ | Two pointers (`left=0`, `right=n-1`). Compare squares of `nums[left]` and `nums[right]`. Place larger square at end of result array (`k=n-1`). Move pointer with larger square inward. | Largest squares come from ends of sorted array. | Two Pointers | O(n) | O(n) | `int[] result = new int[n]; int left = 0, right = n - 1; for (int k = n - 1; k >= 0; k--) { if (Math.abs(nums[left]) > Math.abs(nums[right])) { result[k] = nums[left] * nums[left++]; } else { result[k] = nums[right] * nums[right--]; } }` |
| 102 | Max Consecutive Ones III | 1004 | https://leetcode.com/problems/max-consecutive-ones-iii/ | Sliding window. Track `zeroCount` in window. Expand `right` pointer, increment `zeroCount` for zeros. If `zeroCount > k`, shrink window (`left++`), decrement `zeroCount`. Update `maxLen`. | Track zeros in window to ensure at most k flips. | Sliding Window | O(n) | O(1) | `int left = 0, zeroCount = 0, maxLen = 0; for (int right = 0; right < nums.length; right++) { if (nums[right] == 0) zeroCount++; while (zeroCount > k) { if (nums[left] == 0) zeroCount--; left++; } maxLen = Math.max(maxLen, right - left + 1); }` |
| 103 | Contains Duplicate II | 219 | https://leetcode.com/problems/contains-duplicate-ii/ | HashMap stores last index of each number. For each `nums[i]`, check if in map and `i - map.get(nums[i]) <= k`. Update map with current index. | Map tracks indices to check distance constraint. | Hash Map / Sliding Window (implicit) | O(n) | O(min(n, k)) | `Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; i++) { if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k) return true; map.put(nums[i], i); } return false;` |
| 104 | Permutation in String | 567 | https://leetcode.com/problems/permutation-in-string/ | Sliding window with frequency arrays. Use `s1Count[26]` for `s1` and `s2Count[26]` for window in `s2`. Initialize window of `s1.length()`. Slide window, updating counts. Check if arrays equal. | Compare frequency arrays to detect permutation. | Sliding Window / Frequency Map | O(L1 + L2) | O(1) (alphabet size) | `int[] s1Count = new int[26]; int[] s2Count = new int[26]; for (char c : s1.toCharArray()) s1Count[c - 'a']++; for (int i = 0; i < s2.length(); i++) { s2Count[s2.charAt(i) - 'a']++; if (i >= s1.length()) s2Count[s2.charAt(i - s1.length()) - 'a']--; if (Arrays.equals(s1Count, s2Count)) return true; }` |
| 105 | Trapping Rain Water II | 407 | https://leetcode.com/problems/trapping-rain-water-ii/ | Min-Heap PriorityQueue with cells `(r, c, height)`. Add boundary cells to heap, mark visited. Poll min height cell, process neighbors. For each neighbor, water trapped = `max(0, currentHeight - neighborHeight)`. Update neighbor height and add to heap. | Min-Heap ensures processing cells by increasing height, simulating water flow. | Priority Queue / BFS variant | O(m*n log(m*n)) | O(m*n) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); boolean[][] visited = new boolean[m][n]; // Add boundary cells to pq while (!pq.isEmpty()) { int[] cell = pq.poll(); // Process neighbors, calculate water, update height }` |
| 106 | Swap Nodes in Pairs | 24 | https://leetcode.com/problems/swap-nodes-in-pairs/ | Iterative with dummy node. For each pair, swap `prev.next` and `prev.next.next`. Update pointers: `prev`, `first`, `second`. Connect to next pair. | Dummy node simplifies head case; swap pairs in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0, head); ListNode prev = dummy; while (prev.next != null && prev.next.next != null) { ListNode first = prev.next; ListNode second = first.next; prev.next = second; first.next = second.next; second.next = first; prev = first; }` |
| 107 | Reverse Linked List II | 92 | https://leetcode.com/problems/reverse-linked-list-ii/ | Locate `prev` (before segment), `start` (segment start), `end` (segment end), `next_group` (after segment). Reverse segment, connect `prev` to new head, old `start` to `next_group`. | Identify four key nodes and reverse segment in-place. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prev = dummy; for (int i = 1; i < left; i++) prev = prev.next; ListNode start = prev.next; ListNode end = start; for (int i = left; i < right; i++) end = end.next; ListNode next_group = end.next; // Reverse segment and connect` |
| 108 | Populating Next Right Pointers in Each Node II | 117 | https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ | Iterative O(1) space. Use `next` pointers of previous level to traverse current level. Maintain `levelHead` (dummy for next level) and `prev` to link nodes within level. | Use existing `next` pointers to avoid extra space. | Tree Traversal / Linked List | O(n) | O(1) | `Node dummy = new Node(0); Node levelHead = dummy; Node curr = root; while (curr != null) { while (curr != null) { if (curr.left != null) { levelHead.next = curr.left; levelHead = levelHead.next; } if (curr.right != null) { levelHead.next = curr.right; levelHead = levelHead.next; } curr = curr.next; } curr = dummy.next; dummy.next = null; levelHead = dummy; }` |
| 109 | Construct Tree from Given Inorder and Preorder Traversal | N/A | https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ | Recursive. Preorder’s first element is root. Find root in inorder to split left/right subtrees. Use HashMap for O(1) inorder lookup. Recurse on subtrees. | Preorder gives root; inorder splits subtrees. | Recursion / Tree Construction | O(n) | O(n) (map + recursion) | `Map<Integer, Integer> inorderMap = new HashMap<>(); for (int i = 0; i < inorder.length; i++) inorderMap.put(inorder[i], i); return buildTreeHelper(preorder, 0, preorder.length - 1, 0, inorder.length - 1, inorderMap);` |
| 110 | Reverse a Linked List in Groups of Given Size | N/A | https://www.geeksforgeeks.org/reverse-a-linked-list-in-groups-of-given-size/ | Iterative. Use dummy node. For each group of k nodes, check if exists, reverse, and connect `prevGroupEnd` to new head, old head to next group. | Reverse k nodes and reconnect segments. | Linked List Manipulation | O(n) | O(1) | `ListNode dummy = new ListNode(0); dummy.next = head; ListNode prevGroupEnd = dummy; while (head != null) { ListNode groupStart = head; int count = 0; while (head != null && count < k) { head = head.next; count++; } if (count == k) { ListNode reversedHead = reverse(groupStart, k); prevGroupEnd.next = reversedHead; prevGroupEnd = groupStart; } }` |
| 111 | Knapsack Problem 0/1 | N/A | https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/ | DP Memoization. `dp(index, capacity)` = max value from `index` onwards with given capacity. Recurrence: max(include `values[index]` if possible, exclude). | State: (index, remaining capacity). | Dynamic Programming | O(n * capacity) | O(n * capacity) | `Map<String, Integer> memo = new HashMap<>(); int solve(int i, int capacity, int[] weights, int[] values) { if (i == weights.length || capacity == 0) return 0; String key = i + "-" + capacity; if (memo.containsKey(key)) return memo.get(key); int include = (weights[i] <= capacity) ? values[i] + solve(i + 1, capacity - weights[i], weights, values) : -1; int exclude = solve(i + 1, capacity, weights, values); memo.put(key, Math.max(include, exclude)); return memo.get(key); }` |
| 112 | Egg Dropping Puzzle | N/A | https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/ | DP Memoization. `dp(eggs, floors)` = min trials needed. For each floor k, max of `dp(eggs-1, k-1)` (breaks) and `dp(eggs, floors-k)` (survives). Minimize over k. | State: (eggs, floors); minimize max outcomes. | Dynamic Programming | O(eggs * floors^2) | O(eggs * floors) | `Map<String, Integer> memo = new HashMap<>(); int solve(int eggs, int floors) { if (floors <= 1) return floors; if (eggs == 1) return floors; String key = eggs + "-" + floors; if (memo.containsKey(key)) return memo.get(key); int minTrials = Integer.MAX_VALUE; for (int k = 1; k <= floors; k++) { int res = Math.max(solve(eggs - 1, k - 1), solve(eggs, floors - k)); minTrials = Math.min(minTrials, res); } memo.put(key, minTrials + 1); return minTrials + 1; }` |
| 113 | Search Insert Position | 35 | https://leetcode.com/problems/search-insert-position/ | Binary search. If target found, return index. Else, return `low` where search converges (insertion point). | Binary search finds exact or insertion position. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return low;` |
| 114 | Binary Search | 704 | https://leetcode.com/problems/binary-search/ | Standard binary search. Compare target with mid element, adjust `low` or `high`. Return index if found, -1 otherwise. | Classic divide-and-conquer on sorted array. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return -1;` |
| 115 | Search in Rotated Sorted Array II | 81 | https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ | Binary search handling duplicates. If `nums[mid] == nums[low] == nums[high]`, skip duplicates (`low++`, `high--`). Else, check which half is sorted and if target lies in it. | Handle duplicates by shrinking ambiguous cases. | Binary Search | O(log n) avg, O(n) worst | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return true; if (nums[mid] == nums[low] && nums[mid] == nums[high]) { low++; high--; continue; } // Check sorted half and target range }` |
| 116 | Middle of the Linked List | 876 | https://leetcode.com/problems/middle-of-the-linked-list/ | Slow and fast pointers. Slow moves one step, fast moves two. When fast reaches end, slow is at middle. | Fast pointer doubles speed to find middle. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;` |
| 117 | A Product Array Puzzle | N/A | https://www.geeksforgeeks.org/a-product-array-puzzle/ | Compute `left[i]` (product of `arr[0...i-1]`) and `right[i]` (product of `arr[i+1...n-1]`). Result `prod[i] = left[i] * right[i]`. Avoid division. | Precompute left and right products for each index. | Array Manipulation | O(n) | O(n) | `int[] left = new int[n]; int[] right = new int[n]; left[0] = 1; for (int i = 1; i < n; i++) left[i] = left[i-1] * arr[i-1]; right[n-1] = 1; for (int i = n-2; i >= 0; i--) right[i] = right[i+1] * arr[i+1]; int[] prod = new int[n]; for (int i = 0; i < n; i++) prod[i] = left[i] * right[i];` |
| 118 | Find the Smallest Window in a String Containing All Characters of Another String | N/A | https://www.geeksforgeeks.org/find-the-smallest-window-in-a-string-containing-all-characters-of-another-string/ | Sliding window. Use `patternMap` and `windowMap`. Expand window until valid (`formed == required`). Shrink from left, update min window if smaller. | Track matching characters with frequency maps. | Sliding Window / Frequency Map | O(S + T) | O(1) (alphabet size) | `Map<Character, Integer> patternMap = new HashMap<>(); Map<Character, Integer> windowMap = new HashMap<>(); int required = patternMap.size(); int formed = 0; int left = 0, minLen = Integer.MAX_VALUE, minStart = 0; for (int right = 0; right < s.length(); right++) { // Expand and shrink logic }` |
| 119 | Swapping Nodes in a Linked List | 1721 | https://leetcode.com/problems/swapping-nodes-in-a-linked-list/ | Find k-th node from start (`kFromStart`) and k-th from end (`kFromEnd`) using two pointers. Swap their values. | Use two pointers to locate k-th from end efficiently. | Linked List / Two Pointers | O(n) | O(1) | `ListNode slow = head, fast = head; for (int i = 0; i < k-1; i++) fast = fast.next; ListNode kFromStart = fast; while (fast.next != null) { fast = fast.next; slow = slow.next; } ListNode kFromEnd = slow; int temp = kFromStart.val; kFromStart.val = kFromEnd.val; kFromEnd.val = temp;` |
| 120 | Odd Even Linked List | 328 | https://leetcode.com/problems/odd-even-linked-list/ | Maintain `oddPtr` and `evenPtr` to build odd and even lists. Connect odd nodes to odd, even to even. Link odd tail to even head. | Separate odd and even nodes, then reconnect. | Linked List Manipulation | O(n) | O(1) | `ListNode oddHead = head; ListNode evenHead = head.next; ListNode oddPtr = oddHead; ListNode evenPtr = evenHead; while (evenPtr != null && evenPtr.next != null) { oddPtr.next = evenPtr.next; oddPtr = oddPtr.next; evenPtr.next = oddPtr.next; evenPtr = evenPtr.next; } oddPtr.next = evenHead;` |
| 121 | Construct Binary Tree from String | 536 | https://leetcode.com/problems/construct-binary-tree-from-string/ | Recursive. Parse number as root. Find matching parentheses for left/right subtrees. Recurse on substrings. | Parse string, handle nested parentheses for subtrees. | Recursion / Tree Construction | O(n) | O(n) (recursion stack) | `int[] build(String s, int start) { // Returns [node, endIndex] // Parse number, find '(' and matching ')', recurse for left/right } TreeNode construct(String s) { return build(s, 0)[0]; }` |
| 122 | Lowest Common Ancestor of a Binary Tree II | 1644 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ | Recursive LCA. Track if `p` and `q` found. Return LCA only if both found. If node is `p` or `q`, check other in subtrees. | Verify `p` and `q` exist before returning LCA. | Tree Traversal / Recursion | O(n) | O(h) | `boolean[] found = new boolean[2]; TreeNode lca(TreeNode root, TreeNode p, TreeNode q) { TreeNode result = lcaHelper(root, p, q); return found[0] && found[1] ? result : null; } TreeNode lcaHelper(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return null; if (root == p) { found[0] = true; return root; } if (root == q) { found[1] = true; return root; } TreeNode left = lcaHelper(root.left, p, q); TreeNode right = lcaHelper(root.right, p, q); if (left != null && right != null) return root; return left != null ? left : right; }` |
| 123 | Lowest Common Ancestor of a Binary Tree III | 1650 | https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ | Use parent pointers. Traverse from `p` to root, store in `Set`. Traverse from `q`, return first node in `Set`. | Parent pointers allow path tracing to find intersection. | Tree Traversal / Hash Set | O(h) | O(h) | `Set<Node> visited = new HashSet<>(); while (p != null) { visited.add(p); p = p.parent; } while (q != null) { if (visited.contains(q)) return q; q = q.parent; } return null;` |
| 124 | Check if a Binary Tree is Subtree of Another Binary Tree | N/A | https://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/ | Recursive. Check if tree rooted at each node of `T` is identical to `S`. Use `isIdentical` helper to compare trees. | Traverse `T`, check identity with `S` at each node. | Tree Traversal / Recursion | O(m*n) worst, O(n) avg | O(max(h_T, h_S)) | `boolean isIdentical(TreeNode t1, TreeNode t2) { if (t1 == null && t2 == null) return true; if (t1 == null || t2 == null) return false; return t1.val == t2.val && isIdentical(t1.left, t2.left) && isIdentical(t1.right, t2.right); } boolean isSubtree(TreeNode T, TreeNode S) { if (T == null) return false; if (isIdentical(T, S)) return true; return isSubtree(T.left, S) || isSubtree(T.right, S); }` |
| 125 | Flattening a Linked List | N/A | https://www.geeksforgeeks.org/flattening-a-linked-list/ | Recursive. Flatten `next` list, merge current `down` list with flattened result using sorted merge. | Merge sorted `down` lists recursively. | Linked List / Recursion | O(N * M) | O(N) (recursion) | `Node merge(Node list1, Node list2) { // Standard merge sorted lists } Node flatten(Node root) { if (root == null || root.next == null) return root; root.next = flatten(root.next); return merge(root, root.next); }` |
| 126 | Subset Sum Problem | N/A | https://www.geeksforgeeks.org/subset-sum-problem-dp-25/ | DP Memoization. `dp(index, target)` = can `target` be formed from `index` onwards. Recurrence: include or exclude `arr[index]`. | State: (index, target sum); try include/exclude. | Dynamic Programming | O(n * target_sum) | O(n * target_sum) | `Map<String, Boolean> memo = new HashMap<>(); boolean solve(int i, int target, int[] arr) { if (target == 0) return true; if (i == arr.length) return false; String key = i + "-" + target; if (memo.containsKey(key)) return memo.get(key); boolean include = arr[i] <= target ? solve(i + 1, target - arr[i], arr) : false; boolean exclude = solve(i + 1, target, arr); memo.put(key, include || exclude); return memo.get(key); }` |
| 127 | Partition Problem | N/A | https://www.geeksforgeeks.org/partition-problem-dp-18/ | Subset Sum variant. If total sum is even, check if subset with `totalSum / 2` exists using Subset Sum DP. | Reduce to Subset Sum with target = totalSum / 2. | Dynamic Programming | O(n * total_sum) | O(n * total_sum) | `int totalSum = 0; for (int num : arr) totalSum += num; if (totalSum % 2 != 0) return false; return solve(0, totalSum / 2, arr, new HashMap<>()); // Subset Sum logic` |
| 128 | Minimum Coins Make Given Value | N/A | https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-given-value/ | DP Memoization. `dp(value)` = min coins for `value`. Recurrence: min(1 + `dp(value - coin)`) for valid coins. | State: remaining value; try each coin. | Dynamic Programming | O(target_value * num_coins) | O(target_value) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int value, int[] coins) { if (value == 0) return 0; if (value < 0) return -1; if (memo.containsKey(value)) return memo.get(value); int minCoins = Integer.MAX_VALUE; for (int coin : coins) { int res = solve(value - coin, coins); if (res != -1) minCoins = Math.min(minCoins, res + 1); } memo.put(value, minCoins == Integer.MAX_VALUE ? -1 : minCoins); return memo.get(value); }` |
| 129 | Matrix Chain Multiplication | N/A | https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/ | DP Memoization. `dp(i, j)` = min multiplications for matrices `i` to `j`. Recurrence: min(`dp(i, k) + dp(k+1, j) + p[i-1]*p[k]*p[j]`) for k. | State: (start, end indices); try all splits. | Dynamic Programming | O(n^3) | O(n^2) | `int[][] memo; int solve(int i, int j, int[] p) { if (i == j) return 0; if (memo[i][j] != -1) return memo[i][j]; int minCost = Integer.MAX_VALUE; for (int k = i; k < j; k++) { int cost = solve(i, k, p) + solve(k + 1, j, p) + p[i - 1] * p[k] * p[j]; minCost = Math.min(minCost, cost); } return memo[i][j] = minCost; }` |
| 130 | Maximum Sum Increasing Subsequence | N/A | https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/ | DP. `dp[i]` = max sum of increasing subsequence ending at `i`. For each `i`, check `j < i` where `arr[i] > arr[j]`, update `dp[i]`. | Iterate previous indices for increasing property. | Dynamic Programming | O(n^2) | O(n) | `int[] dp = new int[n]; for (int i = 0; i < n; i++) dp[i] = arr[i]; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (arr[i] > arr[j]) dp[i] = Math.max(dp[i], dp[j] + arr[i]); } } int maxSum = 0; for (int sum : dp) maxSum = Math.max(maxSum, sum);` |
| 131 | Minimum Insertion Steps to Make a String Palindrome | N/A | https://www.geeksforgeeks.org/minimum-insertions-to-form-a-palindromic-string-dp-28/ | DP. Find Longest Palindromic Subsequence (LPS). Result = `s.length() - LPS`. `dp(i, j)` = LPS length for `s[i..j]`. Recurrence: if `s[i] == s[j]`, `2 + dp(i+1, j-1)`; else, max of subproblems. | Use LPS to compute min insertions. | Dynamic Programming | O(n^2) | O(n^2) | `int[][] memo; int lps(String s, int i, int j) { if (i > j) return 0; if (i == j) return 1; if (memo[i][j] != 0) return memo[i][j]; if (s.charAt(i) == s.charAt(j)) return memo[i][j] = 2 + lps(s, i + 1, j - 1); return memo[i][j] = Math.max(lps(s, i + 1, j), lps(s, i, j - 1)); } // Result: s.length() - lps(s, 0, s.length() - 1)` |
| 132 | Search an Element in a Sorted and Pivoted Array | N/A | https://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/ | Binary search. Check if left or right half is sorted. If target lies in sorted half, search there; else, search other half. | Identify sorted portion and narrow search. | Binary Search | O(log n) | O(1) | `int low = 0, high = nums.length - 1; while (low <= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) return mid; if (nums[low] <= nums[mid] && target >= nums[low] && target < nums[mid]) high = mid - 1; else low = mid + 1; }` |
| 133 | Find the Maximum j – i Such that arr[j] > arr[i] | N/A | https://www.geeksforgeeks.org/find-the-maximum-j-i-such-that-arrj-arri/ | Create `LMin[i]` (min from 0 to i) and `RMax[j]` (max from j to n-1). Use two pointers `i`, `j`. If `RMax[j] > LMin[i]`, try next `j`; else, next `i`. Track max `j-i`. | Precompute min/max arrays, use two pointers. | Array / Two Pointers | O(n) | O(n) | `int[] LMin = new int[n]; int[] RMax = new int[n]; LMin[0] = arr[0]; for (int i = 1; i < n; i++) LMin[i] = Math.min(arr[i], LMin[i-1]); RMax[n-1] = arr[n-1]; for (int j = n-2; j >= 0; j--) RMax[j] = Math.max(arr[j], RMax[j+1]); int i = 0, j = 0, maxDiff = -1; while (i < n && j < n) { if (RMax[j] > LMin[i]) { maxDiff = Math.max(maxDiff, j - i); j++; } else i++; }` |
| 134 | Insert into a Sorted Circular Linked List | 708 | https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/ | Find insertion point: where `node.val <= insertVal <= node.next.val`, or at list’s “break” (max to min), or if all equal. Insert new node. Handle empty/single node cases. | Handle sorted segment, break point, and equal values. | Linked List / Circular | O(n) | O(1) | `if (head == null) { Node newNode = new Node(insertVal); newNode.next = newNode; return newNode; } Node curr = head; while (true) { if (curr.val <= insertVal && insertVal <= curr.next.val || curr.val > curr.next.val && (insertVal >= curr.val || insertVal <= curr.next.val)) { Node newNode = new Node(insertVal); newNode.next = curr.next; curr.next = newNode; break; } curr = curr.next; if (curr == head) break; }` |
| 135 | Binary Tree Upside Down | 156 | https://leetcode.com/problems/binary-tree-upside-down/ | Iterative. Left child becomes root, root becomes right child, right child becomes left child. Use pointers `curr`, `prev`, `next` to transform bottom-up. | Transform tree level by level using pointer updates. | Tree Transformation | O(n) | O(1) | `Node curr = root; Node prev = null; Node next = null; while (curr != null) { next = curr.left; curr.left = prev; prev = curr.right; curr.right = curr; curr = next; } return prev;` |
| 136 | Boundary Traversal of Binary Tree | N/A | https://www.geeksforgeeks.org/boundary-traversal-of-binary-tree/ | Traverse left boundary (top-down, exclude leaf), leaves (inorder), right boundary (bottom-up, exclude leaf). Handle duplicates and single-node cases. | Split into three traversals, avoid duplicate leaves. | Tree Traversal | O(n) | O(h) | `void leftBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; result.add(node.val); leftBoundary(node.left != null ? node.left : node.right, result); } void leaves(TreeNode node, List<Integer> result) { if (node == null) return; if (node.left == null && node.right == null) result.add(node.val); leaves(node.left, result); leaves(node.right, result); } void rightBoundary(TreeNode node, List<Integer> result) { if (node == null || (node.left == null && node.right == null)) return; rightBoundary(node.right != null ? node.right : node.left, result); result.add(node.val); }` |
| 137 | Clone a Binary Tree with Random Pointers | N/A | https://www.geeksforgeeks.org/clone-binary-tree-with-random-pointers/ | Two-pass. First: create nodes and map original to clones. Second: set `left`, `right`, `random` pointers using map. | Map ensures correct pointer assignments. | Tree Traversal / Hash Map | O(n) | O(n) | `Map<Node, Node> map = new HashMap<>(); Node clone(Node root) { if (root == null) return null; if (map.containsKey(root)) return map.get(root); Node newNode = new Node(root.val); map.put(root, newNode); newNode.left = clone(root.left); newNode.right = clone(root.right); newNode.random = clone(root.random); return newNode; }` |
| 138 | Convert an Arbitrary Binary Tree to a Tree that Holds Children Sum Property | N/A | https://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/ | Post-order. Recurse on children. If node value < children sum, set node value to sum. If node value > sum, increase children to match (propagate down). | Adjust node or children values post-order. | Tree Traversal / Recursion | O(n^2) worst case | O(h) | `void convert(Node node) { if (node == null || (node.left == null && node.right == null)) return; convert(node.left); convert(node.right); int childSum = (node.left != null ? node.left.val : 0) + (node.right != null ? node.right.val : 0); if (node.val <= childSum) node.val = childSum; else incrementChildren(node, node.val - childSum); } void incrementChildren(Node node, int diff) { if (node.left != null) node.left.val += diff; else if (node.right != null) node.right.val += diff; }` |
| 139 | Print Nodes at Distance k from Given Node in Binary Tree | N/A | https://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root/ | Two parts: nodes k distance below target (DFS), and nodes k distance via ancestors (track distance to target, print in other subtree). | Handle downward and ancestor paths separately. | Tree Traversal / Recursion | O(n) | O(h) | `int printKDistance(Node root, Node target, int k) { if (root == null) return -1; if (root == target) { printBelow(root, k); return 0; } int leftDist = printKDistance(root.left, target, k); if (leftDist != -1) { if (leftDist + 1 == k) System.out.println(root.val); else printBelow(root.right, k - leftDist - 2); return leftDist + 1; } // Similar for right subtree } void printBelow(Node node, int k) { if (node == null || k < 0) return; if (k == 0) System.out.println(node.val); printBelow(node.left, k-1); printBelow(node.right, k-1); }` |
| 140 | Longest Bitonic Subsequence | N/A | https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/ | DP. Compute `lis[i]` (LIS ending at i) and `lds[i]` (LDS starting at i). Max bitonic length = `lis[i] + lds[i] - 1` for any i. | Combine LIS and LDS through each index. | Dynamic Programming | O(n^2) | O(n) | `int[] lis = new int[n]; int[] lds = new int[n]; for (int i = 0; i < n; i++) lis[i] = 1; for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j]) lis[i] = Math.max(lis[i], lis[j] + 1); for (int i = 0; i < n; i++) lds[i] = 1; for (int i = n-2; i >= 0; i--) for (int j = n-1; j > i; j--) if (arr[i] > arr[j]) lds[i] = Math.max(lds[i], lds[j] + 1); int maxLen = 0; for (int i = 0; i < n; i++) maxLen = Math.max(maxLen, lis[i] + lds[i] - 1);` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 141 | Rod Cutting | N/A | https://www.geeksforgeeks.org/cutting-a-rod-dp-13/ | Dynamic Programming (Memoization). Define `dp(length)` as max value for rod of length `length`. Recurrence: `dp(l) = max(price[i] + dp(l - i - 1))` for `i` from 0 to `l-1` (cuts of length `i+1`). Base case: `dp(0) = 0`. | State is remaining rod length. Maximize value by trying all possible first cuts. | Dynamic Programming (Memoization) | O(n^2) | O(n) | `Map<Integer, Integer> memo = new HashMap<>(); int solve(int length, int[] price) { if (length == 0) return 0; if (memo.containsKey(length)) return memo.get(length); int maxVal = Integer.MIN_VALUE; for (int i = 0; i < length; i++) maxVal = Math.max(maxVal, price[i] + solve(length - (i + 1), price)); memo.put(length, maxVal); return maxVal; }` |
| 142 | Min Cost Path | N/A | https://www.geeksforgeeks.org/min-cost-path-dp-6/ | Dynamic Programming (Memoization). Define `dp(r, c)` as min cost to reach `(r, c)` from `(0, 0)`. Recurrence: `dp(r, c) = grid[r][c] + min(dp(r-1, c), dp(r, c-1), dp(r-1, c-1))`. Base case: `dp(0, 0) = grid[0][0]`. Handle boundaries. | State is current cell. Minimize cost from valid neighbors (up, left, diagonal). | Dynamic Programming, Grid Traversal | O(rows * cols) | O(rows * cols) | `int[][] memo; int solve(int r, int c, int[][] grid) { if (r < 0 || c < 0) return Integer.MAX_VALUE; if (r == 0 && c == 0) return grid[0][0]; if (memo[r][c] != -1) return memo[r][c]; int minPrevCost = Math.min(Math.min(solve(r - 1, c, grid), solve(r, c - 1, grid)), solve(r - 1, c - 1, grid)); return memo[r][c] = grid[r][c] + minPrevCost; }` |
| 143 | Maximize Greatness of an Array | 2592 | https://leetcode.com/problems/maximize-greatness-of-an-array/ | Sort array. Use two pointers: `p1` for permuted array, `p2` for original sorted array. For each `nums[p1]`, find smallest `nums[p2]` where `nums[p2] > nums[p1]`. Increment greatness and both pointers if found, else advance `p2`. | Greedy: pair each element with smallest greater element. | Sorting, Two Pointers, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); int p1 = 0, p2 = 0, greatness = 0; while (p1 < nums.length && p2 < nums.length) { if (p2 < nums.length && nums[p2] > nums[p1]) { greatness++; p1++; p2++; } else p2++; } return greatness;` |
| 144 | Count Complete Subarrays in an Array | 2799 | https://leetcode.com/problems/count-complete-subarrays-in-an-array/ | Find `k` (distinct elements in array). Use sliding window with frequency map. Expand until window has `k` distinct elements. Count subarrays ending at `right` starting from `left` or later. Shrink `left` and repeat. | Count valid subarrays by tracking distinct elements in window. | Sliding Window, Frequency Map | O(n) | O(D) | `int distinctCount = new HashSet<>(Arrays.asList(Arrays.stream(nums).boxed().toArray())).size(); Map<Integer, Integer> windowFreq = new HashMap<>(); int left = 0, count = 0; for (int right = 0; right < nums.length; right++) { windowFreq.put(nums[right], windowFreq.getOrDefault(nums[right], 0) + 1); while (windowFreq.size() == distinctCount) { count += nums.length - right; windowFreq.put(nums[left], windowFreq.get(nums[left]) - 1); if (windowFreq.get(nums[left]) == 0) windowFreq.remove(nums[left]); left++; } } return count;` |
| 145 | Maximum Number of Upgradable Servers | 1947 | https://leetcode.com/problems/maximum-number-of-upgradable-servers/ | Recursive DP on tree/graph. For each server, compute max upgradable servers in subtree for two states: upgraded or not. Use memoization to store results. Consider dependencies (parent must be upgraded). | State: (server, isUpgraded). Recurse on children, aggregate results. | Dynamic Programming, Tree/Graph Traversal | O(n) | O(n) | `Map<Integer, int[]> memo; int[] solve(int serverId, int parentId, List<List<Integer>> adj, int[] cost, int[] value) { if (memo.containsKey(serverId)) return memo.get(serverId); int[] result = new int[2]; // [upgraded, notUpgraded] // Recurse on children, compute max for both states return result; }` |
| 146 | Double a Number Represented as a Linked List | 2816 | https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/ | Recursive approach. Process list from right to left via recursion. Double each digit, handle carry. Return carry for previous digit. Use dummy node for potential leading digit. | Recurse to process least significant digits first, propagate carry. | Linked List, Recursion | O(n) | O(n) | `int doubleHelper(ListNode node) { if (node == null) return 0; int carry = doubleHelper(node.next); int newVal = node.val * 2 + carry; node.val = newVal % 10; return newVal / 10; } ListNode doubleIt(ListNode head) { int carry = doubleHelper(head); if (carry > 0) { ListNode newHead = new ListNode(carry); newHead.next = head; return newHead; } return head; }` |
| 147 | Merge In Between Linked Lists | 1669 | https://leetcode.com/problems/merge-in-between-linked-lists/ | Locate node at `a-1` and `b` in `list1`. Find `list2` head and tail. Connect `a-1` to `list2` head, `list2` tail to `b.next`. | Identify and relink four key pointers. | Linked List Manipulation | O(a + b) | O(1) | `ListNode nodeBeforeA = head; for (int i = 0; i < a - 1; i++) nodeBeforeA = nodeBeforeA.next; ListNode nodeB = head; for (int i = 0; i < b; i++) nodeB = nodeB.next; ListNode list2Tail = list2; while (list2Tail.next != null) list2Tail = list2Tail.next; nodeBeforeA.next = list2; list2Tail.next = nodeB.next;` |
| 148 | Valid Anagram | 242 | https://leetcode.com/problems/valid-anagram/ | Use frequency array for lowercase letters. Increment counts for `s`, decrement for `t`. Check if all counts are zero. | Identical character frequencies indicate anagrams. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (char c : t.toCharArray()) count[c - 'a']--; for (int i : count) if (i != 0) return false; return true;` |
| 149 | Longest Consecutive Sequence | 128 | https://leetcode.com/problems/longest-consecutive-sequence/ | Use HashSet for O(1) lookups. For each number, if it’s a sequence start (`num-1` not in set), count consecutive numbers (`num+1`, `num+2`, ...). Track max length. | Only count from sequence starts to avoid redundant work. | Hash Set | O(n) | O(n) | `Set<Integer> set = new HashSet<>(); for (int num : nums) set.add(num); int maxLen = 0; for (int num : nums) { if (!set.contains(num - 1)) { int currentNum = num; int currentLen = 0; while (set.contains(currentNum)) { currentLen++; currentNum++; } maxLen = Math.max(maxLen, currentLen); } } return maxLen;` |
| 150 | Find the Duplicate Number | 287 | https://leetcode.com/problems/find-the-duplicate-number/ | Floyd’s Tortoise and Hare. Treat array as linked list (`index i` points to `nums[i]`). Find cycle meeting point, then cycle start (duplicate). | Array forms a cycle due to duplicate. Cycle start is the duplicate. | Cycle Detection | O(n) | O(1) | `int tortoise = nums[0]; int hare = nums[0]; do { tortoise = nums[tortoise]; hare = nums[nums[hare]]; } while (tortoise != hare); tortoise = nums[0]; while (tortoise != hare) { tortoise = nums[tortoise]; hare = nums[hare]; } return hare;` |
| 151 | Kth Largest Element in an Array | 215 | https://leetcode.com/problems/kth-largest-element-in-an-array/ | QuickSelect. Partition around pivot. If pivot position is `n-k`, return pivot. If less, recurse right; if greater, recurse left. | Partition to narrow search for kth largest. | QuickSelect | O(n) avg | O(log n) | `int quickSelect(int[] nums, int low, int high, int k) { int pivot = partition(nums, low, high); if (pivot == nums.length - k) return nums[pivot]; if (pivot < nums.length - k) return quickSelect(nums, pivot + 1, high, k); return quickSelect(nums, low, pivot - 1, k); }` |
| 152 | Find Median from Data Stream | 295 | https://leetcode.com/problems/find-median-from-data-stream/ | Use max-heap for lower half, min-heap for upper half. Keep max-heap size equal or one more than min-heap. Median is max-heap top or average of both tops. | Two heaps split data for O(log n) insertion, O(1) median. | Two Heaps | O(log n) add, O(1) median | O(n) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); void addNum(int num) { maxHeap.offer(num); minHeap.offer(maxHeap.poll()); if (maxHeap.size() < minHeap.size()) maxHeap.offer(minHeap.poll()); } double findMedian() { return maxHeap.size() > minHeap.size() ? maxHeap.peek() : (maxHeap.peek() + minHeap.peek()) / 2.0; }` |
| 153 | Valid Palindrome | 125 | https://leetcode.com/problems/valid-palindrome/ | Two pointers from start and end. Skip non-alphanumeric, compare lowercase alphanumeric chars. | Ignore non-alphanumeric, case-insensitive comparison. | Two Pointers, String | O(n) | O(1) | `int left = 0, right = s.length() - 1; while (left < right) { char l = s.charAt(left), r = s.charAt(right); if (!Character.isLetterOrDigit(l)) left++; else if (!Character.isLetterOrDigit(r)) right--; else if (Character.toLowerCase(l) != Character.toLowerCase(r)) return false; else { left++; right--; } } return true;` |
| 154 | Longest Common Prefix | 14 | https://leetcode.com/problems/longest-common-prefix/ | Compare chars at same index across all strings. Stop at mismatch or end of any string. | First mismatch determines prefix length. | String | O(S) | O(1) | `if (strs.length == 0) return ""; for (int i = 0; i < strs[0].length(); i++) { char c = strs[0].charAt(i); for (int j = 1; j < strs.length; j++) { if (i >= strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); } } return strs[0];` |
| 155 | Regular Expression Matching | 10 | https://leetcode.com/problems/regular-expression-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `.` and `*`. If `*`, try zero or more matches. Else, check direct match. | Recurrence based on pattern chars and `*`. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '.' || pattern.charAt(j) == text.charAt(i))); if (j + 1 < pattern.length() && pattern.charAt(j + 1) == '*') return memo[i][j] = (solve(text, pattern, i, j + 2) || (firstMatch && solve(text, pattern, i + 1, j))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 156 | Wildcard Matching | 44 | https://leetcode.com/problems/wildcard-matching/ | DP (Memoization). `dp(i, j)`: does `text[i..]` match `pattern[j..]`. Handle `?` and `*`. If `*`, try zero or more chars. If `?` or char match, advance both. | Recurrence based on `?` and `*` handling. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String text, String pattern, int i, int j) { if (j == pattern.length()) return i == text.length(); if (memo[i][j] != null) return memo[i][j]; if (pattern.charAt(j) == '*') return memo[i][j] = (solve(text, pattern, i, j + 1) || (i < text.length() && solve(text, pattern, i + 1, j))); boolean firstMatch = (i < text.length() && (pattern.charAt(j) == '?' || pattern.charAt(j) == text.charAt(i))); return memo[i][j] = firstMatch && solve(text, pattern, i + 1, j + 1); }` |
| 157 | First Unique Character in a String | 387 | https://leetcode.com/problems/first-unique-character-in-a-string/ | Use frequency array. Count char occurrences in first pass. In second pass, return index of first char with count 1. | Two passes: count frequencies, find first unique. | Frequency Map, String | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (int i = 0; i < s.length(); i++) if (count[s.charAt(i) - 'a'] == 1) return i; return -1;` |
| 158 | Intersection of Two Arrays | 349 | https://leetcode.com/problems/intersection-of-two-arrays/ | HashSet for `nums1`. Check `nums2` elements in set, add to result set, remove from set to avoid duplicates. | Set for O(1) lookups, ensure unique results. | Hash Set | O(m + n) | O(min(m, n)) | `Set<Integer> set1 = new HashSet<>(); for (int num : nums1) set1.add(num); Set<Integer> resultSet = new HashSet<>(); for (int num : nums2) if (set1.contains(num)) resultSet.add(num); return resultSet.toArray(new Integer[0]);` |
| 159 | Intersection of Two Arrays II | 350 | https://leetcode.com/problems/intersection-of-two-arrays-ii/ | HashMap for `nums1` frequencies. For `nums2`, add to result if count > 0, decrement count. | Frequency map handles duplicates correctly. | Hash Map | O(m + n) | O(min(m, n)) | `Map<Integer, Integer> freq = new HashMap<>(); for (int num : nums1) freq.put(num, freq.getOrDefault(num, 0) + 1); List<Integer> resultList = new ArrayList<>(); for (int num : nums2) if (freq.containsKey(num) && freq.get(num) > 0) { resultList.add(num); freq.put(num, freq.get(num) - 1); } return resultList.stream().mapToInt(i -> i).toArray();` |
| 160 | Sliding Window Median | 480 | https://leetcode.com/problems/sliding-window-median/ | Two heaps: max-heap for lower half, min-heap for upper half. Add/remove elements as window slides, balance heaps. Median from heap tops. | Heaps maintain sorted window for O(log k) updates. | Sliding Window, Two Heaps | O(n log k) | O(k) | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); PriorityQueue<Integer> minHeap = new PriorityQueue<>(); for (int i = 0; i < nums.length; i++) { // Add nums[i], remove nums[i-k], balance, compute median }` |
| 161 | Find K Pairs with Smallest Sums | 373 | https://leetcode.com/problems/find-k-pairs-with-smallest-sums/ | Min-PQ with `(sum, i, j)`. Start with `(nums1[i] + nums2[0], i, 0)`. Extract min, add to result, push next pair `(nums1[i] + nums2[j+1], i, j+1)` if valid. Repeat k times. | PQ explores sums in order, next pair from same `i`. | Priority Queue | O(k log k) | O(k) | `PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); for (int i = 0; i < Math.min(k, nums1.length); i++) pq.offer(new int[]{nums1[i] + nums2[0], i, 0}); List<List<Integer>> result = new ArrayList<>(); while (k-- > 0 && !pq.isEmpty()) { int[] curr = pq.poll(); result.add(Arrays.asList(nums1[curr[1]], nums2[curr[2]])); if (curr[2] + 1 < nums2.length) pq.offer(new int[]{nums1[curr[1]] + nums2[curr[2] + 1], curr[1], curr[2] + 1}); }` |
| 162 | Kth Largest Element in a Stream | 703 | https://leetcode.com/problems/kth-largest-element-in-a-stream/ | Min-PQ of size `k`. Add new number, if size > `k`, remove smallest. Top is kth largest. | Min-heap maintains k largest elements. | Priority Queue | O(log k) per add | O(k) | `PriorityQueue<Integer> pq; int k; KthLargest(int k, int[] nums) { this.k = k; pq = new PriorityQueue<>(); for (int num : nums) { pq.offer(num); if (pq.size() > k) pq.poll(); } } int add(int val) { pq.offer(val); if (pq.size() > k) pq.poll(); return pq.peek(); }` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 163 | String to Integer (atoi) | 8 | https://leetcode.com/problems/string-to-integer-atoi/ | Parse the string character by character: skip leading whitespace, read optional sign ('+' or '-'), then read digits until a non-digit or end of string. Convert digits to integer by multiplying current result by 10 and adding new digit. Check for overflow before each multiplication to prevent exceeding Integer.MAX_VALUE or Integer.MIN_VALUE. | Check for overflow before multiplying by 10 (e.g., if result > Integer.MAX_VALUE / 10, or equal and next digit > 7). Handle edge cases like empty strings or invalid inputs. | String Parsing, Edge Cases | O(n) | O(1) | `int index = 0, sign = 1, result = 0; while (index < s.length() && s.charAt(index) == ' ') index++; if (index < s.length() && (s.charAt(index) == '+' || s.charAt(index) == '-')) { sign = s.charAt(index) == '+' ? 1 : -1; index++; } while (index < s.length() && Character.isDigit(s.charAt(index))) { int digit = s.charAt(index) - '0'; if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; result = result * 10 + digit; index++; } return result * sign;` |
| 164 | Reverse Words in a String | 151 | https://leetcode.com/problems/reverse-words-in-a-string/ | Trim leading/trailing spaces, split string by one or more spaces using regex `\\s+`. Reverse the resulting array of words, then join with a single space. Handle cases with multiple consecutive spaces or empty strings. | Use `trim()` and `split("\\s+")` to handle multiple spaces efficiently. Reverse the word array in-place or via Collections.reverse for simplicity. | String Manipulation, Array Reversal | O(n) | O(n) | `String[] words = s.trim().split("\\s+"); Collections.reverse(Arrays.asList(words)); return String.join(" ", words);` |
| 165 | Valid Palindrome II | 680 | https://leetcode.com/problems/valid-palindrome-ii/ | Use two pointers starting from string ends. If characters match, move pointers inward. On mismatch, check if skipping either the left or right character results in a palindrome by calling a helper function to verify the remaining substring. | Allow one character skip by testing both options (skip left or right) on mismatch. Use a helper function to avoid duplicating palindrome check logic. | Two Pointers, String Manipulation | O(n) | O(1) | `boolean isPalindrome(String s, int left, int right) { while (left < right) if (s.charAt(left++) != s.charAt(right--)) return false; return true; } int left = 0, right = s.length() - 1; while (left < right) { if (s.charAt(left) != s.charAt(right)) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); left++; right--; } return true;` |
| 166 | Reverse String | 344 | https://leetcode.com/problems/reverse-string/ | Use two pointers: one at the start, one at the end of the char array. Swap characters at these pointers and move them toward the center until they meet. Perform swaps in-place to avoid extra space. | In-place swap using a temporary variable ensures O(1) space. Move pointers only when necessary to minimize operations. | Two Pointers, Array Manipulation | O(n) | O(1) | `int left = 0, right = s.length - 1; while (left < right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; }` |
| 167 | Encode and Decode Strings | 271 | https://leetcode.com/problems/encode-and-decode-strings/ | Encode: For each string, prepend its length followed by '#' delimiter, then append the string itself. Concatenate all encoded strings. Decode: Parse the encoded string by reading the length up to '#', then extract that many characters as a string. Repeat until the input is consumed. | Use length prefix with a delimiter to uniquely identify string boundaries. Ensure parsing handles empty strings and varying lengths. | String Serialization | O(N) | O(N) | `public String encode(List<String> strs) { StringBuilder sb = new StringBuilder(); for (String s : strs) sb.append(s.length()).append("#").append(s); return sb.toString(); } public List<String> decode(String s) { List<String> result = new ArrayList<>(); int i = 0; while (i < s.length()) { int j = i; while (s.charAt(j) != '#') j++; int len = Integer.parseInt(s.substring(i, j)); result.add(s.substring(j + 1, j + 1 + len)); i = j + 1 + len; } return result; }` |
| 168 | Decode String | 394 | https://leetcode.com/problems/decode-string/ | Use two stacks: one for counts, one for partial strings. Iterate through the string: for digits, build the count; for '[', push current count and string, reset them; for ']', pop count and string, repeat current string count times, append to popped string; for letters, append to current string. | Stacks handle nested brackets by saving state (count and partial string) at each '['. Pop and process on ']'. | Stack, String Manipulation | O(n * m) | O(n) | `Stack<Integer> countStack = new Stack<>(); Stack<StringBuilder> stringStack = new Stack<>(); StringBuilder currentString = new StringBuilder(); int k = 0; for (char c : s.toCharArray()) { if (Character.isDigit(c)) k = k * 10 + (c - '0'); else if (c == '[') { countStack.push(k); stringStack.push(currentString); k = 0; currentString = new StringBuilder(); } else if (c == ']') { StringBuilder temp = currentString; currentString = stringStack.pop(); int count = countStack.pop(); for (int i = 0; i < count; i++) currentString.append(temp); } else currentString.append(c); } return currentString.toString();` |
| 169 | Interleaving String | 97 | https://leetcode.com/problems/interleaving-string/ | Use dynamic programming with memoization. Define `dp(i, j)` as a boolean indicating if `s1[0..i-1]` and `s2[0..j-1]` interleave to form `s3[0..i+j-1]`. Recurrence: true if `s1[i-1] == s3[i+j-1]` and `dp(i-1, j)` is true, or `s2[j-1] == s3[i+j-1]` and `dp(i, j-1)` is true. Base case: `dp(0, 0) = true`. | Memoize to avoid recomputing overlapping subproblems. Check both sources (`s1` or `s2`) for each `s3` character. | Dynamic Programming, String | O(m*n) | O(m*n) | `Boolean[][] memo; boolean solve(String s1, String s2, String s3, int i, int j) { int k = i + j; if (k == s3.length()) return i == s1.length() && j == s2.length(); if (i > s1.length() || j > s2.length()) return false; if (memo[i][j] != null) return memo[i][j]; boolean res = false; if (i < s1.length() && s1.charAt(i) == s3.charAt(k)) res = solve(s1, s2, s3, i + 1, j); if (!res && j < s2.length() && s2.charAt(j) == s3.charAt(k)) res = solve(s1, s2, s3, i, j + 1); return memo[i][j] = res; } boolean isInterleave(String s1, String s2, String s3) { if (s1.length() + s2.length() != s3.length()) return false; memo = new Boolean[s1.length() + 1][s2.length() + 1]; return solve(s1, s2, s3, 0, 0); }` |
| 170 | Find the Difference | 389 | https://leetcode.com/problems/find-the-difference/ | Use a frequency array for lowercase letters. Increment counts for `s`, decrement for `t`. The character with a count of -1 is the added character in `t`. Alternatively, XOR all characters in `s` and `t` to find the differing character. | Negative count in frequency array directly identifies the added character. XOR cancels paired characters, leaving the extra one. | Frequency Map, Bit Manipulation | O(n) | O(1) | `int[] count = new int[26]; for (char c : s.toCharArray()) count[c - 'a']++; for (char c : t.toCharArray()) { count[c - 'a']--; if (count[c - 'a'] < 0) return c; } return ' ';` |
| 171 | Kth Smallest Product of Two Sorted Arrays | 2040 | https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/ | Binary search on the product range (e.g., [-10^10, 10^10]). For each candidate `mid`, count pairs `(nums1[i], nums2[j])` with product <= `mid` using two pointers, handling positive and negative numbers separately. Adjust search range based on whether count is >= `k`. | Efficiently count pairs <= `mid` by leveraging sorted arrays and two pointers for each quadrant (positive/negative combinations). | Binary Search, Two Pointers | O((m + n) log(max_val)) | O(1) | `long countPairsLessThanOrEqual(int[] nums1, int[] nums2, long target) { long count = 0; for (int i = 0; i < nums1.length; i++) { int j = nums2.length - 1; if (nums1[i] > 0) while (j >= 0 && (long) nums1[i] * nums2[j] > target) j--; else if (nums1[i] < 0) { j = 0; while (j < nums2.length && (long) nums1[i] * nums2[j] > target) j++; count += nums2.length - j; } else if (target >= 0) count += nums2.length; } return count; } long low = -10_000_000_001L, high = 10_000_000_001L; long ans = high; while (low <= high) { long mid = low + (high - low) / 2; long count = countPairsLessThanOrEqual(nums1, nums2, mid); if (count >= k) { ans = mid; high = mid - 1; } else low = mid + 1; } return ans;` |
| 172 | Shortest Palindrome | 214 | https://leetcode.com/problems/shortest-palindrome/ | Find the longest palindromic prefix using KMP’s LPS array on `s + "#" + reverse(s)`. The last LPS value gives the length of the longest palindromic prefix. Prepend the reverse of the remaining suffix to `s`. | KMP’s LPS array efficiently computes the longest palindromic prefix by treating the problem as a pattern matching task. | String, KMP | O(n) | O(n) | `int[] computeLPS(String s) { int[] lps = new int[s.length()]; int len = 0, i = 1; while (i < s.length()) { if (s.charAt(i) == s.charAt(len)) lps[i++] = ++len; else if (len > 0) len = lps[len - 1]; else lps[i++] = 0; } return lps; } String reversedS = new StringBuilder(s).reverse().toString(); String temp = s + "#" + reversedS; int[] lps = computeLPS(temp); int len = lps[temp.length() - 1]; return reversedS.substring(0, s.length() - len) + s;` |
| 173 | Text Justification | 68 | https://leetcode.com/problems/text-justification/ | Greedy: For each line, fit as many words as possible within `maxWidth`. Calculate gaps and distribute spaces: base spaces per gap, extra spaces left to right. Last line is left-justified with single spaces and padded with spaces to `maxWidth`. Handle single-word lines. | Compute total spaces and gaps, distribute evenly, and handle special cases (last line, single word) separately. | String, Array | O(L) | O(L) | `List<String> result = new ArrayList<>(); int index = 0; while (index < words.length) { int count = words[index].length(), last = index + 1; while (last < words.length && count + 1 + words[last].length() <= maxWidth) { count += 1 + words[last].length(); last++; } StringBuilder line = new StringBuilder(); if (last == words.length || last - index == 1) { for (int i = index; i < last; i++) line.append(words[i]).append(" "); while (line.length() < maxWidth) line.append(" "); } else { int gaps = last - index - 1; int totalSpaces = maxWidth - (count - gaps); int baseSpaces = totalSpaces / gaps; int extraSpaces = totalSpaces % gaps; for (int i = index; i < last; i++) { line.append(words[i]); if (i < last - 1) for (int j = 0; j < baseSpaces + (i - index < extraSpaces ? 1 : 0); j++) line.append(" "); } } result.add(line.toString().substring(0, maxWidth)); index = last; } return result;` |
| 174 | String Compression | 443 | https://leetcode.com/problems/string-compression/ | Use two pointers: `read` to scan characters, `write` to place compressed result. Count consecutive repeating characters, write the character, and if count > 1, write its digits. Modify array in-place and return new length. | In-place modification requires careful index management. Convert count to chars for multi-digit counts. | Two Pointers, String | O(n) | O(1) | `int write = 0, read = 0; while (read < chars.length) { char currentChar = chars[read]; int count = 0; while (read < chars.length && chars[read] == currentChar) { read++; count++; } chars[write++] = currentChar; if (count > 1) for (char digit : Integer.toString(count).toCharArray()) chars[write++] = digit; } return write;` |
| 175 | Longest Common Prefix Using Sorting | N/A | https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/ | Sort the array of strings. The longest common prefix is the common prefix of the first and last strings in the sorted array, as they bound the lexicographical range. Compare characters until mismatch or end. | Sorting ensures the prefix is common to all strings, as it’s shared by the lexicographically smallest and largest strings. | Sorting, String | O(n log n * m) | O(1) | `if (strs.length == 0) return ""; Arrays.sort(strs); String s1 = strs[0]; String s2 = strs[strs.length - 1]; int i = 0; while (i < s1.length() && i < s2.length() && s1.charAt(i) == s2.charAt(i)) i++; return s1.substring(0, i);` |
| 176 | Group Shifted Strings | 249 | https://leetcode.com/problems/group-shifted-strings/ | For each string, compute a shift pattern by calculating the difference (mod 26) between consecutive characters, starting from the first character. Use a HashMap to group strings by their pattern. Return grouped lists. | Normalize shifts by subtracting the first character’s value (mod 26) to create a canonical pattern. Empty strings have an empty pattern. | Hash Map, String | O(N * L) | O(N * L) | `Map<String, List<String>> map = new HashMap<>(); for (String s : strings) { StringBuilder pattern = new StringBuilder(); if (s.length() > 0) for (int i = 1; i < s.length(); i++) pattern.append((s.charAt(i) - s.charAt(0) + 26) % 26).append("#"); map.computeIfAbsent(pattern.toString(), k -> new ArrayList<>()).add(s); } return new ArrayList<>(map.values());` |
| 177 | Valid Word Abbreviation | 408 | https://leetcode.com/problems/valid-word-abbreviation/ | Use two pointers: one for word, one for abbreviation. If characters match, advance both. If abbreviation has a digit, read the full number (handle leading zeros), skip that many characters in word. Ensure both pointers reach their ends. | Parse multi-digit numbers in abbreviation and validate no leading zeros. Check word length matches after skips. | Two Pointers, String | O(w + a) | O(1) | `int wordPtr = 0, abbrPtr = 0; while (abbrPtr < abbr.length()) { if (wordPtr < word.length() && abbr.charAt(abbrPtr) == word.charAt(wordPtr)) { wordPtr++; abbrPtr++; } else if (Character.isDigit(abbr.charAt(abbrPtr))) { if (abbr.charAt(abbrPtr) == '0') return false; int num = 0; while (abbrPtr < abbr.length() && Character.isDigit(abbr.charAt(abbrPtr))) num = num * 10 + (abbr.charAt(abbrPtr++) - '0'); wordPtr += num; } else return false; } return wordPtr == word.length();` |
| 178 | String Transformation | 2750 | https://leetcode.com/problems/string-transformation/ | Check if `s` can transform to `t` via consistent character mapping. Use two HashMaps: `sToT` maps characters from `s` to `t`, `tToS` ensures one-to-one or many-to-one mapping. Verify lengths match and mappings are consistent. | Ensure bidirectional consistency in mappings to detect invalid transformations (e.g., one `s` char mapping to multiple `t` chars). | Hash Map, String | O(n) | O(1) | `if (s.length() != t.length()) return false; Map<Character, Character> sToT = new HashMap<>(); Map<Character, Character> tToS = new HashMap<>(); for (int i = 0; i < s.length(); i++) { char c1 = s.charAt(i), c2 = t.charAt(i); if (!sToT.containsKey(c1)) sToT.put(c1, c2); if (!tToS.containsKey(c2)) tToS.put(c2, c1); if (sToT.get(c1) != c2 || tToS.get(c2) != c1) return false; } return true;` |
| 179 | Count Vowel Substrings of a String | 2062 | https://leetcode.com/problems/count-vowel-substrings-of-a-string/ | Use nested loops to generate substrings. For each substring, track vowels using a set. If the substring contains only vowels and all five vowels (`a, e, i, o, u`), increment count. Break early if a non-vowel is encountered. | Early termination on non-vowels reduces unnecessary checks. Set ensures all five vowels are present in O(1) lookup. | String, Frequency Set | O(n^2) | O(1) | `int count = 0; Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u')); for (int i = 0; i < word.length(); i++) { Set<Character> currentVowels = new HashSet<>(); for (int j = i; j < word.length(); j++) { char c = word.charAt(j); if (!vowels.contains(c)) break; currentVowels.add(c); if (currentVowels.size() == 5) count++; } } return count;` |
| 180 | Add Two Integers | 2235 | https://leetcode.com/problems/add-two-integers/ | Perform standard integer addition using the `+` operator. Constraints ensure no overflow for typical 32-bit integers. | No special trick; direct addition suffices given problem constraints. | Arithmetic | O(1) | O(1) | `return num1 + num2;` |
| 181 | Add Binary | 67 | https://leetcode.com/problems/add-binary/ | Add binary strings from right to left, maintaining a carry. For each position, sum the digits (if any) and carry, append `sum % 2` to result, update carry as `sum / 2`. Reverse the result string. | Simulate manual binary addition, handling different string lengths and carry propagation. | String, Arithmetic | O(max(a.length(), b.length())) | O(max(a.length(), b.length())) | `StringBuilder result = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1, carry = 0; while (i >= 0 || j >= 0 || carry > 0) { int sum = carry; if (i >= 0) sum += a.charAt(i--) - '0'; if (j >= 0) sum += b.charAt(j--) - '0'; result.append(sum % 2); carry = sum / 2; } return result.reverse().toString();` |
| 182 | Multiply Strings | 43 | https://leetcode.com/problems/multiply-strings/ | Simulate digit-by-digit multiplication. Use an array to store intermediate results, where index `i+j` and `i+j+1` hold the product of digits at positions `i` and `j`. Process carries and convert to string, skipping leading zeros. | Use an array to manage place values and carries, avoiding direct string manipulation until the end. | String, Arithmetic | O(m*n) | O(m + n) | `int[] product = new int[num1.length() + num2.length()]; for (int i = num1.length() - 1; i >= 0; i--) { for (int j = num2.length() - 1; j >= 0; j--) { int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + product[p2]; product[p2] = sum % 10; product[p1] += sum / 10; } } StringBuilder sb = new StringBuilder(); for (int num : product) if (!(sb.length() == 0 && num == 0)) sb.append(num); return sb.length() == 0 ? "0" : sb.toString();` |
| 183 | Divide Two Integers | 29 | https://leetcode.com/problems/divide-two-integers/ | Use bitwise shifts to subtract multiples of the divisor from the dividend. Convert to long to avoid overflow, handle signs separately, and check for edge cases like `Integer.MIN_VALUE / -1`. | Bitwise left shifts allow subtracting large multiples of the divisor, reducing iterations. | Arithmetic, Bit Manipulation | O(log N) | O(1) | `long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); long quotient = 0; int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1; while (ldividend >= ldivisor) { long temp = ldivisor, multiple = 1; while (ldividend >= (temp << 1)) { temp <<= 1; multiple <<= 1; } ldividend -= temp; quotient += multiple; } quotient *= sign; if (quotient > Integer.MAX_VALUE) return Integer.MAX_VALUE; if (quotient < Integer.MIN_VALUE) return Integer.MIN_VALUE; return (int) quotient;` |
| 184 | Pow(x, n) | 50 | https://leetcode.com/problems/powx-n/ | Use binary exponentiation: if `n` is even, `x^n = (x^(n/2))^2`; if odd, `x^n = x * (x^(n/2))^2`. For negative `n`, compute `1/x` and make `n` positive. Handle edge cases like `n = 0`. | Exponentiation by squaring reduces the number of multiplications to O(log n). | Arithmetic, Recursion | O(log |n|) | O(log |n|) | `double myPow(double x, int n) { if (n == 0) return 1.0; if (n < 0) { x = 1.0 / x; if (n == Integer.MIN_VALUE) return x * myPow(x, Integer.MAX_VALUE); n = -n; } if (n % 2 == 0) return myPow(x * x, n / 2); else return x * myPow(x * x, n / 2); }` |
| 185 | Sqrt(x) | 69 | https://leetcode.com/problems/sqrtx/ | Binary search on `[0, x]` to find the largest integer `mid` such that `mid * mid <= x`. Use `long` for `mid * mid` to prevent overflow. Return the floor of the square root. | Binary search efficiently narrows down to the integer square root, handling large inputs. | Binary Search | O(log x) | O(1) | `int low = 0, high = x; int ans = 0; while (low <= high) { long mid = low + (high - low) / 2; long square = mid * mid; if (square == x) return (int) mid; if (square < x) { ans = (int) mid; low = mid + 1; } else high = mid - 1; } return ans;` |
| 186 | Reverse Integer | 7 | https://leetcode.com/problems/reverse-integer/ | Extract digits one by one using modulo and division. Build reversed number by multiplying current result by 10 and adding the digit. Check for overflow before each step. | Check overflow before multiplying by 10 to prevent exceeding integer bounds. | Arithmetic | O(log |x|) | O(1) | `long reversed = 0; while (x != 0) { int digit = x % 10; x /= 10; reversed = reversed * 10 + digit; if (reversed > Integer.MAX_VALUE || reversed < Integer.MIN_VALUE) return 0; } return (int) reversed;` |
| 187 | Palindrome Number | 9 | https://leetcode.com/problems/palindrome-number/ | Reverse the second half of the number and compare with the first half. Handle negative numbers (not palindromes) and numbers ending in 0 (only 0 is a palindrome). Stop reversing when the original number is less than or equal to the reversed part. | Reverse only half the number to avoid full reversal, handling both even and odd digit counts. | Arithmetic | O(log n) | O(1) | `if (x < 0 || (x % 10 == 0 && x != 0)) return false; int reversedHalf = 0; while (x > reversedHalf) { reversedHalf = reversedHalf * 10 + x % 10; x /= 10; } return x == reversedHalf || x == reversedHalf / 10;` |
| 188 | Power of Two | 231 | https://leetcode.com/problems/power-of-two/ | Check if `n` is positive and has exactly one set bit using `n & (n - 1) == 0`. A power of two has only one bit set in its binary representation. | Bitwise operation `n & (n - 1)` removes the least significant set bit, making it zero for powers of two. | Bit Manipulation | O(1) | O(1) | `return n > 0 && (n & (n - 1)) == 0;` |
| 189 | Power of Three | 326 | https://leetcode.com/problems/power-of-three/ | Repeatedly divide `n` by 3 until it’s no longer divisible or becomes 1. If it becomes 1, `n` is a power of three. Handle non-positive numbers. | Iterative division by 3 is simple and effective. Alternatively, check if `n` divides the largest power of 3 within integer range. | Arithmetic | O(log_3 n) | O(1) | `if (n <= 0) return false; while (n % 3 == 0) n /= 3; return n == 1;` |
| 190 | Power of Four | 342 | https://leetcode.com/problems/power-of-four/ | Check if `n` is a power of two (`n > 0 && n & (n - 1) == 0`) and satisfies `n % 3 == 1`, as powers of four (1, 4, 16, ...) are congruent to 1 mod 3. | Combine power-of-two check with modulo 3 to distinguish powers of four from other powers of two. | Bit Manipulation | O(1) | O(1) | `return n > 0 && (n & (n - 1)) == 0 && (n % 3 == 1);` |
| 191 | Valid Perfect Square | 367 | https://leetcode.com/problems/valid-perfect-square/ | Binary search on `[1, num]` to find an integer `mid` such that `mid * mid == num`. Use `long` to prevent overflow in `mid * mid`. Return true if found, false otherwise. | Binary search ensures exact match for perfect squares, handling large inputs efficiently. | Binary Search | O(log num) | O(1) | `if (num < 0) return false; if (num <= 1) return true; long low = 1, high = num; while (low <= high) { long mid = low + (high - low) / 2; long square = mid * mid; if (square == num) return true; if (square < num) low = mid + 1; else high = mid - 1; } return false;` |
| 192 | Sum of Square Numbers | 633 | https://leetcode.com/problems/sum-of-square-numbers/ | Use two pointers: `left` starts at 0, `right` at `sqrt(c)`. Compute `left^2 + right^2`. If equal to `c`, return true; if less, increment `left`; if more, decrement `right`. Use `long` to prevent overflow. | Two pointers efficiently explore all possible square sums, leveraging the bounded range `[0, sqrt(c)]`. | Two Pointers | O(sqrt(c)) | O(1) | `int left = 0; int right = (int) Math.sqrt(c); while (left <= right) { long sum = (long) left * left + (long) right * right; if (sum == c) return true; if (sum < c) left++; else right--; } return false;` |
| 193 | Count Primes | 204 | https://leetcode.com/problems/count-primes/ | Use Sieve of Eratosthenes: initialize a boolean array up to `n` as true, mark 0 and 1 as non-prime, and for each prime `p`, mark its multiples starting from `p*p` as non-prime. Count remaining primes. | Start marking multiples from `p*p` since smaller multiples are already marked by smaller primes. | Sieve | O(n log log n) | O(n) | `if (n <= 2) return 0; boolean[] isPrime = new boolean[n]; Arrays.fill(isPrime, true); isPrime[0] = isPrime[1] = false; for (int p = 2; p * p < n; p++) if (isPrime[p]) for (int i = p * p; i < n; i += p) isPrime[i] = false; int count = 0; for (int i = 2; i < n; i++) if (isPrime[i]) count++; return count;` |
| 194 | Add Digits | 258 | https://leetcode.com/problems/add-digits/ | Use the digital root formula: if `num > 0`, result is `(num - 1) % 9 + 1`; if `num == 0`, result is 0. This computes the single-digit sum of digits in O(1). | Digital root leverages congruence modulo 9, avoiding iterative digit summation. | Arithmetic | O(1) | O(1) | `if (num == 0) return 0; return (num - 1) % 9 + 1;` |
| 195 | Fizz Buzz | 412 | https://leetcode.com/problems/fizz-buzz/ | Iterate from 1 to `n`. Check divisibility: if divisible by 15, append “FizzBuzz”; by 3, “Fizz”; by 5, “Buzz”; else, the number as a string. Store results in a list. | Check divisibility by 15 first to handle the combined case efficiently. | Iteration | O(n) | O(n) | `List<String> result = new ArrayList<>(); for (int i = 1; i <= n; i++) { if (i % 15 == 0) result.add("FizzBuzz"); else if (i % 3 == 0) result.add("Fizz"); else if (i % 5 == 0) result.add("Buzz"); else result.add(Integer.toString(i)); } return result;` |
| 196 | Number of 1 Bits | 191 | https://leetcode.com/problems/number-of-1-bits/ | Use Brian Kernighan’s algorithm: repeatedly unset the least significant set bit using `n & (n - 1)` and count iterations until `n` is 0. | `n & (n - 1)` removes the rightmost set bit, making it faster than checking each bit. | Bit Manipulation | O(k) | O(1) | `int count = 0; while (n != 0) { n = n & (n - 1); count++; } return count;` |
| 197 | Reverse Bits | 190 | https://leetcode.com/problems/reverse-bits/ | Iterate 32 times: left shift the result, add the least significant bit of `n` using `n & 1`, and right shift `n` (unsigned). | Use unsigned right shift (`>>>`) to handle sign extension correctly for negative numbers. | Bit Manipulation | O(1) | O(1) | `int reversed = 0; for (int i = 0; i < 32; i++) { reversed <<= 1; reversed |= (n & 1); n >>>= 1; } return reversed;` |
| 198 | Sum of Two Integers | 371 | https://leetcode.com/problems/sum-of-two-integers/ | Use bitwise operations: `x ^ y` computes sum without carry, `(x & y) << 1` computes carry. Repeat until carry is 0, updating `x` as sum and `y` as carry. | XOR handles bit addition, AND with left shift captures carry, iterating until no carry remains. | Bit Manipulation | O(log n) | O(1) | `while (y != 0) { int carry = x & y; x = x ^ y; y = carry << 1; } return x;` |
| 199 | Factor Combinations | 254 | https://leetcode.com/problems/factor-combinations/ | Use backtracking: recurse on remaining number `num` starting from a minimum factor `startFactor`. If `num` is divisible by `i`, add `i` to current combination, recurse on `num/i` with `i` as new minimum. Backtrack by removing `i`. Add combination when `num == 1`. | Start from `startFactor` to ensure non-decreasing order and avoid duplicates. Check up to `sqrt(num)` for efficiency. | Recursion, Backtracking | O(k * 2^k) | O(log n) | `List<List<Integer>> result = new ArrayList<>(); void findFactors(List<List<Integer>> result, List<Integer> current, int num, int startFactor) { if (num == 1 && current.size() > 0) { result.add(new ArrayList<>(current)); return; } for (int i = startFactor; i <= Math.sqrt(num) || i == num; i++) if (num % i == 0) { current.add(i); findFactors(result, current, num / i, i); current.remove(current.size() - 1); } } findFactors(result, new ArrayList<>(), n, 2); return result;` |
| 200 | Binomial Coefficient | N/A | https://www.geeksforgeeks.org/binomial-coefficient-dp-9/ | Use dynamic programming based on Pascal’s Identity: `C(n, k) = C(n-1, k-1) + C(n-1, k)`. Build a 2D DP table where `dp[i][j]` is `C(i, j)`. Base cases: `C(i, 0) = C(i, i) = 1`. | Pascal’s Triangle structure allows efficient computation by reusing previous values. | Dynamic Programming | O(n*k) | O(n*k) | `int[][] dp = new int[n + 1][k + 1]; for (int i = 0; i <= n; i++) { for (int j = 0; j <= Math.min(i, k); j++) { if (j == 0 || j == i) dp[i][j] = 1; else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } } return dp[n][k];` |
| 201 | Check if Given Number is Perfect Square | N/A | https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ | Compute the integer square root using `Math.sqrt()`, cast to `long`, and check if squaring it equals the original number. Alternatively, use binary search for exact integer square root. | Casting `sqrt` to `long` avoids floating-point precision issues. Binary search is an alternative for precision. | Arithmetic | O(1) | O(1) | `long root = (long) Math.sqrt(num); return root * root == num;` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 202 | Minimum Number of Squares Whose Sum Equals to Given Number N | N/A | https://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/ | Use dynamic programming with memoization. Define `dp(n)` as the minimum number of perfect squares summing to `n`. For each `n`, iterate over all perfect squares `i*i <= n`, compute `1 + dp(n - i*i)`, and take the minimum. Base cases: `dp(0) = 0`, `dp(negative) = infinity`. Memoize results to avoid recomputation. Alternatively, use bottom-up DP for O(1) space. | Iterate only up to `sqrt(n)` for perfect squares to reduce iterations. Use `Integer.MAX_VALUE` to handle invalid cases and avoid overflow in comparisons. | Dynamic Programming (Memoization) | O(n * sqrt(n)) | O(n) | `int[] memo = new int[n + 1]; Arrays.fill(memo, -1); int solve(int k) { if (k == 0) return 0; if (k < 0) return Integer.MAX_VALUE; if (memo[k] != -1) return memo[k]; int minSquares = Integer.MAX_VALUE; for (int i = 1; i * i <= k; i++) { int next = solve(k - i * i); if (next != Integer.MAX_VALUE) minSquares = Math.min(minSquares, 1 + next); } return memo[k] = minSquares; } return solve(n);` |
| 203 | Count Ways To Reach The Nth Stair | N/A | https://www.geeksforgeeks.org/count-ways-reach-nth-stair/ | Use dynamic programming with memoization. Define `dp(k)` as the number of ways to reach stair `k` using 1 or 2 steps. Recurrence: `dp(k) = dp(k-1) + dp(k-2)`. Base cases: `dp(0) = 1`, `dp(1) = 1`. Memoize to avoid recomputation. Alternatively, use iterative DP with O(1) space for Fibonacci-like sequence. | Recognize as Fibonacci sequence shifted by one (dp(0) = 1). Use modulo 10^9+7 if large outputs are expected. | Dynamic Programming (Memoization), Fibonacci Sequence | O(n) | O(n) | `int[] memo = new int[n + 1]; Arrays.fill(memo, -1); int solve(int k) { if (k == 0 || k == 1) return 1; if (memo[k] != -1) return memo[k]; return memo[k] = (solve(k - 1) + solve(k - 2)) % 1000000007; } return solve(n);` |
| 204 | Fibonacci Number | 509 | https://leetcode.com/problems/fibonacci-number/ | Calculate the n-th Fibonacci number using dynamic programming with memoization. Define `fib(i)` as the i-th Fibonacci number: `fib(i) = fib(i-1) + fib(i-2)`. Base cases: `fib(0) = 0`, `fib(1) = 1`. Memoize to avoid recomputation. For efficiency, use iterative DP with O(1) space. | Use iterative approach with two variables to achieve O(1) space, avoiding stack overflow for large `n`. | Dynamic Programming (Iterative), Fibonacci Sequence | O(n) | O(1) | `if (n == 0) return 0; if (n == 1) return 1; int prev2 = 0, prev1 = 1; for (int i = 2; i <= n; i++) { int curr = prev1 + prev2; prev2 = prev1; prev1 = curr; } return prev1;` |
| 205 | Fibonacci Numbers | N/A | https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ | Same as Fibonacci Number (204). Calculate the n-th Fibonacci number using iterative dynamic programming for optimal space. Define `fib(i) = fib(i-1) + fib(i-2)`. Base cases: `fib(0) = 0`, `fib(1) = 1`. Use two variables to track previous values. | Iterative approach with O(1) space is more efficient than memoization for large `n`. Apply modulo 10^9+7 if needed. | Dynamic Programming (Iterative), Fibonacci Sequence | O(n) | O(1) | `if (n == 0) return 0; if (n == 1) return 1; int prev2 = 0, prev1 = 1; for (int i = 2; i <= n; i++) { int curr = prev1 + prev2; prev2 = prev1; prev1 = curr; } return prev1;` |
| 206 | Maximum Odd Binary Number | 2864 | https://leetcode.com/problems/maximum-odd-binary-number/ | To maximize an odd binary number, place one '1' at the rightmost position (least significant bit). Count total '1's and '0's in the input string. Place remaining '1's (count-1) at the leftmost positions, followed by all '0's, then the final '1'. | Ensure oddness by fixing the last bit as '1'. Maximize value by placing other '1's at higher-order bits. | String Manipulation, Counting | O(n) | O(n) | `int ones = 0; for (char c : s.toCharArray()) if (c == '1') ones++; StringBuilder sb = new StringBuilder(); for (int i = 0; i < ones - 1; i++) sb.append('1'); for (int i = 0; i < s.length() - ones; i++) sb.append('0'); sb.append('1'); return sb.toString();` |
| 207 | Calculate Amount Paid in Taxes | 2303 | https://leetcode.com/problems/calculate-amount-paid-in-taxes/ | Iterate through tax brackets. For each bracket `[upper, percent]`, calculate taxable income as `min(income - prevUpper, upper - prevUpper)`. Compute tax as `(taxableAmount * percent) / 100.0` and add to total. Update `prevUpper` to current `upper`. Stop if income is fully taxed. | Track `prevUpper` to compute taxable income per bracket. Use double for precise tax calculations. | Array Iteration, Calculation | O(n) | O(1) | `double totalTax = 0; int prevUpper = 0; for (int[] bracket : brackets) { int upper = bracket[0], percent = bracket[1]; if (income <= prevUpper) break; int taxableAmount = Math.min(income - prevUpper, upper - prevUpper); totalTax += (double) taxableAmount * percent / 100.0; prevUpper = upper; } return totalTax;` |
| 208 | Spiral Matrix | 54 | https://leetcode.com/problems/spiral-matrix/ | Traverse the matrix in a spiral order using four pointers: `top`, `bottom`, `left`, `right`. For each layer: traverse right (top row), down (right column), left (bottom row), up (left column). Update boundaries after each traversal. Stop when `top > bottom` or `left > right`. Handle single row/column cases. | Check boundaries before each traversal to avoid duplicates (e.g., single row). Use `result` list to store spiral order. | Matrix Traversal, Simulation | O(m*n) | O(1) | `List<Integer> result = new ArrayList<>(); int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.add(matrix[top][j]); top++; if (top > bottom) break; for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); right--; if (left > right) break; for (int j = right; j >= left; j--) result.add(matrix[bottom][j]); bottom--; if (top > bottom) break; for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); left++; } return result;` |
| 209 | Rotate Image | 48 | https://leetcode.com/problems/rotate-image/ | Rotate a square matrix 90 degrees clockwise in-place. First, transpose the matrix (swap `matrix[i][j]` with `matrix[j][i]` for `i <= j`). Then, reverse each row using two pointers. No extra space needed. | Transpose only upper triangle (`i <= j`) to avoid redundant swaps. Row reversal ensures correct orientation. | Matrix Manipulation, In-place Algorithm | O(n^2) | O(1) | `int n = matrix.length; for (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i < n; i++) { for (int j = 0; j < n / 2; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[i][n - 1 - j]; matrix[i][n - 1 - j] = temp; } }` |
| 210 | Set Matrix Zeroes | 73 | https://leetcode.com/problems/set-matrix-zeros/ | Use the first row and first column as markers to indicate which rows/columns should be zeroed. First, check if first row/column need zeroing. Then, scan the matrix (excluding first row/column) to mark zeros in first row/column. Finally, zero out rows/columns based on markers, handling first row/column last. | Use matrix itself as extra space to avoid O(m+n) space. Handle first row/column separately to avoid overwriting markers prematurely. | Matrix Manipulation, In-place Algorithm | O(m*n) | O(1) | `boolean firstRowZero = false, firstColZero = false; for (int j = 0; j < matrix[0].length; j++) if (matrix[0][j] == 0) firstRowZero = true; for (int i = 0; i < matrix.length; i++) if (matrix[i][0] == 0) firstColZero = true; for (int i = 1; i < matrix.length; i++) for (int j = 1; j < matrix[0].length; j++) if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; } for (int i = 1; i < matrix.length; i++) if (matrix[i][0] == 0) for (int j = 1; j < matrix[0].length; j++) matrix[i][j] = 0; for (int j = 1; j < matrix[0].length; j++) if (matrix[0][j] == 0) for (int i = 1; i < matrix.length; i++) matrix[i][j] = 0; if (firstRowZero) for (int j = 0; j < matrix[0].length; j++) matrix[0][j] = 0; if (firstColZero) for (int i = 0; i < matrix.length; i++) matrix[i][0] = 0;` |
| 211 | Valid Sudoku | 36 | https://leetcode.com/problems/valid-sudoku/ | Check each row, column, and 3x3 subgrid for duplicate digits (1-9). Use a HashSet to track seen entries, encoding each as a string (e.g., "4 in row 0"). For each cell, if not '.', check for conflicts in row, column, and box (box index = `(i/3)*3 + j/3`). Return false on any duplicate. | Encode constraints as unique strings for O(1) lookup. Compute box index efficiently to avoid separate loops. | Hash Set, Matrix Traversal | O(1) (fixed 9x9 grid) | O(1) | `Set<String> seen = new HashSet<>(); for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { char number = board[i][j]; if (number != '.') { if (!seen.add(number + " in row " + i) || !seen.add(number + " in column " + j) || !seen.add(number + " in block " + (i / 3) + "-" + (j / 3))) return false; } } } return true;` |
| 212 | Maximal Square | 221 | https://leetcode.com/problems/maximal-square/ | Use dynamic programming. Define `dp[i][j]` as the side length of the largest square ending at `(i,j)`. If `matrix[i][j] == '1'`, then `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`. Track maximum side length. Return `maxSide * maxSide`. | Use min of three neighbors to ensure a valid square. Initialize first row/column for base cases. | Dynamic Programming, Matrix DP | O(m*n) | O(m*n) | `int m = matrix.length, n = matrix[0].length; int[][] dp = new int[m][n]; int maxSide = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == '1') { dp[i][j] = 1; if (i > 0 && j > 0) dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])); maxSide = Math.max(maxSide, dp[i][j]); } } } return maxSide * maxSide;` |
| 213 | 01 Matrix | 542 | https://leetcode.com/problems/01-matrix/ | Use multi-source BFS. Initialize a queue with all cells containing 0 and set their distance to 0. Mark all 1s as `Integer.MAX_VALUE`. For each cell in the queue, update its four neighbors’ distances to `dist[curr] + 1` if smaller. Continue until queue is empty. | Start BFS from all 0s simultaneously to compute shortest paths to 1s. Use matrix as distance storage to save space. | BFS (Multi-Source), Matrix Traversal | O(m*n) | O(m*n) | `int m = matrix.length, n = matrix[0].length; int[][] dist = new int[m][n]; Queue<int[]> q = new LinkedList<>(); for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == 0) { q.offer(new int[]{i, j}); dist[i][j] = 0; } else dist[i][j] = Integer.MAX_VALUE; } } int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}}; while (!q.isEmpty()) { int[] curr = q.poll(); for (int[] dir : dirs) { int r = curr[0] + dir[0], c = curr[1] + dir[1]; if (r >= 0 && r < m && c >= 0 && c < n && dist[r][c] > dist[curr[0]][curr[1]] + 1) { dist[r][c] = dist[curr[0]][curr[1]] + 1; q.offer(new int[]{r, c}); } } } return dist;` |
| 214 | Print a Given Matrix in Spiral Form | N/A | https://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/ | Same as Spiral Matrix (208). Use four pointers (`top`, `bottom`, `left`, `right`) to traverse matrix in spiral order: right, down, left, up. Update boundaries after each traversal. Stop when boundaries cross. | Check boundaries before each traversal to handle single row/column cases correctly. | Matrix Traversal, Simulation | O(m*n) | O(1) | `List<Integer> result = new ArrayList<>(); int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.add(matrix[top][j]); top++; if (top > bottom) break; for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); right--; if (left > right) break; for (int j = right; j >= left; j--) result.add(matrix[bottom][j]); bottom--; if (top > bottom) break; for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); left++; } return result;` |
| 215 | Search in a Row Wise and Column Wise Sorted Matrix | N/A | https://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/ | Start from top-right corner (`row=0, col=n-1`). If current element equals target, return true. If less than target, move down (row++); if greater, move left (col--). Continue until out of bounds. | Top-right corner allows binary-search-like elimination of rows or columns based on comparisons. | Matrix Traversal, Two Pointers | O(m + n) | O(1) | `int row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] == target) return true; if (matrix[row][col] < target) row++; else col--; } return false;` |
| 216 | Time Based Key-Value Store | 981 | https://leetcode.com/problems/time-based-key-value-store/ | Use a HashMap where keys are strings and values are TreeMaps mapping timestamps to values. For `set(key, value, timestamp)`, add to `key`’s TreeMap. For `get(key, timestamp)`, use `floorEntry(timestamp)` to find the value with the largest timestamp <= given timestamp. | TreeMap’s `floorEntry` provides O(log N) lookup for the most recent timestamp. Handle empty cases with empty string return. | Hash Map, Sorted Map | O(log N) for get, O(1) for set | O(N) | `Map<String, TreeMap<Integer, String>> store = new HashMap<>(); void set(String key, String value, int timestamp) { store.computeIfAbsent(key, k -> new TreeMap<>()).put(timestamp, value); } String get(String key, int timestamp) { TreeMap<Integer, String> timestamps = store.get(key); if (timestamps == null) return ""; Map.Entry<Integer, String> entry = timestamps.floorEntry(timestamp); return entry == null ? "" : entry.getValue(); }` |
| 217 | Design Hit Counter | 362 | https://leetcode.com/problems/design-hit-counter/ | Use a queue to store timestamps of hits. For `hit(timestamp)`, add timestamp to queue. For `getHits(timestamp)`, remove timestamps older than `timestamp - 300` from the front, then return queue size. | Queue ensures O(1) amortized operations. Clean up old timestamps only during `getHits` to optimize `hit`. | Queue, Sliding Window | O(1) amortized | O(N) | `Queue<Integer> timestamps = new LinkedList<>(); void hit(int timestamp) { timestamps.offer(timestamp); } int getHits(int timestamp) { while (!timestamps.isEmpty() && timestamps.peek() <= timestamp - 300) timestamps.poll(); return timestamps.size(); }` |
| 218 | Logger Rate Limiter | 359 | https://leetcode.com/problems/logger-rate-limiter/ | Use a HashMap to store message -> last printed timestamp. For each message, check if it’s absent or if `timestamp >= lastPrinted + 10`. If true, update timestamp and return true; else return false. | HashMap provides O(1) average lookup. Only store messages seen within the last 10 seconds for efficiency. | Hash Map, Time-based Logic | O(1) | O(N) | `Map<String, Integer> lastPrinted = new HashMap<>(); boolean shouldPrintMessage(int timestamp, String message) { if (!lastPrinted.containsKey(message) || timestamp >= lastPrinted.get(message) + 10) { lastPrinted.put(message, timestamp); return true; } return false; }` |
| 219 | Design In-Memory File System | 588 | https://leetcode.com/problems/design-in-memory-file-system/ | Use a tree-like structure with a root node. Each node (Dir) contains a TreeMap of children (name -> Dir or File). Files store content as a StringBuilder. Implement `ls` (list sorted children), `mkdir` (create directory path), `addContentToFile` (append to file), `readContentFromFile` (return file content). | Split paths and traverse/create nodes iteratively. Use TreeMap for sorted `ls` output. | Tree, Hash Map | O(L) average | O(S) | `class Dir { TreeMap<String, Object> children = new TreeMap<>(); } class File { StringBuilder content = new StringBuilder(); } Dir root = new Dir(); List<String> ls(String path) { Object node = navigate(path); if (node instanceof File) return List.of(path.substring(path.lastIndexOf("/") + 1)); Dir dir = (Dir) node; return new ArrayList<>(dir.children.keySet()); } void mkdir(String path) { navigate(path, true); } void addContentToFile(String filePath, String content) { File file = (File) navigate(filePath, true); file.content.append(content); } String readContentFromFile(String filePath) { File file = (File) navigate(filePath, false); return file.content.toString(); } Object navigate(String path, boolean create) { ... }` |
| 220 | All O`one Data Structure | 432 | https://leetcode.com/problems/all-oone-data-structure/ | Use a HashMap (`keyToNode`) and a doubly linked list of Buckets (frequency -> Set of keys). Each Bucket has a frequency and a Set of keys. `inc`/`dec` moves keys between Buckets, updating the list. Maintain head/tail for min/max frequency access. | Doubly linked list ensures O(1) Bucket updates. Set in Buckets allows O(1) key removal. | Hash Map, Doubly Linked List | O(1) | O(N) | `class AllOne { class Bucket { int freq; Set<String> keys = new HashSet<>(); Bucket prev, next; Bucket(int f) { freq = f; } } Map<String, Bucket> keyToNode = new HashMap<>(); Bucket head = new Bucket(0), tail = new Bucket(0); { head.next = tail; tail.prev = head; } void inc(String key) { ... } void dec(String key) { ... } String getMaxKey() { return tail.prev == head ? "" : tail.prev.keys.iterator().next(); } String getMinKey() { return head.next == tail ? "" : head.next.keys.iterator().next(); } }` |
| 221 | LFU Cache | 460 | https://leetcode.com/problems/lfu-cache/ | Use three HashMaps: `cache` (key -> Node), `keyToFreq` (key -> frequency), `freqToList` (frequency -> DoublyLinkedList). Each Node has key, value, frequency. Evict least frequent, least recently used node when full. Update frequencies on get/put. | Maintain LRU order within each frequency list. Track `minFreq` for eviction. | Hash Map, Doubly Linked List | O(1) | O(Capacity) | `class LFUCache { class Node { int key, value, freq; Node prev, next; } class DoublyLinkedList { Node head = new Node(), tail = new Node(); ... } Map<Integer, Node> cache = new HashMap<>(); Map<Integer, Integer> keyToFreq = new HashMap<>(); Map<Integer, DoublyLinkedList> freqToList = new HashMap<>(); int minFreq, capacity; public LFUCache(int capacity) { this.capacity = capacity; } public int get(int key) { ... } public void put(int key, int value) { ... } }` |
| 222 | Design Memory Allocator | 2502 | https://leetcode.com/problems/design-memory-allocator/ | Use an array to represent memory, where each cell stores an `mID` (0 for free). For `allocate`, find a contiguous block of `size` zeros, set to `mID`, return start index. For `free`, set all cells with given `mID` to 0, return count. | Linear scan for allocation is simple. Track freed cells by counting matches during `free`. | Array Manipulation, Simulation | O(N) | O(N) | `class Allocator { int[] memory; Allocator(int n) { memory = new int[n]; } int allocate(int size, int mID) { int start = -1; for (int i = 0; i < memory.length; i++) { if (memory[i] == 0) { if (start == -1) start = i; if (i - start + 1 == size) { for (int j = start; j <= i; j++) memory[j] = mID; return start; } } else start = -1; } return -1; } int free(int mID) { int count = 0; for (int i = 0; i < memory.length; i++) if (memory[i] == mID) { memory[i] = 0; count++; } return count; } }` |
| 223 | Design a Data Structure for LRU Cache | N/A | https://www.geeksforgeeks.org/lru-cache-implementation/ | Use a HashMap (key -> Node) and a doubly linked list for O(1) operations. `get` moves node to front. `put` adds to front, evicts tail if over capacity. Use dummy head/tail for easier list manipulation. | Dummy nodes simplify list operations. HashMap ensures O(1) access to nodes. | Hash Map, Doubly Linked List | O(1) | O(Capacity) | `class LRUCache { class Node { int key, value; Node prev, next; } Map<Integer, Node> map = new HashMap<>(); Node head = new Node(), tail = new Node(); int capacity; LRUCache(int capacity) { this.capacity = capacity; head.next = tail; tail.prev = head; } int get(int key) { Node node = map.get(key); if (node == null) return -1; moveToHead(node); return node.value; } void put(int key, int value) { Node node = map.get(key); if (node != null) { node.value = value; moveToHead(node); } else { node = new Node(); node.key = key; node.value = value; addNode(node); map.put(key, node); if (map.size() > capacity) { Node lru = tail.prev; removeNode(lru); map.remove(lru.key); } } } void addNode(Node node) { ... } void removeNode(Node node) { ... } void moveToHead(Node node) { ... } }` |
| 224 | Jump Game | 55 | https://leetcode.com/problems/jump-game/ | Greedy approach: Track the maximum reachable index (`maxReach`). Iterate through array; if current index is reachable (`i <= maxReach`), update `maxReach` as `max(maxReach, i + nums[i])`. Return true if `maxReach >= n-1`. | Single pass with greedy updates ensures efficiency. Early termination if `maxReach` covers end. | Greedy, Array Iteration | O(n) | O(1) | `int maxReach = 0; for (int i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); if (maxReach >= nums.length - 1) return true; } return true;` |
| 225 | Jump Game II | 45 | https://leetcode.com/problems/jump-game-ii/ | Greedy approach: Track `currentReach` (end of current jump) and `maxReach` (farthest reachable with next jump). When reaching `currentReach`, increment jumps and update `currentReach` to `maxReach`. | Greedy selection of farthest reach per jump minimizes jump count. Implicit BFS levels. | Greedy, Array Iteration | O(n) | O(1) | `int jumps = 0, currentReach = 0, maxReach = 0; for (int i = 0; i < nums.length - 1; i++) { maxReach = Math.max(maxReach, i + nums[i]); if (i == currentReach) { jumps++; currentReach = maxReach; } } return jumps;` |
| 226 | Gas Station | 134 | https://leetcode.com/problems/gas-station/ | Greedy approach: Compute total gas and cost. Track `currentGas` and reset `startStation` when `currentGas < 0`. If `totalGas >= totalCost`, return `startStation`; else return -1. | If total gas is sufficient, a valid start exists. Reset start after negative `currentGas` to skip invalid segments. | Greedy, Array Iteration | O(n) | O(1) | `int totalGas = 0, totalCost = 0, currentGas = 0, startStation = 0; for (int i = 0; i < gas.length; i++) { totalGas += gas[i]; totalCost += cost[i]; currentGas += gas[i] - cost[i]; if (currentGas < 0) { startStation = i + 1; currentGas = 0; } } return totalGas >= totalCost ? startStation : -1;` |
| 227 | Candy | 135 | https://leetcode.com/problems/candy/ | Two-pass greedy: Left pass gives more candies if rating > left neighbor. Right pass ensures more candies if rating > right neighbor, taking max with current count. Sum candies. | Two passes handle both neighbor constraints independently. Use `long` for sum to avoid overflow. | Two Passes, Array Manipulation | O(n) | O(n) | `int n = ratings.length; int[] candies = new int[n]; Arrays.fill(candies, 1); for (int i = 1; i < n; i++) if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1; for (int i = n - 2; i >= 0; i--) if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1); long totalCandies = 0; for (int candy : candies) totalCandies += candy; return (int) totalCandies;` |
| 228 | Non-overlapping Intervals | 435 | https://leetcode.com/problems/non-overlapping-intervals/ | Sort intervals by end time. Track `end` of last selected interval. If current interval’s start < `end`, increment count (overlap); else update `end`. Return count. | Sorting by end time ensures greedy selection maximizes non-overlapping intervals. | Sorting, Greedy | O(n log n) | O(1) | `Arrays.sort(intervals, (a, b) -> a[1] - b[1]); int count = 0, end = intervals[0][1]; for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] < end) count++; else end = intervals[i][1]; } return count;` |
| 229 | Maximum Profit in Job Scheduling | 1235 | https://leetcode.com/problems/maximum-profit-in-job-scheduling/ | Sort jobs by end time. Use DP with memoization: `dp(i)` is max profit from index `i` onward. For each job, compute profit by including it (find next non-overlapping job via binary search) or excluding it. | Binary search finds next job efficiently. Memoization avoids recomputing subproblems. | Dynamic Programming, Binary Search | O(n log n) | O(n) | `int[][] jobs = new int[n][3]; for (int i = 0; i < n; i++) jobs[i] = new int[]{startTime[i], endTime[i], profit[i]}; Arrays.sort(jobs, (a, b) -> a[1] - b[1]); Integer[] memo = new Integer[n]; int solve(int i) { if (i >= jobs.length) return 0; if (memo[i] != null) return memo[i]; int exclude = solve(i + 1); int next = Arrays.binarySearch(jobs, i + 1, jobs.length, new int[]{jobs[i][1], 0, 0}, (a, b) -> a[0] - b[0]); next = next < 0 ? -(next + 1) : next; int include = jobs[i][2] + solve(next); return memo[i] = Math.max(exclude, include); } return solve(0);` |
| 230 | Minimum Number of Refueling Stops | 871 | https://leetcode.com/problems/minimum-number-of-refueling-stops/ | Use a max-heap to store fuel from stations passed. Track `currentFuel`. For each station, consume fuel to reach it. If `currentFuel < 0`, refuel from heap (max fuel first), increment stops. If still negative, return -1. | Greedy refueling with max fuel optimizes stops. Heap ensures O(log n) access to max fuel. | Greedy, Priority Queue | O(n log n) | O(n) | `PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a); int stops = 0, currentFuel = startFuel, prevPos = 0; for (int[] station : stations) { int pos = station[0], fuel = station[1]; currentFuel -= (pos - prevPos); while (currentFuel < 0 && !pq.isEmpty()) { currentFuel += pq.poll(); stops++; } if (currentFuel < 0) return -1; pq.offer(fuel); prevPos = pos; } currentFuel -= (target - prevPos); while (currentFuel < 0 && !pq.isEmpty()) { currentFuel += pq.poll(); stops++; } return currentFuel >= 0 ? stops : -1;` |
| 231 | Can I Win | 464 | https://leetcode.com/problems/can-i-win/ | Use DP with bitmask memoization. `dp(mask, total)` is true if the current player can win with used numbers (`mask`) and current sum (`total`). For each unused number, check if it meets `desiredTotal` or if opponent loses after picking it. | Bitmask tracks used numbers efficiently. Memoize `(mask, total)` to handle large states. | Dynamic Programming, Bit Manipulation | O(2^n * n) | O(2^n) | `Map<Long, Boolean> memo = new HashMap<>(); boolean canWin(int mask, int total, int maxChoosableInteger, int desiredTotal) { if (total >= desiredTotal) return true; long key = ((long) mask << 32) | total; if (memo.containsKey(key)) return memo.get(key); for (int i = 1; i <= maxChoosableInteger; i++) { if ((mask & (1 << (i - 1))) == 0) { if (!canWin(mask | (1 << (i - 1)), total + i, maxChoosableInteger, desiredTotal)) { memo.put(key, true); return true; } } } memo.put(key, false); return false; } boolean canIWin(int maxChoosableInteger, int desiredTotal) { if (desiredTotal == 0) return true; if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false; return canWin(0, 0, maxChoosableInteger, desiredTotal); }` |
| 232 | Task Scheduler | 621 | https://leetcode.com/problems/task-scheduler/ | Count task frequencies. The most frequent task determines minimum time: `(maxFreq - 1) * n` idle slots plus tasks. Fill idle slots with other tasks. Return max of total tasks and calculated slots. | Formula `(maxFreq - 1) * n + maxFreq` accounts for idle slots. Adjust for ties in max frequency. | Frequency Map, Greedy | O(n) | O(1) | `int[] freq = new int[26]; for (char task : tasks) freq[task - 'A']++; Arrays.sort(freq); int maxFreq = freq[25]; int idleSlots = (maxFreq - 1) * n; for (int i = 24; i >= 0 && freq[i] > 0; i--) idleSlots -= Math.min(freq[i], maxFreq - 1); return Math.max(tasks.length, tasks.length + Math.max(0, idleSlots));` |
| 233 | Task Scheduler II | 2365 | https://leetcode.com/problems/task-scheduler-ii/ | Use a HashMap to track last execution day of each task. For each task, if it was executed within `space` days, wait until `lastDay + space + 1`. Update `currentDay` and `lastExecDay`. | Track last execution to enforce cooldown. Advance `currentDay` only when necessary. | Hash Map, Simulation | O(n) | O(U) | `Map<Integer, Long> lastExecDay = new HashMap<>(); long currentDay = 0; for (int task : tasks) { if (lastExecDay.containsKey(task) && currentDay - lastExecDay.get(task) <= space) currentDay = lastExecDay.get(task) + space + 1; lastExecDay.put(task, currentDay); currentDay++; } return currentDay;` |
| 234 | Maximum Coin Collection | N/A | https://www.geeksforgeeks.org/maximum-coin-collection/ | Use dynamic programming. Define `dp[i][j]` as max coins collected reaching `(i,j)` moving right or down. Recurrence: `dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])`. Initialize first row/column. | Standard grid DP. Space can be optimized to O(n) by using only previous row. | Dynamic Programming, Grid Traversal | O(m*n) | O(m*n) | `int m = grid.length, n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for (int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j]; for (int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0]; for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[i][j] = grid[i][j] + Math.max(dp[i-1][j], dp[i][j-1]); return dp[m-1][n-1];` |



| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 235 | Single Number | 136 | https://leetcode.com/problems/single-number/ | Iterate through the array and XOR all elements. Since XORing a number with itself is 0 and XOR is associative, paired numbers cancel out, leaving the single number. Handle edge case: array of length 1. | XOR cancels pairs, leaving the unique number. Use `^=` for concise iteration. | Bit Manipulation (XOR) | O(n) | O(1) | `int result = 0; for (int num : nums) result ^= num; return result;` |
| 236 | Single Number II | 137 | https://leetcode.com/problems/single-number-ii/ | Count bits at each position (0 to 31). For each bit position, sum the occurrences of 1s across all numbers. If the sum modulo 3 is 1, set that bit in the result. Handle negative numbers by considering the sign bit. | Bit sum modulo 3 identifies the single number’s bits. Use `>>` and `&` for bit operations. | Bit Manipulation, Counting | O(n) | O(1) | `int singleNumber = 0; for (int i = 0; i < 32; i++) { int bitSum = 0; for (int num : nums) bitSum += ((num >> i) & 1); if (bitSum % 3 != 0) singleNumber |= (1 << i); } return singleNumber;` |
| 237 | Counting Bits | 338 | https://leetcode.com/problems/counting-bits/ | Use dynamic programming with bit manipulation. For each `i`, the number of 1s is the number of 1s in `i >> 1` (i/2) plus the last bit (`i & 1`). Initialize `ans[0] = 0`. Iterate from 1 to `n`. | Relate `i` to `i/2` and add the last bit. Avoid explicit bit counting for efficiency. | Dynamic Programming, Bit Manipulation | O(n) | O(n) | `int[] ans = new int[n + 1]; for (int i = 1; i <= n; i++) ans[i] = ans[i >> 1] + (i & 1); return ans;` |
| 238 | Find Kth Bit in Nth Binary String | 1545 | https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/ | Recursively compute the k-th bit of S_n. Base case: S_1 = "0". For S_n, length is `2^n - 1`. Midpoint is `(2^n - 1) / 2 + 1`. If `k == mid`, return '1'. If `k < mid`, recurse on S_{n-1}. If `k > mid`, map to index in S_{n-1} as `2*mid - k` and invert the result. | Map k to S_{n-1} and handle inversion for second half. Use bit shifts for length calculation. | Recursion, String Manipulation | O(n) | O(n) | `char findKthBit(int n, int k) { if (n == 1) return '0'; int mid = (1 << n - 1); if (k == mid) return '1'; if (k < mid) return findKthBit(n - 1, k); return findKthBit(n - 1, 2 * mid - k) == '0' ? '1' : '0'; }` |
| 239 | Subarray Sum Equals K | 560 | https://leetcode.com/problems/subarray-sum-equals-k/ | Use prefix sums with a HashMap to store frequency of sums. For each index, compute cumulative sum. If `sum - k` exists in the map, add its frequency to the count. Update map with current sum. Initialize map with `{0: 1}` for subarrays starting at index 0. | Prefix sum difference identifies subarrays summing to k. Map tracks sum frequencies. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - k, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 240 | Continuous Subarray Sum | 523 | https://leetcode.com/problems/continuous-subarray-sum/ | Use prefix sums modulo k with a HashMap to store remainder -> index. If a remainder repeats at index `j` (previously at `i`), the subarray `[i+1, j]` sums to a multiple of k. Ensure `j - i > 1`. Handle `k == 0` by checking sum directly. Initialize map with `{0: -1}`. | Same remainder modulo k implies subarray sum is divisible by k. Check subarray length. | Hash Map, Prefix Sum, Modular Arithmetic | O(n) | O(min(n, k)) | `Map<Integer, Integer> remainderMap = new HashMap<>(); remainderMap.put(0, -1); int currentSum = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; int remainder = k == 0 ? currentSum : currentSum % k; if (remainderMap.containsKey(remainder) && i - remainderMap.get(remainder) > 1) return true; if (!remainderMap.containsKey(remainder)) remainderMap.put(remainder, i); } return false;` |
| 241 | Count Subarray Sums Divisible by K | 974 | https://leetcode.com/problems/subarray-sums-divisible-by-k/ | Use prefix sums modulo k with a HashMap to count remainder frequencies. For each index, compute cumulative sum modulo k (handle negative remainders). Add frequency of current remainder to count. Update map. Initialize with `{0: 1}`. | Count subarrays by tracking remainder frequencies. Adjust negative remainders with `+k`. | Hash Map, Prefix Sum, Modular Arithmetic | O(n) | O(k) | `Map<Integer, Integer> remainderCounts = new HashMap<>(); remainderCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; int remainder = ((currentSum % k) + k) % k; count += remainderCounts.getOrDefault(remainder, 0); remainderCounts.put(remainder, remainderCounts.getOrDefault(remainder, 0) + 1); } return count;` |
| 242 | Count Binary Subarrays with Given Sum | 930 | https://leetcode.com/problems/binary-subarrays-with-sum/ | Same as Subarray Sum Equals K (239). Use prefix sums with a HashMap. For each index, compute cumulative sum. If `sum - goal` exists, add its frequency to count. Update map. Initialize with `{0: 1}`. | Identical to Subarray Sum Equals K, optimized for binary array but same logic applies. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0, 1); int currentSum = 0, count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - goal, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 243 | Contiguous Array | 525 | https://leetcode.com/problems/contiguous-array/ | Replace 0s with -1s to find longest subarray with sum 0. Use prefix sums with a HashMap to store sum -> first index. If sum repeats at index `j` (previously at `i`), subarray `[i+1, j]` has sum 0. Track max length. Initialize with `{0: -1}`. | Convert to sum-0 problem by mapping 0 to -1. Length is `j - i`. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Integer, Integer> sumIndexMap = new HashMap<>(); sumIndexMap.put(0, -1); int currentSum = 0, maxLen = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i] == 1 ? 1 : -1; if (sumIndexMap.containsKey(currentSum)) maxLen = Math.max(maxLen, i - sumIndexMap.get(currentSum)); else sumIndexMap.put(currentSum, i); } return maxLen;` |
| 244 | Minimum Operations to Reduce X to Zero | 1658 | https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/ | Find longest subarray with sum `totalSum - x`. Use prefix sums with a HashMap to store sum -> index. Compute cumulative sum. If `sum - target` exists, update max length. Minimize operations as `n - maxLen`. Initialize with `{0: -1}`. | Transform to longest subarray problem. Operations = array length - subarray length. | Hash Map, Prefix Sum | O(n) | O(n) | `long totalSum = 0; for (int num : nums) totalSum += num; long targetSum = totalSum - x; if (targetSum < 0) return -1; Map<Long, Integer> sumIndexMap = new HashMap<>(); sumIndexMap.put(0L, -1); long currentSum = 0; int maxLen = -1; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; if (sumIndexMap.containsKey(currentSum - targetSum)) maxLen = Math.max(maxLen, i - sumIndexMap.get(currentSum - targetSum)); sumIndexMap.put(currentSum, i); } return maxLen == -1 ? -1 : nums.length - maxLen;` |
| 245 | Subarrays Count with Sum Equal to 0 | N/A | https://www.geeksforgeeks.org/print-all-subarrays-with-0-sum/ | Same as Subarray Sum Equals K (239) with `k = 0`. Use prefix sums with a HashMap to count frequency of sums. If a sum repeats, add its frequency to count. Initialize with `{0: 1}`. | Count zero-sum subarrays using prefix sum frequency. Identical to k=0 case. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Long, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0L, 1); long currentSum = 0; int count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 246 | Subarrays Count with Sum = K | N/A | https://www.geeksforgeeks.org/subarrays-with-sum-k/ | Identical to Subarray Sum Equals K (239). Use prefix sums with a HashMap. For each index, compute cumulative sum. If `sum - k` exists, add its frequency. Update map. Initialize with `{0: 1}`. | Direct application of prefix sum technique for arbitrary k. | Hash Map, Prefix Sum | O(n) | O(n) | `Map<Long, Integer> prefixSumCounts = new HashMap<>(); prefixSumCounts.put(0L, 1); long currentSum = 0; int count = 0; for (int num : nums) { currentSum += num; count += prefixSumCounts.getOrDefault(currentSum - k, 0); prefixSumCounts.put(currentSum, prefixSumCounts.getOrDefault(currentSum, 0) + 1); } return count;` |
| 247 | Print All Subarrays with 0 Sum | N/A | https://www.geeksforgeeks.org/print-all-subarrays-with-0-sum/ | Use prefix sums with a HashMap mapping sum to list of indices. If a sum repeats, print subarrays from each previous index + 1 to current index. Initialize with `{0: [-1]}`. Note: Printing increases time complexity based on output size. | Store indices for each sum to print all subarrays. Handle printing in O(max_occurrences). | Hash Map, Prefix Sum | O(n + S) (S = subarray count) | O(n) | `Map<Long, List<Integer>> sumIndices = new HashMap<>(); sumIndices.put(0L, new ArrayList<>(List.of(-1))); long currentSum = 0; for (int i = 0; i < nums.length; i++) { currentSum += nums[i]; if (sumIndices.containsKey(currentSum)) { for (int prevIndex : sumIndices.get(currentSum)) System.out.println("Subarray from " + (prevIndex + 1) + " to " + i); } sumIndices.computeIfAbsent(currentSum, k -> new ArrayList<>()).add(i); }` |
| 248 | Number of Provinces | 547 | https://leetcode.com/problems/number-of-provinces/ | Use Union-Find to count connected components. Initialize each city in its own set. For each connection, union the cities. Count distinct sets (roots). Alternatively, use DFS to count components. | Union-Find efficiently merges connected cities. Count roots for province count. | Union-Find, Graph | O(n^2 * α(n)) | O(n) | `int[] parent = new int[n]; int count = n; for (int i = 0; i < n; i++) parent[i] = i; int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } void union(int x, int y) { int px = find(x), py = find(y); if (px != py) { parent[px] = py; count--; } } for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (isConnected[i][j] == 1) union(i, j); return count;` |
| 249 | Accounts Merge | 721 | https://leetcode.com/problems/accounts-merge/ | Use Union-Find to group emails. Map each email to an ID and name. Union emails in the same account. Group emails by their root, then map to names and sort. Return merged accounts. | Union-Find groups emails efficiently. Sort emails for output consistency. | Union-Find, Hash Map | O(A * E * α(E) + E log E) | O(A * E) | `Map<String, Integer> emailToId = new HashMap<>(); Map<String, String> emailToName = new HashMap<>(); int id = 0; for (List<String> account : accounts) for (int i = 1; i < account.size(); i++) { String email = account.get(i); emailToId.putIfAbsent(email, id++); emailToName.put(email, account.get(0)); } int[] parent = new int[id]; for (int i = 0; i < id; i++) parent[i] = i; int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } for (List<String> account : accounts) for (int i = 2; i < account.size(); i++) parent[find(emailToId.get(account.get(i)))] = find(emailToId.get(account.get(1))); Map<Integer, List<String>> groups = new HashMap<>(); for (String email : emailToId.keySet()) groups.computeIfAbsent(find(emailToId.get(email)), k -> new ArrayList<>()).add(email); List<List<String>> result = new ArrayList<>(); for (List<String> emails : groups.values()) { Collections.sort(emails); List<String> account = new ArrayList<>(); account.add(emailToName.get(emails.get(0))); account.addAll(emails); result.add(account); } return result;` |
| 250 | Minesweeper | 529 | https://leetcode.com/problems/minesweeper/ | Use DFS to reveal cells. If clicked cell is 'M', set to 'X'. If 'E', count adjacent mines. If count > 0, set to digit; if 0, set to 'B' and recurse on neighbors. Use visited set to avoid cycles. | DFS reveals connected blank cells efficiently. Count mines using 8-directional check. | DFS, Matrix Traversal | O(m*n) | O(m*n) | `void updateBoard(char[][] board, int[] click) { int r = click[0], c = click[1]; if (board[r][c] == 'M') { board[r][c] = 'X'; return; } dfs(board, r, c, new boolean[board.length][board[0].length]); } void dfs(char[][] board, int r, int c, boolean[][] visited) { if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || visited[r][c] || board[r][c] != 'E') return; visited[r][c] = true; int mines = countMines(board, r, c); if (mines > 0) { board[r][c] = (char) ('0' + mines); return; } board[r][c] = 'B'; int[][] dirs = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; for (int[] dir : dirs) dfs(board, r + dir[0], c + dir[1], visited); } int countMines(char[][] board, int r, int c) { int count = 0; for (int i = -1; i <= 1; i++) for (int j = -1; j <= 1; j++) if (i != 0 || j != 0) if (r + i >= 0 && r + i < board.length && c + j >= 0 && c + j < board[0].length && board[r + i][c + j] == 'M') count++; return count; }` |
| 251 | Robot Room Cleaner | 489 | https://leetcode.com/problems/robot-room-cleaner/ | Use backtracking (DFS). Clean current cell, mark as visited. Try all four directions. If move is possible, recurse, then backtrack by moving back and restoring direction. Use a set for visited cells. | Backtrack with explicit direction handling. Visited set prevents cycles. | Backtracking, DFS | O(N * 4) | O(N) | `Set<String> visited = new HashSet<>(); int[][] dirs = {{-1,0},{0,1},{1,0},{0,-1}}; void cleanRoom(Robot robot) { clean(0, 0, 0, robot); } void clean(int r, int c, int dir, Robot robot) { visited.add(r + "," + c); robot.clean(); for (int i = 0; i < 4; i++) { int newDir = (dir + i) % 4; int nr = r + dirs[newDir][0], nc = c + dirs[newDir][1]; if (!visited.contains(nr + "," + nc) && robot.move()) { clean(nr, nc, newDir, robot); robot.turnLeft(); robot.turnLeft(); robot.move(); robot.turnRight(); robot.turnRight(); } robot.turnRight(); } }` |
| 252 | The Maze | 490 | https://leetcode.com/problems/the-maze/ | Use BFS to find if the ball can stop at the destination. From each stop point, roll in all four directions until hitting a wall. Add stop points to queue if unvisited. Check if destination is reached. | BFS explores all stop points. Roll until wall for each direction. | BFS, Matrix Traversal | O(m*n) | O(m*n) | `boolean hasPath(int[][] maze, int[] start, int[] destination) { int m = maze.length, n = maze[0].length; boolean[][] visited = new boolean[m][n]; Queue<int[]> q = new LinkedList<>(); q.offer(start); visited[start[0]][start[1]] = true; int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}}; while (!q.isEmpty()) { int[] curr = q.poll(); if (curr[0] == destination[0] && curr[1] == destination[1]) return true; for (int[] dir : dirs) { int r = curr[0], c = curr[1]; while (r + dir[0] >= 0 && r + dir[0] < m && c + dir[1] >= 0 && c + dir[1] < n && maze[r + dir[0]][c + dir[1]] == 0) { r += dir[0]; c += dir[1]; } if (!visited[r][c]) { visited[r][c] = true; q.offer(new int[]{r, c}); } } } return false; }` |
| 253 | Robot Bounded In Circle | 1041 | https://leetcode.com/problems/robot-bounded-in-circle/ | Simulate one cycle of instructions. Track position (x, y) and direction (0: North, 1: East, 2: South, 3: West). Return true if back at origin or direction changed (implying a cycle). | Check position and direction after one cycle. Direction change ensures eventual return. | Simulation, Math | O(n) | O(1) | `int x = 0, y = 0, dir = 0; int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}}; for (char instr : instructions.toCharArray()) { if (instr == 'G') { x += directions[dir][0]; y += directions[dir][1]; } else if (instr == 'L') dir = (dir + 3) % 4; else dir = (dir + 1) % 4; } return (x == 0 && y == 0) || dir != 0;` |
| 254 | Sliding Puzzle | 773 | https://leetcode.com/problems/sliding-puzzle/ | Use BFS to find minimum moves. Represent board as a string. For each state, find the '0' position, swap with adjacent positions, and add new states to queue if unvisited. Track moves via BFS levels. Target is "123450". | BFS ensures shortest path. String representation simplifies state tracking. | BFS, State Space Search | O(6!) | O(6!) | `int slidingPuzzle(int[][] board) { String target = "123450"; StringBuilder sb = new StringBuilder(); for (int[] row : board) for (int num : row) sb.append(num); String start = sb.toString(); Queue<String> q = new LinkedList<>(); Set<String> visited = new HashSet<>(); q.offer(start); visited.add(start); int moves = 0; int[][] swaps = {{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}}; while (!q.isEmpty()) { int size = q.size(); while (size-- > 0) { String curr = q.poll(); if (curr.equals(target)) return moves; int zeroIdx = curr.indexOf('0'); for (int next : swaps[zeroIdx]) { String nextState = swap(curr, zeroIdx, next); if (!visited.contains(nextState)) { visited.add(nextState); q.offer(nextState); } } } moves++; } return -1; } String swap(String s, int i, int j) { char[] arr = s.toCharArray(); char temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return new String(arr); }` |
| 255 | 24 Game | 679 | https://leetcode.com/problems/24-game/ | Use backtracking to try all pairs of numbers and operations (+, -, *, /). Replace pair with result, recurse on remaining numbers. Base case: one number ≈ 24 (within 1e-6). Handle division by zero and floating-point precision. | Explore all combinations and operations. Use double for precision. | Backtracking, Arithmetic | O(4!) | O(4) | `boolean judgePoint24(int[] cards) { List<Double> nums = new ArrayList<>(); for (int card : cards) nums.add((double) card); return solve(nums); } boolean solve(List<Double> nums) { if (nums.size() == 1) return Math.abs(nums.get(0) - 24.0) < 1e-6; for (int i = 0; i < nums.size(); i++) { for (int j = 0; j < nums.size(); j++) { if (i == j) continue; List<Double> next = new ArrayList<>(); for (int k = 0; k < nums.size(); k++) if (k != i && k != j) next.add(nums.get(k)); double a = nums.get(i), b = nums.get(j); for (double res : new double[]{a + b, a - b, a * b, b != 0 ? a / b : Double.MAX_VALUE}) if (res != Double.MAX_VALUE) { next.add(res); if (solve(next)) return true; next.remove(next.size() - 1); } } } return false; }` |
| 256 | Nim Game | 292 | https://leetcode.com/problems/nim-game/ | First player wins if `n` is not divisible by 4, as they can force a losing state (multiple of 4) for the opponent. Check `n % 4 != 0`. | Pattern recognition: multiples of 4 are losing states for the first player. | Game Theory, Math | O(1) | O(1) | `return n % 4 != 0;` |
| 257 | Flip Game II | 294 | https://leetcode.com/problems/flip-game-ii/ | Use backtracking with memoization. For each state, try flipping "++" to "--". If any resulting state leads to a loss for the opponent, the current player wins. Memoize states to avoid recomputation. | Memoize string states to optimize recursive exploration of game tree. | Backtracking, Game Theory | O(n * 2^n) | O(2^n) | `Map<String, Boolean> memo = new HashMap<>(); boolean canWin(String s) { if (memo.containsKey(s)) return memo.get(s); for (int i = 0; i < s.length() - 1; i++) if (s.startsWith("++", i)) { String next = s.substring(0, i) + "--" + s.substring(i + 2); if (!canWin(next)) { memo.put(s, true); return true; } } memo.put(s, false); return false; }` |
| 258 | Insert Delete GetRandom O(1) | 380 | https://leetcode.com/problems/insert-delete-getrandom-o1/ | Use a HashMap (`val -> index`) and ArrayList for O(1) operations. Insert: add to list and map. Remove: swap with last element, update map, remove last. GetRandom: pick random index from list. | Swap with last element for O(1) removal. Map ensures O(1) lookup. | Hash Map, Array List | O(1) | O(n) | `Map<Integer, Integer> valToIndex = new HashMap<>(); List<Integer> list = new ArrayList<>(); Random rand = new Random(); boolean insert(int val) { if (valToIndex.containsKey(val)) return false; valToIndex.put(val, list.size()); list.add(val); return true; } boolean remove(int val) { if (!valToIndex.containsKey(val)) return false; int idx = valToIndex.get(val); int lastVal = list.get(list.size() - 1); list.set(idx, lastVal); valToIndex.put(lastVal, idx); list.remove(list.size() - 1); valToIndex.remove(val); return true; } int getRandom() { return list.get(rand.nextInt(list.size())); }` |
| 259 | Insert Delete GetRandom O(1) - Duplicates Allowed | 381 | https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/ | Use a HashMap (`val -> Set<index>`) and ArrayList. Insert: add to list and set in map. Remove: pick an index from set, swap with last element, update set, remove last. GetRandom: random index from list. | Handle duplicates with sets of indices. Swap with last for O(1) removal. | Hash Map, Array List, Set | O(1) | O(n) | `Map<Integer, Set<Integer>> valToIndices = new HashMap<>(); List<Integer> list = new ArrayList<>(); Random rand = new Random(); boolean insert(int val) { valToIndices.computeIfAbsent(val, k -> new HashSet<>()).add(list.size()); list.add(val); return true; } boolean remove(int val) { if (!valToIndices.containsKey(val) || valToIndices.get(val).isEmpty()) return false; int idx = valToIndices.get(val).iterator().next(); valToIndices.get(val).remove(idx); int lastVal = list.get(list.size() - 1); list.set(idx, lastVal); valToIndices.computeIfAbsent(lastVal, k -> new HashSet<>()).add(idx); valToIndices.get(lastVal).remove(list.size() - 1); list.remove(list.size() - 1); return true; } int getRandom() { return list.get(rand.nextInt(list.size())); }` |
| 260 | Linked List Random Node | 382 | https://leetcode.com/problems/linked-list-random-node/ | Use reservoir sampling. Iterate through the list, keeping a reservoir (initially first node). For the i-th node, replace reservoir with probability 1/i. Ensures uniform random selection. | Reservoir sampling handles unknown list size with O(1) space. | Reservoir Sampling | O(n) | O(1) | `ListNode head; Random rand; public Solution(ListNode head) { this.head = head; rand = new Random(); } public int getRandom() { ListNode curr = head; int result = curr.val; int i = 1; while (curr.next != null) { curr = curr.next; if (rand.nextInt(++i) == 0) result = curr.val; } return result; }` |
| 261 | Shuffle an Array | 384 | https://leetcode.com/problems/shuffle-an-array/ | Use Fisher-Yates shuffle. Clone original array. For each index i from n-1 to 1, swap with a random index from 0 to i. Reset returns original array clone. | Fisher-Yates ensures unbiased permutations. Clone array for reset. | Fisher-Yates Shuffle | O(n) | O(n) | `int[] original, array; Random rand; public Solution(int[] nums) { original = nums.clone(); array = nums.clone(); rand = new Random(); } public int[] reset() { array = original.clone(); return array; } public int[] shuffle() { for (int i = array.length - 1; i > 0; i--) { int j = rand.nextInt(i + 1); int temp = array[i]; array[i] = array[j]; array[j] = temp; } return array; }` |
| 262 | Random Pick with Weight | 528 | https://leetcode.com/problems/random-pick-with-weight/ | Compute prefix sums of weights. Generate random number from 1 to total sum. Use binary search to find the index where the random number falls in prefix sums. | Prefix sums map weights to ranges. Binary search ensures O(log n) pick. | Prefix Sum, Binary Search | O(n) init, O(log n) pick | O(n) | `int[] prefixSums; Random rand; public Solution(int[] w) { prefixSums = new int[w.length]; prefixSums[0] = w[0]; for (int i = 1; i < w.length; i++) prefixSums[i] = prefixSums[i - 1] + w[i]; rand = new Random(); } public int pickIndex() { int total = prefixSums[prefixSums.length - 1]; int target = rand.nextInt(total) + 1; int low = 0, high = prefixSums.length - 1; while (low < high) { int mid = low + (high - low) / 2; if (prefixSums[mid] < target) low = mid + 1; else high = mid; } return low; }` |
| 263 | Rectangle Area | 223 | https://leetcode.com/problems/rectangle-area/ | Compute area of each rectangle. Find intersection by taking max of left/bottom and min of right/top. If intersection is valid (positive width/height), subtract its area from sum of individual areas. | Intersection requires valid width and height checks. Simple coordinate math. | Geometry, Arithmetic | O(1) | O(1) | `int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { int area1 = (ax2 - ax1) * (ay2 - ay1); int area2 = (bx2 - bx1) * (by2 - by1); int xLeft = Math.max(ax1, bx1), xRight = Math.min(ax2, bx2); int yBottom = Math.max(ay1, by1), yTop = Math.min(ay2, by2); int intersectArea = (xRight > xLeft && yTop > yBottom) ? (xRight - xLeft) * (yTop - yBottom) : 0; return area1 + area2 - intersectArea; }` |
| 264 | Minimum Area Rectangle | 939 | https://leetcode.com/problems/minimum-area-rectangle/ | Store points in a HashSet. Iterate over all pairs as potential diagonals. If x and y differ, check if other two corners exist. Compute area and track minimum. Return 0 if no rectangle found. | Diagonal points simplify corner checks. Set ensures O(1) lookup. | Hash Set, Geometry | O(n^2) | O(n) | `Set<String> pointSet = new HashSet<>(); for (int[] point : points) pointSet.add(point[0] + "," + point[1]); long minArea = Long.MAX_VALUE; for (int i = 0; i < points.length; i++) for (int j = i + 1; j < points.length; j++) { int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1]; if (x1 != x2 && y1 != y2 && pointSet.contains(x1 + "," + y2) && pointSet.contains(x2 + "," + y1)) minArea = Math.min(minArea, (long) Math.abs(x1 - x2) * Math.abs(y1 - y2)); } return minArea == Long.MAX_VALUE ? 0 : minArea;` |
| 265 | Rectangle Overlap | 836 | https://leetcode.com/problems/rectangle-overlap/ | Check if rectangles overlap by verifying that neither is completely left, right, above, or below the other. Equivalently, check `x1 < x2' && x1' > x2 && y1 < y2' && y1' > y2`. | Overlap requires intersection in both x and y axes. Simple boundary checks. | Geometry, Conditional Logic | O(1) | O(1) | `boolean isRectangleOverlap(int[] rec1, int[] rec2) { return rec1[0] < rec2[2] && rec1[2] > rec2[0] && rec1[1] < rec2[3] && rec1[3] > rec2[1]; }` |
| 266 | Minimum Height Trees | 310 | https://leetcode.com/problems/minimum-height-trees/ | Use a leaf-trimming approach (BFS). Build adjacency list and degree array. Start with leaves (degree 1). Remove leaves, update degrees, and add new leaves until 1 or 2 nodes remain. | Trim leaves layer by layer to find centroid(s). BFS ensures correctness. | Graph, BFS | O(n) | O(n) | `List<Integer> findMinHeightTrees(int n, int[][] edges) { if (n == 1) return List.of(0); List<Set<Integer>> adj = new ArrayList<>(n); for (int i = 0; i < n; i++) adj.add(new HashSet<>()); int[] degree = new int[n]; for (int[] edge : edges) { adj.get(edge[0]).add(edge[1]); adj.get(edge[1]).add(edge[0]); degree[edge[0]]++; degree[edge[1]]++; } Queue<Integer> leaves = new LinkedList<>(); for (int i = 0; i < n; i++) if (degree[i] == 1) leaves.offer(i); int remaining = n; while (remaining > 2) { int size = leaves.size(); remaining -= size; for (int i = 0; i < size; i++) { int leaf = leaves.poll(); for (int neighbor : adj.get(leaf)) if (--degree[neighbor] == 1) leaves.offer(neighbor); } } return new ArrayList<>(leaves); }` |
| 267 | Parallel Courses III | 2050 | https://leetcode.com/problems/parallel-courses-iii/ | Use topological sort (BFS) on a DAG. Build adjacency list and in-degree array. For each course, track max time to complete (own time + max prerequisite time). Process nodes with in-degree 0, updating neighbors’ times. | Topological sort ensures prerequisite order. Track max finish times dynamically. | Graph, Topological Sort | O(n + E) | O(n + E) | `int minimumTime(int n, int[][] relations, int[] time) { List<List<Integer>> adj = new ArrayList<>(n); for (int i = 0; i < n; i++) adj.add(new ArrayList<>()); int[] inDegree = new int[n]; for (int[] rel : relations) { adj.get(rel[0] - 1).add(rel[1] - 1); inDegree[rel[1] - 1]++; } Queue<Integer> q = new LinkedList<>(); long[] finishTime = new long[n]; for (int i = 0; i < n; i++) if (inDegree[i] == 0) { q.offer(i); finishTime[i] = time[i]; } while (!q.isEmpty()) { int u = q.poll(); for (int v : adj.get(u)) { finishTime[v] = Math.max(finishTime[v], finishTime[u] + time[v]); if (--inDegree[v] == 0) q.offer(v); } } long maxTime = 0; for (long ft : finishTime) maxTime = Math.max(maxTime, ft); return (int) maxTime; }` |
| 268 | Insert Interval | 57 | https://leetcode.com/problems/insert-interval/ | Iterate through intervals. Add non-overlapping intervals before newInterval. Merge overlapping intervals by updating newInterval’s start/end. Add merged interval, then remaining intervals. | Merge by taking min start and max end of overlapping intervals. | Array, Intervals | O(n) | O(n) | `List<int[]> merged = new ArrayList<>(); int i = 0; while (i < intervals.length && intervals[i][1] < newInterval[0]) merged.add(intervals[i++]); while (i < intervals.length && intervals[i][0] <= newInterval[1]) { newInterval[0] = Math.min(newInterval[0], intervals[i][0]); newInterval[1] = Math.max(newInterval[1], intervals[i][1]); i++; } merged.add(newInterval); while (i < intervals.length) merged.add(intervals[i++]); return merged.toArray(new int[merged.size()][]);` |
| 269 | Meeting Rooms | 252 | https://leetcode.com/problems/meeting-rooms/ | Sort intervals by start time. Check for overlaps by ensuring each interval’s start time is >= previous interval’s end time. | Sorting ensures consecutive interval checks catch all overlaps. | Sorting, Intervals | O(n log n) | O(1) | `Arrays.sort(intervals, (a, b) -> a[0] - b[0]); for (int i = 1; i < intervals.length; i++) if (intervals[i][0] < intervals[i - 1][1]) return false; return true;` |
| 270 | Meeting Rooms II | 253 | https://leetcode.com/problems/meeting-rooms-ii/ | Sort intervals by start time. Use a min-heap to track end times of ongoing meetings. For each meeting, if it starts after the earliest end time, reuse a room (remove earliest). Add current end time. Heap size is room count. | Min-heap tracks active meetings. Reuse rooms when possible. | Sorting, Priority Queue | O(n log n) | O(n) | `Arrays.sort(intervals, (a, b) -> a[0] - b[0]); PriorityQueue<Integer> endTimes = new PriorityQueue<>(); endTimes.offer(intervals[0][1]); for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] >= endTimes.peek()) endTimes.poll(); endTimes.offer(intervals[i][1]); } return endTimes.size();` |


| Sr. No. | Problem Name | LeetCode Number | Link | Approach Detail | Trick | Pattern | Time Complexity | Space Complexity | Critical Code Snippet (Java) |
|---------|--------------|-----------------|------|-----------------|-------|---------|-----------------|------------------|-----------------------------|
| 271 | Employee Free Time | 759 | https://leetcode.com/problems/employee-free-time/ | Flatten all intervals from employee schedules into one list. Sort by start time. Merge overlapping intervals by tracking the latest end time. Gaps between merged intervals are free times. Handle edge cases: empty schedules or no gaps. | Merge overlapping intervals after sorting. Gaps between merged intervals are the answer. | Intervals, Sorting, Merging Intervals | O(N log N) | O(N) | `List<Interval> allIntervals = new ArrayList<>(); for (List<Interval> schedule : schedule) allIntervals.addAll(schedule); Collections.sort(allIntervals, (a, b) -> a.start - b.start); List<Interval> freeTime = new ArrayList<>(); if (allIntervals.isEmpty()) return freeTime; int prevEnd = allIntervals.get(0).end; for (int i = 1; i < allIntervals.size(); i++) { if (allIntervals.get(i).start > prevEnd) freeTime.add(new Interval(prevEnd, allIntervals.get(i).start)); prevEnd = Math.max(prevEnd, allIntervals.get(i).end); } return freeTime;` |
| 272 | Interval List Intersections | 986 | https://leetcode.com/problems/interval-list-intersections/ | Use two pointers to iterate through both sorted interval lists. For each pair, compute intersection by taking max of starts and min of ends. If intersection is valid (start ≤ end), add to result. Advance pointer of interval with earlier end. Handle empty lists. | Two pointers exploit sorted intervals. Intersection is max(starts) to min(ends). | Two Pointers, Intervals | O(m + n) | O(1) (excluding result) | `List<int[]> result = new ArrayList<>(); int i = 0, j = 0; while (i < firstList.length && j < secondList.length) { int start = Math.max(firstList[i][0], secondList[j][0]); int end = Math.min(firstList[i][1], secondList[j][1]); if (start <= end) result.add(new int[]{start, end}); if (firstList[i][1] < secondList[j][1]) i++; else j++; } return result.toArray(new int[result.size()][]);` |
| 273 | Meeting Scheduler | 1229 | https://leetcode.com/problems/meeting-scheduler/ | Use two pointers on sorted slot lists. For each pair, compute intersection (max of starts, min of ends). If intersection duration ≥ required duration, return first valid slot. Advance pointer of earlier-ending slot. Handle no valid slot. | Intersection of slots must cover duration. Two pointers minimize checks. | Two Pointers, Intervals | O(m log m + n log n) | O(1) | `int i = 0, j = 0; while (i < slots1.length && j < slots2.length) { int start = Math.max(slots1[i][0], slots2[j][0]); int end = Math.min(slots1[i][1], slots2[j][1]); if (start + duration <= end) return new int[]{start, start + duration}; if (slots1[i][1] < slots2[j][1]) i++; else j++; } return new int[]{};` |
| 274 | Count Days Without Meetings | 3169 | https://leetcode.com/problems/count-days-without-meetings/ | Sort meetings by start time. Merge overlapping intervals by tracking latest end time. Sum lengths of merged intervals (days covered). Subtract from total days. Handle edge cases: empty meetings or meetings exceeding days. | Merge overlapping intervals to find covered days. Subtract from total days. | Intervals, Sorting, Merging Intervals | O(n log n) | O(1) | `Arrays.sort(meetings, (a, b) -> a[0] - b[0]); int coveredDays = 0, prevEnd = -1; for (int[] meeting : meetings) { int start = Math.max(prevEnd + 1, meeting[0]), end = meeting[1]; if (start <= end) coveredDays += end - start + 1; prevEnd = Math.max(prevEnd, end); } return days - coveredDays;` |
| 275 | Meeting Rooms III | 2402 | https://leetcode.com/problems/meeting-rooms-iii/ | Sort meetings by start time. Use two min-heaps: one for available rooms (by index), one for busy rooms (by end time, then index). For each meeting, free rooms whose end times ≤ start time. If available rooms exist, use smallest index; else, use earliest-ending room, updating its end time. Track room usage. Return room with max usage. | Two heaps manage room allocation. Greedy choice of earliest available or ending room. | Sorting, Priority Queue, Greedy | O(n log n + m log m) | O(m) | `PriorityQueue<Integer> available = new PriorityQueue<>(); PriorityQueue<long[]> busy = new PriorityQueue<>((a, b) -> a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1])); int[] usage = new int[n]; for (int i = 0; i < n; i++) available.offer(i); Arrays.sort(meetings, (a, b) -> a[0] - b[0]); for (int[] meeting : meetings) { long start = meeting[0], end = meeting[1]; while (!busy.isEmpty() && busy.peek()[0] <= start) available.offer((int) busy.poll()[1]); int room; if (!available.isEmpty()) room = available.poll(); else { long[] earliest = busy.poll(); room = (int) earliest[1]; end = earliest[0] + (end - start); } busy.offer(new long[]{end, room}); usage[room]++; } int maxRoom = 0; for (int i = 1; i < n; i++) if (usage[i] > usage[maxRoom]) maxRoom = i; return maxRoom;` |
| 276 | Binary Search Tree Iterator | 173 | https://leetcode.com/problems/binary-search-tree-iterator/ | Use a stack for inorder traversal. Initialize by pushing root and all left children. `next()` pops top node, returns value, pushes right child and its left children. `hasNext()` checks stack emptiness. | Stack simulates inorder traversal, pushing left children for next smallest. | Tree Traversal, Stack, Design | O(1) amortized | O(h) | `Stack<TreeNode> stack = new Stack<>(); public BSTIterator(TreeNode root) { pushLeft(root); } private void pushLeft(TreeNode node) { while (node != null) { stack.push(node); node = node.left; } } public int next() { TreeNode node = stack.pop(); pushLeft(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); }` |
| 277 | Convert Binary Search Tree to Sorted Doubly Linked List | 426 | https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/ | Use inorder traversal to visit nodes in sorted order. Track `first` (head) and `prev` (last processed node). Link `prev.right` to current, `current.left` to `prev`. After traversal, connect `first` and last node for circular list. | Inorder traversal ensures sorted order. Track prev to link nodes dynamically. | Tree Traversal, Doubly Linked List | O(n) | O(h) | `Node first = null, prev = null; public Node treeToDoublyList(Node root) { if (root == null) return null; inorder(root); prev.right = first; first.left = prev; return first; } private void inorder(Node node) { if (node == null) return; inorder(node.left); if (prev == null) first = node; else { prev.right = node; node.left = prev; } prev = node; inorder(node.right); }` |
| 278 | Inorder Successor in BST II | 510 | https://leetcode.com/problems/inorder-successor-in-bst-ii/ | If node has right child, successor is leftmost node in right subtree. Else, traverse up until moving from left child to parent (or null). Handle edge cases: no successor or single node. | Right subtree’s leftmost node or first left-to-parent ancestor. | Tree Traversal, Parent Pointers | O(h) | O(1) | `Node inorderSuccessor(Node node) { if (node.right != null) { Node curr = node.right; while (curr.left != null) curr = curr.left; return curr; } Node curr = node; while (curr.parent != null && curr == curr.parent.right) curr = curr.parent; return curr.parent; }` |
| 279 | Closest Binary Search Tree Value | 270 | https://leetcode.com/problems/closest-binary-search-tree-value/ | Traverse BST iteratively. At each node, update closest if current value is closer to target. Move left if target < value, else right. Handle edge cases: empty tree or exact match. | BST properties guide traversal toward target. Update closest on smaller differences. | Tree Traversal, Binary Search | O(h) | O(1) | `int closest = root.val; TreeNode curr = root; while (curr != null) { closest = Math.abs(target - curr.val) < Math.abs(target - closest) ? curr.val : closest; curr = target < curr.val ? curr.left : curr.right; } return closest;` |
| 280 | Closest Binary Search Tree Value II | 272 | https://leetcode.com/problems/closest-binary-search-tree-value-ii/ | Use two stacks: one for inorder traversal (≤ target), one for reverse inorder (> target). Initialize by pushing nodes along paths. Pop from stack with value closer to target, add to result, push next nodes. Repeat k times. | Two stacks simulate inorder and reverse inorder, picking closest values. | Tree Traversal, Two Stacks | O(h + k) | O(h) | `Stack<TreeNode> s1 = new Stack<>(), s2 = new Stack<>(); List<Integer> result = new ArrayList<>(); pushLess(root, target, s1); pushGreater(root, target, s2); while (k-- > 0 && (!s1.isEmpty() || !s2.isEmpty())) { double diff1 = s1.isEmpty() ? Double.MAX_VALUE : target - s1.peek().val; double diff2 = s2.isEmpty() ? Double.MAX_VALUE : s2.peek().val - target; if (diff1 <= diff2) { TreeNode node = s1.pop(); result.add(node.val); pushLess(node.right, target, s1); } else { TreeNode node = s2.pop(); result.add(node.val); pushGreater(node.left, target, s2); } } return result; void pushLess(TreeNode node, double target, Stack<TreeNode> stack) { while (node != null) { if (node.val <= target) stack.push(node); node = node.val <= target ? node.left : node.right; } } void pushGreater(TreeNode node, double target, Stack<TreeNode> stack) { while (node != null) { if (node.val > target) stack.push(node); node = node.val > target ? node.right : node.left; } }` |
| 281 | Verify Preorder Sequence in Binary Search Tree | 255 | https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/ | Use stack to track nodes in right subtrees. Maintain lower bound. For each value, ensure it’s > lower bound. If > stack top, pop and update lower bound to last popped (parent of right subtree). Push current value. | Stack tracks right subtree parents. Lower bound ensures BST property. | Stack, BST Properties | O(n) | O(n) | `Stack<Integer> stack = new Stack<>(); int lowerBound = Integer.MIN_VALUE; for (int val : preorder) { if (val < lowerBound) return false; while (!stack.isEmpty() && val > stack.peek()) lowerBound = stack.pop(); stack.push(val); } return true;` |
| 282 | Verify Preorder Serialization of a Binary Tree | 331 | https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/ | Track available slots (initially 1 for root). For each node, consume 1 slot. Non-null nodes add 2 slots; null nodes (#) add 0. Slots must not go negative and must be 0 at end. | Slots represent available child positions. Non-null adds 2, null consumes 1. | String Parsing, Tree Properties | O(n) | O(1) | `int slots = 1; String[] nodes = preorder.split(","); for (String node : nodes) { slots--; if (slots < 0) return false; if (!node.equals("#")) slots += 2; } return slots == 0;` |
| 283 | Implementing Forward Iterator in BST | N/A | https://www.geeksforgeeks.org/implementing-forward-iterator-in-bst/ | Same as BST Iterator (276). Use stack for inorder traversal. Initialize by pushing root and left children. `next()` pops node, returns value, pushes right child and its left children. `hasNext()` checks stack. | Stack maintains inorder sequence. Push left children for next smallest. | Tree Traversal, Stack, Design | O(1) amortized | O(h) | `Stack<TreeNode> stack = new Stack<>(); public BSTIterator(TreeNode root) { pushLeft(root); } private void pushLeft(TreeNode node) { while (node != null) { stack.push(node); node = node.left; } } public int next() { TreeNode node = stack.pop(); pushLeft(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); }` |
| 284 | Kth Smallest Element in BST Using O(1) Extra Space | N/A | https://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/ | Use Morris inorder traversal. Temporarily thread predecessors to current node. Count nodes visited. When k-th node is reached, return its value. Restore tree by breaking threads. | Morris traversal avoids stack/recursion by threading. Count nodes in inorder. | Tree Traversal, Morris Inorder | O(n) | O(1) | `TreeNode curr = root; int count = 0; while (curr != null) { if (curr.left == null) { if (++count == k) return curr.val; curr = curr.right; } else { TreeNode pred = curr.left; while (pred.right != null && pred.right != curr) pred = pred.right; if (pred.right == null) { pred.right = curr; curr = curr.left; } else { pred.right = null; if (++count == k) return curr.val; curr = curr.right; } } } return -1;` |
| 285 | Construct BST from Given Preorder Traversal | N/A | https://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-1/ | Iterative approach with stack. Push root. For each value, if < stack top, it’s left child; push it. If > stack top, pop until stack empty or top < value; last popped is parent, current is its right child. Push current. | Stack tracks rightmost path. Compare with top to decide left/right child. | Stack, Tree Construction | O(n) | O(n) | `Stack<TreeNode> stack = new Stack<>(); TreeNode root = new TreeNode(preorder[0]); stack.push(root); for (int i = 1; i < preorder.length; i++) { TreeNode node = new TreeNode(preorder[i]); TreeNode parent = null; while (!stack.isEmpty() && node.val > stack.peek().val) parent = stack.pop(); if (parent != null) parent.right = node; else stack.peek().left = node; stack.push(node); } return root;` |
| 286 | Count BST Subtrees that Lie in Given Range | N/A | https://www.geeksforgeeks.org/count-bst-subtrees-that-lie-in-given-range/ | Post-order traversal. For each node, check if entire subtree is within [low, high] by ensuring node value and all descendants are in range. If valid, increment count. Use helper to verify subtree validity. | Validate entire subtree recursively. Count valid subtrees in post-order. | Tree Traversal, Recursion | O(n) | O(h) | `int count = 0; public int countValidSubtrees(TreeNode root, int low, int high) { countValidSubtrees(root, low, high); return count; } private void countValidSubtrees(TreeNode node, int low, int high) { if (node == null) return; if (isValid(node, low, high)) count++; countValidSubtrees(node.left, low, high); countValidSubtrees(node.right, low, high); } private boolean isValid(TreeNode node, int low, int high) { if (node == null) return true; if (node.val < low || node.val > high) return false; return isValid(node.left, low, high) && isValid(node.right, low, high); }` |
| 287 | Largest BST in a Binary Tree | N/A | https://www.geeksforgeeks.org/find-the-largest-bst-subtree-in-a-binary-tree/ | Post-order traversal. For each node, get from children: isBST, size, min, max. If current node forms BST (left.isBST, right.isBST, node.val > left.max, node.val < right.min), compute size and update max BST size. Else, propagate max child size. | Post-order combines child info to validate BST and track largest size. | Tree Traversal, Postorder | O(n) | O(h) | `class Result { boolean isBST; int size, min, max; Result(boolean isBST, int size, int min, int max) { this.isBST = isBST; this.size = size; this.min = min; this.max = max; } } int maxSize = 0; public int largestBST(TreeNode root) { largestBSTUtil(root); return maxSize; } private Result largestBSTUtil(TreeNode node) { if (node == null) return new Result(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE); Result left = largestBSTUtil(node.left); Result right = largestBSTUtil(node.right); if (left.isBST && right.isBST && node.val > left.max && node.val < right.min) { int size = left.size + right.size + 1; maxSize = Math.max(maxSize, size); return new Result(true, size, Math.min(node.val, left.min), Math.max(node.val, right.max)); } return new Result(false, Math.max(left.size, right.size), 0, 0); }` |
| 288 | Check if Given Array Can Represent Level Order Traversal of Binary Search Tree | N/A | https://www.geeksforgeeks.org/check-if-given-array-can-represent-level-order-traversal-of-binary-search-tree/ | Use queue to simulate level-order construction. For each node, track valid range [min, max]. Dequeue node; next array elements are left/right children. Ensure they fit BST ranges (left: [min, parent), right: (parent, max]). Enqueue valid children. Check all elements used. | Queue tracks nodes and ranges. Validate children against BST constraints. | Queue, Level Order Traversal | O(n) | O(n) | `class NodeInfo { int val, min, max; NodeInfo(int val, int min, int max) { this.val = val; this.min = min; this.max = max; } } Queue<NodeInfo> q = new LinkedList<>(); q.offer(new NodeInfo(arr[0], Integer.MIN_VALUE, Integer.MAX_VALUE)); int i = 1; while (!q.isEmpty() && i < arr.length) { NodeInfo curr = q.poll(); if (i < arr.length && arr[i] > curr.min && arr[i] < curr.val) { q.offer(new NodeInfo(arr[i], curr.min, curr.val)); i++; } else if (i < arr.length && (arr[i] <= curr.min || arr[i] >= curr.val)) return false; if (i < arr.length && arr[i] > curr.val && arr[i] < curr.max) { q.offer(new NodeInfo(arr[i], curr.val, curr.max)); i++; } else if (i < arr.length && (arr[i] <= curr.val || arr[i] >= curr.max)) return false; } return i == arr.length;` |
| 289 | Next Permutation | 31 | https://leetcode.com/problems/next-permutation/ | Find largest k where nums[k] < nums[k+1]. If none, reverse array. Find largest l > k where nums[k] < nums[l]. Swap nums[k] and nums[l]. Reverse from k+1 to end. | Find pivot, swap with next greater element, reverse suffix for next permutation. | Array Manipulation, In-place Algorithm | O(n) | O(1) | `int k = nums.length - 2; while (k >= 0 && nums[k] >= nums[k + 1]) k--; if (k < 0) { reverse(nums, 0, nums.length - 1); return; } int l = nums.length - 1; while (l > k && nums[l] <= nums[k]) l--; swap(nums, k, l); reverse(nums, k + 1, nums.length - 1); void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } void reverse(int[] nums, int start, int end) { while (start < end) swap(nums, start++, end--); }` |
| 290 | Remove Duplicates from Sorted Array | 26 | https://leetcode.com/problems/remove-duplicates-from-sorted-array/ | Use two pointers: i for next unique element position, j to scan array. If nums[j] != nums[i-1], copy to nums[i] and increment i. Return i. Handle empty/single-element arrays. | Two pointers: write unique elements while scanning sorted array. | Two Pointers, Array Manipulation | O(n) | O(1) | `if (nums.length == 0) return 0; int i = 1; for (int j = 1; j < nums.length; j++) { if (nums[j] != nums[i - 1]) nums[i++] = nums[j]; } return i;` |
| 291 | Remove Element | 27 | https://leetcode.com/problems/remove-element/ | Use two pointers: i for next non-val position, j to scan array. If nums[j] != val, copy to nums[i] and increment i. Return i. Handle empty array. | Two pointers: write non-val elements while scanning. | Two Pointers, Array Manipulation | O(n) | O(1) | `int i = 0; for (int j = 0; j < nums.length; j++) { if (nums[j] != val) nums[i++] = nums[j]; } return i;` |
| 292 | First Missing Positive | 41 | https://leetcode.com/problems/first-missing-positive/ | Use array as hash table. For each nums[i], if 1 ≤ nums[i] ≤ n, place at index nums[i]-1 via swaps. First index i where nums[i] != i+1 gives missing i+1. Else, n+1. | Array as hash: place x at index x-1. First mismatch reveals missing positive. | Array Manipulation, In-place Hash | O(n) | O(1) | `int n = nums.length; for (int i = 0; i < n; i++) { while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { int temp = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = temp; } } for (int i = 0; i < n; i++) { if (nums[i] != i + 1) return i + 1; } return n + 1;` |
| 293 | Missing Number | 268 | https://leetcode.com/problems/missing-number/ | Use XOR: XOR all numbers 0 to n with array elements. Paired numbers cancel, leaving missing number. Alternatively, use sum: n*(n+1)/2 minus array sum. | XOR cancels paired numbers, revealing missing one. | Bit Manipulation, Arithmetic | O(n) | O(1) | `int result = nums.length; for (int i = 0; i < nums.length; i++) result ^= i ^ nums[i]; return result;` |
| 294 | Maximum Product Subarray | 152 | https://leetcode.com/problems/maximum-product-subarray/ | Track max and min products ending at each index, as negative numbers can swap their roles. Update maxProd, minProd with current number and products. Track global max. | Maintain max/min products to handle negative numbers. Update global max. | Dynamic Programming | O(n) | O(1) | `int maxProd = nums[0], minProd = nums[0], result = nums[0]; for (int i = 1; i < nums.length; i++) { int num = nums[i]; if (num < 0) { int temp = maxProd; maxProd = minProd; minProd = temp; } maxProd = Math.max(num, maxProd * num); minProd = Math.min(num, minProd * num); result = Math.max(result, maxProd); } return result;` |
| 295 | Find the Smallest Positive Number Missing from an Unsorted Array | N/A | https://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/ | Identical to First Missing Positive (292). Use array as hash table. Place nums[i] at index nums[i]-1 if 1 ≤ nums[i] ≤ n. First nums[i] != i+1 gives i+1, else n+1. | Array as hash: place x at x-1. Mismatch reveals smallest missing positive. | Array Manipulation, In-place Hash | O(n) | O(1) | `int n = arr.length; for (int i = 0; i < n; i++) { while (arr[i] > 0 && arr[i] <= n && arr[arr[i] - 1] != arr[i]) { int temp = arr[arr[i] - 1]; arr[arr[i] - 1] = arr[i]; arr[i] = temp; } } for (int i = 0; i < n; i++) { if (arr[i] != i + 1) return i + 1; } return n + 1;` |
| 296 | Find a Repeating and a Missing Number | N/A | https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/ | Use array as markers. For each abs(arr[i]), mark index abs(arr[i])-1 by negating. If already negative, abs(arr[i]) is repeating. After, positive index i means i+1 is missing. | Negate indices to mark visits. Repeated visits reveal repeating; positive indices reveal missing. | Array Manipulation, In-place Markers | O(n) | O(1) | `int repeating = -1, missing = -1; for (int i = 0; i < arr.length; i++) { int index = Math.abs(arr[i]) - 1; if (arr[index] > 0) arr[index] = -arr[index]; else repeating = Math.abs(arr[i]); } for (int i = 0; i < arr.length; i++) { if (arr[i] > 0) { missing = i + 1; break; } } return new int[]{repeating, missing};` |
| 297 | Make Array Non-decreasing | 3165 | https://leetcode.com/problems/make-array-non-decreasing/ | Check if array can be non-decreasing with ≤ 1 modification. Count violations (nums[i] > nums[i+1]). If > 1, return false. For one violation, try decreasing nums[i] if nums[i-1] ≤ nums[i+1]; else, increase nums[i+1]. | Greedy fix at first violation: decrease i or increase i+1 based on neighbors. | Array Iteration, Greedy | O(n) | O(1) | `int violations = 0; for (int i = 0; i < nums.length - 1; i++) { if (nums[i] > nums[i + 1]) { if (violations++ > 0) return false; if (i > 0 && nums[i - 1] > nums[i + 1]) nums[i + 1] = nums[i]; else nums[i] = nums[i + 1]; } } return true;` |
| 298 | Minimum Operations to Make Numbers Non-positive | 2606 | https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal-to-0/ | For each operation, select a subarray and subtract 1 from its elements. Greedy approach: for each positive element, apply operation to minimal subarray starting at its index. Track operations needed per prefix. | Each positive element requires an operation starting at its index or earlier. | Array Iteration, Greedy | O(n) | O(1) | `int count = 0; for (int i = 0; i < nums.length; i++) { if (nums[i] > 0) { count++; nums[i]--; } } return count;` |
| 299 | Minimum Operations to Reduce an Integer to 0 | 2571 | https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/ | Use binary representation. For each set bit, decide to subtract 2^i or add 2^i to clear it. Greedy: for consecutive 1s, adding higher power (carry) is often optimal. Count operations while shifting bits. | Greedy bit manipulation: clear lowest 1 by subtracting or adding based on bit pattern. | Bit Manipulation, Greedy | O(log n) | O(1) | `int ops = 0; while (n > 0) { if ((n & 1) == 0) n >>= 1; else if ((n & 2) == 0) { n >>= 1; ops++; } else { n++; ops++; } } return ops;` |
| 300 | Minimum Number of Operations to Make Elements in Array Distinct | 3168 | https://leetcode.com/problems/minimum-number-of-operations-to-make-array-elements-distinct/ | Sort array. Iterate: if nums[i] ≤ nums[i-1], increment nums[i] to nums[i-1]+1. Sum increments. Track operations without modifying array by using expected value. | After sorting, ensure each element is > previous by incrementing. Sum increments. | Sorting, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); long moves = 0, prev = nums[0]; for (int i = 1; i < nums.length; i++) { if (nums[i] <= prev) { moves += prev + 1 - nums[i]; prev++; } else prev = nums[i]; } return (int) moves;` |
| 301 | Minimum Pair Removal to Sort Array I | 3172 | https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/ | Minimum removals = n - length of longest non-decreasing subsequence (LNDS). Use patience sorting: maintain tails of non-decreasing subsequences via binary search. | LNDS length via patience sorting. Removals = n - LNDS length. | Dynamic Programming, Binary Search | O(n log n) | O(n) | `List<Integer> tails = new ArrayList<>(); for (int num : nums) { int low = 0, high = tails.size(); while (low < high) { int mid = low + (high - low) / 2; if (tails.get(mid) <= num) low = mid + 1; else high = mid; } if (low == tails.size()) tails.add(num); else tails.set(low, num); } return nums.length - tails.size();` |
| 302 | Minimum Array Length After Pair Removals | 2856 | https://leetcode.com/problems/minimum-array-length-after-pair-removals/ | Sort array. Use two pointers: i from start, j from middle. Pair nums[i] with nums[j] if nums[i] < nums[j]. Count pairs. Remaining length = n - 2 * pairs. | Pair smallest with larger elements from second half. Count pairs to find remaining length. | Sorting, Two Pointers, Greedy | O(n log n) | O(1) | `Arrays.sort(nums); int n = nums.length, count = 0, i = 0, j = (n + 1) / 2; while (i < (n + 1) / 2 && j < n) { if (nums[i] < nums[j]) { count++; i++; j++; } else j++; } return n - 2 * count;` |
| 303 | Zero Array Transformation I | N/A | https://www.geeksforgeeks.org/zero-array-transformation-i/ | Assuming operation: subtract 1 from elements ≥ index i to make all zeros. For each positive element, an operation starting at its index is needed. Count operations by iterating and decrementing positive elements. | Each positive element requires an operation starting at its index or earlier. | Array Iteration, Greedy | O(n) | O(1) | `int count = 0; for (int i = 0; i < arr.length; i++) { if (arr[i] > 0) { count++; arr[i]--; } } return count;` |
| 304 | Remove Stones to Minimize the Total | 1962 | https://leetcode.com/problems/remove-stones-to-minimize-the-total/ | Use max-heap to track pile sizes. For k operations, remove max pile, reduce by floor(size/2), reinsert. Sum remaining piles. | Max-heap ensures largest pile is reduced, maximizing stone removal. | Priority Queue, Greedy | O(k log n) | O(n) | `PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a); for (int pile : piles) pq.offer(pile); for (int i = 0; i < k; i++) { int max = pq.poll(); pq.offer(max - max / 2); } int total = 0; while (!pq.isEmpty()) total += pq.poll(); return total;` |
| 305 | Sort an Array | 912 | https://leetcode.com/problems/sort-an-array/ | Use Merge Sort for guaranteed O(n log n). Divide array, recursively sort halves, merge by comparing elements. Handle base case (size ≤ 1). | Merge Sort divides, sorts, and merges for stable O(n log n) sorting. | Sorting, Merge Sort | O(n log n) | O(n) | `public int[] sortArray(int[] nums) { mergeSort(nums, 0, nums.length - 1); return nums; } private void mergeSort(int[] nums, int left, int right) { if (left >= right) return; int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); merge(nums, left, mid, right); } private void merge(int[] nums, int left, int mid, int right) { int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; while (i <= mid && j <= right) temp[k++] = nums[i] <= nums[j] ? nums[i++] : nums[j++]; while (i <= mid) temp[k++] = nums[i++]; while (j <= right) temp[k++] = nums[j++]; for (k = 0; k < temp.length; k++) nums[left + k] = temp[k]; }` |
| 306 | Sort Transformed Array | 360 | https://leetcode.com/problems/sort-transformed-array/ | Apply f(x) = ax² + bx + c to sorted array. If a ≥ 0, parabola opens up, max values at ends; if a < 0, min values at ends. Use two pointers (start, end) to fill result array from end (a ≥ 0) or start (a < 0). | Two pointers leverage parabola shape. Fill result from extremes based on a. | Two Pointers, Math | O(n) | O(n) | `int[] result = new int[nums.length]; int i = 0, j = nums.length - 1, k = a >= 0 ? nums.length - 1 : 0; while (i <= j) { int leftVal = a * nums[i] * nums[i] + b * nums[i] + c; int rightVal = a * nums[j] * nums[j] + b * nums[j] + c; if (a >= 0) { result[k--] = leftVal >= rightVal ? leftVal : rightVal; if (leftVal >= rightVal) i++; else j--; } else { result[k++] = leftVal <= rightVal ? leftVal : rightVal; if (leftVal <= rightVal) i++; else j--; } } return result;` |
| 307 | Nearly Sorted Algorithm (Sort a K-Sorted Array) | N/A | https://www.geeksforgeeks.org/nearly-sorted-algorithm/ | Use min-heap of size k+1. Add first k+1 elements. For each remaining element, extract min, add to result, insert next element. Extract remaining heap elements. | Min-heap maintains k+1 elements, ensuring smallest is next in sorted order. | Priority Queue, Sorting | O(n log k) | O(k) | `PriorityQueue<Integer> pq = new PriorityQueue<>(); for (int i = 0; i < Math.min(k + 1, arr.length); i++) pq.offer(arr[i]); int index = 0; for (int i = k + 1; i < arr.length; i++) { arr[index++] = pq.poll(); pq.offer(arr[i]); } while (!pq.isEmpty()) arr[index++] = pq.poll();` |
| 308 | Shuffle a Given Array Using Fisher-Yates Shuffle Algorithm | N/A | https://www.geeksforgeeks.org/shuffle-a-given-array-using-fisher-yates-shuffle-algorithm/ | Fisher-Yates shuffle: iterate from end to start. For each index i, swap with random index from 0 to i. Ensures uniform randomization. | Swap with random index in remaining unshuffled portion for unbiased shuffle. | Fisher-Yates Shuffle | O(n) | O(1) | `Random rand = new Random(); for (int i = arr.length - 1; i > 0; i--) { int j = rand.nextInt(i + 1); int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }` |
| 309 | Find Index of 0 to be Replaced with 1 to Get Longest Continuous Sequence of 1s in a Binary Array | N/A | https://www.geeksforgeeks.org/find-index-of-0-to-be-replaced-with-1-to-get-longest-continuous-sequence-of-1s-in-a-binary-array/ | Track current and previous sequences of 1s separated by a 0. When a 0 is encountered, compute length if flipped (prevOnes + currOnes + 1). Update max length and index. | Track 1s segments around a 0. Flipping 0 combines segments for max length. | Sliding Window, Array Iteration | O(n) | O(1) | `int maxLen = 0, index = -1, currOnes = 0, prevOnes = 0; for (int i = 0; i < arr.length; i++) { if (arr[i] == 1) currOnes++; else { if (currOnes + prevOnes + 1 > maxLen) { maxLen = currOnes + prevOnes + 1; index = i; } prevOnes = currOnes; currOnes = 0; } } if (currOnes + prevOnes + 1 > maxLen) { maxLen = currOnes + prevOnes + 1; index = arr.length - 1; } return index;` |
| 310 | Rearrange Array Maximum Minimum Form | N/A | https://www.geeksforgeeks.org/rearrange-array-maximum-minimum-form/ | Sort array. Use two pointers: one at start (min), one at end (max). Fill result array alternating max, min. For O(1) space, encode max/min in array using modular arithmetic (maxVal + 1). | Alternate max/min from sorted array. Encode for O(1) space using modular trick. | Two Pointers, Array Manipulation | O(n log n) or O(n) with encoding | O(n) or O(1) | `Arrays.sort(arr); int[] result = new int[arr.length]; int i = 0, j = arr.length - 1, k = 0; while (i <= j) { if (k % 2 == 0) result[k++] = arr[j--]; else result[k++] = arr[i++]; } return result;` |








